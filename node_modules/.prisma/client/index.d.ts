
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Lead
 * 
 */
export type Lead = $Result.DefaultSelection<Prisma.$LeadPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model CampaignLead
 * 
 */
export type CampaignLead = $Result.DefaultSelection<Prisma.$CampaignLeadPayload>
/**
 * Model EmailTemplate
 * 
 */
export type EmailTemplate = $Result.DefaultSelection<Prisma.$EmailTemplatePayload>
/**
 * Model EmailEvent
 * 
 */
export type EmailEvent = $Result.DefaultSelection<Prisma.$EmailEventPayload>
/**
 * Model Website
 * 
 */
export type Website = $Result.DefaultSelection<Prisma.$WebsitePayload>
/**
 * Model Video
 * 
 */
export type Video = $Result.DefaultSelection<Prisma.$VideoPayload>
/**
 * Model ApiKey
 * 
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model CannedResponse
 * 
 */
export type CannedResponse = $Result.DefaultSelection<Prisma.$CannedResponsePayload>
/**
 * Model AutoResponse
 * 
 */
export type AutoResponse = $Result.DefaultSelection<Prisma.$AutoResponsePayload>
/**
 * Model ConversationNote
 * 
 */
export type ConversationNote = $Result.DefaultSelection<Prisma.$ConversationNotePayload>
/**
 * Model SystemHealthMetric
 * 
 */
export type SystemHealthMetric = $Result.DefaultSelection<Prisma.$SystemHealthMetricPayload>
/**
 * Model DiagnosticReport
 * 
 */
export type DiagnosticReport = $Result.DefaultSelection<Prisma.$DiagnosticReportPayload>
/**
 * Model RepairHistory
 * 
 */
export type RepairHistory = $Result.DefaultSelection<Prisma.$RepairHistoryPayload>
/**
 * Model LearningPattern
 * 
 */
export type LearningPattern = $Result.DefaultSelection<Prisma.$LearningPatternPayload>
/**
 * Model Prediction
 * 
 */
export type Prediction = $Result.DefaultSelection<Prisma.$PredictionPayload>
/**
 * Model SecurityIncident
 * 
 */
export type SecurityIncident = $Result.DefaultSelection<Prisma.$SecurityIncidentPayload>
/**
 * Model PerformanceMetric
 * 
 */
export type PerformanceMetric = $Result.DefaultSelection<Prisma.$PerformanceMetricPayload>
/**
 * Model SystemAlert
 * 
 */
export type SystemAlert = $Result.DefaultSelection<Prisma.$SystemAlertPayload>
/**
 * Model AdminUser
 * 
 */
export type AdminUser = $Result.DefaultSelection<Prisma.$AdminUserPayload>
/**
 * Model AdminAuditLog
 * 
 */
export type AdminAuditLog = $Result.DefaultSelection<Prisma.$AdminAuditLogPayload>
/**
 * Model AdminSession
 * 
 */
export type AdminSession = $Result.DefaultSelection<Prisma.$AdminSessionPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **Lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.LeadDelegate<ExtArgs>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs>;

  /**
   * `prisma.campaignLead`: Exposes CRUD operations for the **CampaignLead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignLeads
    * const campaignLeads = await prisma.campaignLead.findMany()
    * ```
    */
  get campaignLead(): Prisma.CampaignLeadDelegate<ExtArgs>;

  /**
   * `prisma.emailTemplate`: Exposes CRUD operations for the **EmailTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailTemplates
    * const emailTemplates = await prisma.emailTemplate.findMany()
    * ```
    */
  get emailTemplate(): Prisma.EmailTemplateDelegate<ExtArgs>;

  /**
   * `prisma.emailEvent`: Exposes CRUD operations for the **EmailEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailEvents
    * const emailEvents = await prisma.emailEvent.findMany()
    * ```
    */
  get emailEvent(): Prisma.EmailEventDelegate<ExtArgs>;

  /**
   * `prisma.website`: Exposes CRUD operations for the **Website** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Websites
    * const websites = await prisma.website.findMany()
    * ```
    */
  get website(): Prisma.WebsiteDelegate<ExtArgs>;

  /**
   * `prisma.video`: Exposes CRUD operations for the **Video** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos
    * const videos = await prisma.video.findMany()
    * ```
    */
  get video(): Prisma.VideoDelegate<ExtArgs>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeys
    * const apiKeys = await prisma.apiKey.findMany()
    * ```
    */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.cannedResponse`: Exposes CRUD operations for the **CannedResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CannedResponses
    * const cannedResponses = await prisma.cannedResponse.findMany()
    * ```
    */
  get cannedResponse(): Prisma.CannedResponseDelegate<ExtArgs>;

  /**
   * `prisma.autoResponse`: Exposes CRUD operations for the **AutoResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutoResponses
    * const autoResponses = await prisma.autoResponse.findMany()
    * ```
    */
  get autoResponse(): Prisma.AutoResponseDelegate<ExtArgs>;

  /**
   * `prisma.conversationNote`: Exposes CRUD operations for the **ConversationNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationNotes
    * const conversationNotes = await prisma.conversationNote.findMany()
    * ```
    */
  get conversationNote(): Prisma.ConversationNoteDelegate<ExtArgs>;

  /**
   * `prisma.systemHealthMetric`: Exposes CRUD operations for the **SystemHealthMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemHealthMetrics
    * const systemHealthMetrics = await prisma.systemHealthMetric.findMany()
    * ```
    */
  get systemHealthMetric(): Prisma.SystemHealthMetricDelegate<ExtArgs>;

  /**
   * `prisma.diagnosticReport`: Exposes CRUD operations for the **DiagnosticReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiagnosticReports
    * const diagnosticReports = await prisma.diagnosticReport.findMany()
    * ```
    */
  get diagnosticReport(): Prisma.DiagnosticReportDelegate<ExtArgs>;

  /**
   * `prisma.repairHistory`: Exposes CRUD operations for the **RepairHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RepairHistories
    * const repairHistories = await prisma.repairHistory.findMany()
    * ```
    */
  get repairHistory(): Prisma.RepairHistoryDelegate<ExtArgs>;

  /**
   * `prisma.learningPattern`: Exposes CRUD operations for the **LearningPattern** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningPatterns
    * const learningPatterns = await prisma.learningPattern.findMany()
    * ```
    */
  get learningPattern(): Prisma.LearningPatternDelegate<ExtArgs>;

  /**
   * `prisma.prediction`: Exposes CRUD operations for the **Prediction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Predictions
    * const predictions = await prisma.prediction.findMany()
    * ```
    */
  get prediction(): Prisma.PredictionDelegate<ExtArgs>;

  /**
   * `prisma.securityIncident`: Exposes CRUD operations for the **SecurityIncident** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityIncidents
    * const securityIncidents = await prisma.securityIncident.findMany()
    * ```
    */
  get securityIncident(): Prisma.SecurityIncidentDelegate<ExtArgs>;

  /**
   * `prisma.performanceMetric`: Exposes CRUD operations for the **PerformanceMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformanceMetrics
    * const performanceMetrics = await prisma.performanceMetric.findMany()
    * ```
    */
  get performanceMetric(): Prisma.PerformanceMetricDelegate<ExtArgs>;

  /**
   * `prisma.systemAlert`: Exposes CRUD operations for the **SystemAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemAlerts
    * const systemAlerts = await prisma.systemAlert.findMany()
    * ```
    */
  get systemAlert(): Prisma.SystemAlertDelegate<ExtArgs>;

  /**
   * `prisma.adminUser`: Exposes CRUD operations for the **AdminUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminUsers
    * const adminUsers = await prisma.adminUser.findMany()
    * ```
    */
  get adminUser(): Prisma.AdminUserDelegate<ExtArgs>;

  /**
   * `prisma.adminAuditLog`: Exposes CRUD operations for the **AdminAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminAuditLogs
    * const adminAuditLogs = await prisma.adminAuditLog.findMany()
    * ```
    */
  get adminAuditLog(): Prisma.AdminAuditLogDelegate<ExtArgs>;

  /**
   * `prisma.adminSession`: Exposes CRUD operations for the **AdminSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminSessions
    * const adminSessions = await prisma.adminSession.findMany()
    * ```
    */
  get adminSession(): Prisma.AdminSessionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.7.1
   * Query Engine version: 0ca5ccbcfa6bdc81c003cf549abe4269f59c41e5
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Lead: 'Lead',
    Campaign: 'Campaign',
    CampaignLead: 'CampaignLead',
    EmailTemplate: 'EmailTemplate',
    EmailEvent: 'EmailEvent',
    Website: 'Website',
    Video: 'Video',
    ApiKey: 'ApiKey',
    Conversation: 'Conversation',
    Message: 'Message',
    CannedResponse: 'CannedResponse',
    AutoResponse: 'AutoResponse',
    ConversationNote: 'ConversationNote',
    SystemHealthMetric: 'SystemHealthMetric',
    DiagnosticReport: 'DiagnosticReport',
    RepairHistory: 'RepairHistory',
    LearningPattern: 'LearningPattern',
    Prediction: 'Prediction',
    SecurityIncident: 'SecurityIncident',
    PerformanceMetric: 'PerformanceMetric',
    SystemAlert: 'SystemAlert',
    AdminUser: 'AdminUser',
    AdminAuditLog: 'AdminAuditLog',
    AdminSession: 'AdminSession'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'lead' | 'campaign' | 'campaignLead' | 'emailTemplate' | 'emailEvent' | 'website' | 'video' | 'apiKey' | 'conversation' | 'message' | 'cannedResponse' | 'autoResponse' | 'conversationNote' | 'systemHealthMetric' | 'diagnosticReport' | 'repairHistory' | 'learningPattern' | 'prediction' | 'securityIncident' | 'performanceMetric' | 'systemAlert' | 'adminUser' | 'adminAuditLog' | 'adminSession'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Lead: {
        payload: Prisma.$LeadPayload<ExtArgs>
        fields: Prisma.LeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findFirst: {
            args: Prisma.LeadFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findMany: {
            args: Prisma.LeadFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          create: {
            args: Prisma.LeadCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          createMany: {
            args: Prisma.LeadCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LeadDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          update: {
            args: Prisma.LeadUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          deleteMany: {
            args: Prisma.LeadDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LeadUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LeadUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.LeadGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadCountArgs<ExtArgs>,
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>,
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      CampaignLead: {
        payload: Prisma.$CampaignLeadPayload<ExtArgs>
        fields: Prisma.CampaignLeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignLeadFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignLeadFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>
          }
          findFirst: {
            args: Prisma.CampaignLeadFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignLeadFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>
          }
          findMany: {
            args: Prisma.CampaignLeadFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>[]
          }
          create: {
            args: Prisma.CampaignLeadCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>
          }
          createMany: {
            args: Prisma.CampaignLeadCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CampaignLeadDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>
          }
          update: {
            args: Prisma.CampaignLeadUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>
          }
          deleteMany: {
            args: Prisma.CampaignLeadDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignLeadUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CampaignLeadUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>
          }
          aggregate: {
            args: Prisma.CampaignLeadAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCampaignLead>
          }
          groupBy: {
            args: Prisma.CampaignLeadGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CampaignLeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignLeadCountArgs<ExtArgs>,
            result: $Utils.Optional<CampaignLeadCountAggregateOutputType> | number
          }
        }
      }
      EmailTemplate: {
        payload: Prisma.$EmailTemplatePayload<ExtArgs>
        fields: Prisma.EmailTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailTemplateFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailTemplateFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findFirst: {
            args: Prisma.EmailTemplateFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailTemplateFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findMany: {
            args: Prisma.EmailTemplateFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          create: {
            args: Prisma.EmailTemplateCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          createMany: {
            args: Prisma.EmailTemplateCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmailTemplateDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          update: {
            args: Prisma.EmailTemplateUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          deleteMany: {
            args: Prisma.EmailTemplateDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmailTemplateUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmailTemplateUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          aggregate: {
            args: Prisma.EmailTemplateAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmailTemplate>
          }
          groupBy: {
            args: Prisma.EmailTemplateGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmailTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailTemplateCountArgs<ExtArgs>,
            result: $Utils.Optional<EmailTemplateCountAggregateOutputType> | number
          }
        }
      }
      EmailEvent: {
        payload: Prisma.$EmailEventPayload<ExtArgs>
        fields: Prisma.EmailEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailEventFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailEventFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailEventPayload>
          }
          findFirst: {
            args: Prisma.EmailEventFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailEventFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailEventPayload>
          }
          findMany: {
            args: Prisma.EmailEventFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailEventPayload>[]
          }
          create: {
            args: Prisma.EmailEventCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailEventPayload>
          }
          createMany: {
            args: Prisma.EmailEventCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmailEventDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailEventPayload>
          }
          update: {
            args: Prisma.EmailEventUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailEventPayload>
          }
          deleteMany: {
            args: Prisma.EmailEventDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmailEventUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmailEventUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailEventPayload>
          }
          aggregate: {
            args: Prisma.EmailEventAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmailEvent>
          }
          groupBy: {
            args: Prisma.EmailEventGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmailEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailEventCountArgs<ExtArgs>,
            result: $Utils.Optional<EmailEventCountAggregateOutputType> | number
          }
        }
      }
      Website: {
        payload: Prisma.$WebsitePayload<ExtArgs>
        fields: Prisma.WebsiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebsiteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WebsitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebsiteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WebsitePayload>
          }
          findFirst: {
            args: Prisma.WebsiteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WebsitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebsiteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WebsitePayload>
          }
          findMany: {
            args: Prisma.WebsiteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WebsitePayload>[]
          }
          create: {
            args: Prisma.WebsiteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WebsitePayload>
          }
          createMany: {
            args: Prisma.WebsiteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WebsiteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WebsitePayload>
          }
          update: {
            args: Prisma.WebsiteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WebsitePayload>
          }
          deleteMany: {
            args: Prisma.WebsiteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WebsiteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WebsiteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WebsitePayload>
          }
          aggregate: {
            args: Prisma.WebsiteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWebsite>
          }
          groupBy: {
            args: Prisma.WebsiteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WebsiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebsiteCountArgs<ExtArgs>,
            result: $Utils.Optional<WebsiteCountAggregateOutputType> | number
          }
        }
      }
      Video: {
        payload: Prisma.$VideoPayload<ExtArgs>
        fields: Prisma.VideoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          findFirst: {
            args: Prisma.VideoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          findMany: {
            args: Prisma.VideoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>[]
          }
          create: {
            args: Prisma.VideoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          createMany: {
            args: Prisma.VideoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.VideoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          update: {
            args: Prisma.VideoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          deleteMany: {
            args: Prisma.VideoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.VideoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.VideoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          aggregate: {
            args: Prisma.VideoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVideo>
          }
          groupBy: {
            args: Prisma.VideoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VideoGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoCountArgs<ExtArgs>,
            result: $Utils.Optional<VideoCountAggregateOutputType> | number
          }
        }
      }
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>
        fields: Prisma.ApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateApiKey>
          }
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>,
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>,
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>,
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      CannedResponse: {
        payload: Prisma.$CannedResponsePayload<ExtArgs>
        fields: Prisma.CannedResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CannedResponseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CannedResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CannedResponseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CannedResponsePayload>
          }
          findFirst: {
            args: Prisma.CannedResponseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CannedResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CannedResponseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CannedResponsePayload>
          }
          findMany: {
            args: Prisma.CannedResponseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CannedResponsePayload>[]
          }
          create: {
            args: Prisma.CannedResponseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CannedResponsePayload>
          }
          createMany: {
            args: Prisma.CannedResponseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CannedResponseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CannedResponsePayload>
          }
          update: {
            args: Prisma.CannedResponseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CannedResponsePayload>
          }
          deleteMany: {
            args: Prisma.CannedResponseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CannedResponseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CannedResponseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CannedResponsePayload>
          }
          aggregate: {
            args: Prisma.CannedResponseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCannedResponse>
          }
          groupBy: {
            args: Prisma.CannedResponseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CannedResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CannedResponseCountArgs<ExtArgs>,
            result: $Utils.Optional<CannedResponseCountAggregateOutputType> | number
          }
        }
      }
      AutoResponse: {
        payload: Prisma.$AutoResponsePayload<ExtArgs>
        fields: Prisma.AutoResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutoResponseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AutoResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutoResponseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AutoResponsePayload>
          }
          findFirst: {
            args: Prisma.AutoResponseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AutoResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutoResponseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AutoResponsePayload>
          }
          findMany: {
            args: Prisma.AutoResponseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AutoResponsePayload>[]
          }
          create: {
            args: Prisma.AutoResponseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AutoResponsePayload>
          }
          createMany: {
            args: Prisma.AutoResponseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AutoResponseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AutoResponsePayload>
          }
          update: {
            args: Prisma.AutoResponseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AutoResponsePayload>
          }
          deleteMany: {
            args: Prisma.AutoResponseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AutoResponseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AutoResponseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AutoResponsePayload>
          }
          aggregate: {
            args: Prisma.AutoResponseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAutoResponse>
          }
          groupBy: {
            args: Prisma.AutoResponseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AutoResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutoResponseCountArgs<ExtArgs>,
            result: $Utils.Optional<AutoResponseCountAggregateOutputType> | number
          }
        }
      }
      ConversationNote: {
        payload: Prisma.$ConversationNotePayload<ExtArgs>
        fields: Prisma.ConversationNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationNoteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationNoteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationNotePayload>
          }
          findFirst: {
            args: Prisma.ConversationNoteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationNoteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationNotePayload>
          }
          findMany: {
            args: Prisma.ConversationNoteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationNotePayload>[]
          }
          create: {
            args: Prisma.ConversationNoteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationNotePayload>
          }
          createMany: {
            args: Prisma.ConversationNoteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConversationNoteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationNotePayload>
          }
          update: {
            args: Prisma.ConversationNoteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationNotePayload>
          }
          deleteMany: {
            args: Prisma.ConversationNoteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationNoteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConversationNoteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationNotePayload>
          }
          aggregate: {
            args: Prisma.ConversationNoteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConversationNote>
          }
          groupBy: {
            args: Prisma.ConversationNoteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConversationNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationNoteCountArgs<ExtArgs>,
            result: $Utils.Optional<ConversationNoteCountAggregateOutputType> | number
          }
        }
      }
      SystemHealthMetric: {
        payload: Prisma.$SystemHealthMetricPayload<ExtArgs>
        fields: Prisma.SystemHealthMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemHealthMetricFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemHealthMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemHealthMetricFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemHealthMetricPayload>
          }
          findFirst: {
            args: Prisma.SystemHealthMetricFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemHealthMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemHealthMetricFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemHealthMetricPayload>
          }
          findMany: {
            args: Prisma.SystemHealthMetricFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemHealthMetricPayload>[]
          }
          create: {
            args: Prisma.SystemHealthMetricCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemHealthMetricPayload>
          }
          createMany: {
            args: Prisma.SystemHealthMetricCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SystemHealthMetricDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemHealthMetricPayload>
          }
          update: {
            args: Prisma.SystemHealthMetricUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemHealthMetricPayload>
          }
          deleteMany: {
            args: Prisma.SystemHealthMetricDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SystemHealthMetricUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SystemHealthMetricUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemHealthMetricPayload>
          }
          aggregate: {
            args: Prisma.SystemHealthMetricAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSystemHealthMetric>
          }
          groupBy: {
            args: Prisma.SystemHealthMetricGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SystemHealthMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemHealthMetricCountArgs<ExtArgs>,
            result: $Utils.Optional<SystemHealthMetricCountAggregateOutputType> | number
          }
        }
      }
      DiagnosticReport: {
        payload: Prisma.$DiagnosticReportPayload<ExtArgs>
        fields: Prisma.DiagnosticReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiagnosticReportFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosticReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiagnosticReportFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosticReportPayload>
          }
          findFirst: {
            args: Prisma.DiagnosticReportFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosticReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiagnosticReportFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosticReportPayload>
          }
          findMany: {
            args: Prisma.DiagnosticReportFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosticReportPayload>[]
          }
          create: {
            args: Prisma.DiagnosticReportCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosticReportPayload>
          }
          createMany: {
            args: Prisma.DiagnosticReportCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DiagnosticReportDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosticReportPayload>
          }
          update: {
            args: Prisma.DiagnosticReportUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosticReportPayload>
          }
          deleteMany: {
            args: Prisma.DiagnosticReportDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DiagnosticReportUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DiagnosticReportUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosticReportPayload>
          }
          aggregate: {
            args: Prisma.DiagnosticReportAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDiagnosticReport>
          }
          groupBy: {
            args: Prisma.DiagnosticReportGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DiagnosticReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiagnosticReportCountArgs<ExtArgs>,
            result: $Utils.Optional<DiagnosticReportCountAggregateOutputType> | number
          }
        }
      }
      RepairHistory: {
        payload: Prisma.$RepairHistoryPayload<ExtArgs>
        fields: Prisma.RepairHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RepairHistoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RepairHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RepairHistoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RepairHistoryPayload>
          }
          findFirst: {
            args: Prisma.RepairHistoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RepairHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RepairHistoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RepairHistoryPayload>
          }
          findMany: {
            args: Prisma.RepairHistoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RepairHistoryPayload>[]
          }
          create: {
            args: Prisma.RepairHistoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RepairHistoryPayload>
          }
          createMany: {
            args: Prisma.RepairHistoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RepairHistoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RepairHistoryPayload>
          }
          update: {
            args: Prisma.RepairHistoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RepairHistoryPayload>
          }
          deleteMany: {
            args: Prisma.RepairHistoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RepairHistoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RepairHistoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RepairHistoryPayload>
          }
          aggregate: {
            args: Prisma.RepairHistoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRepairHistory>
          }
          groupBy: {
            args: Prisma.RepairHistoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RepairHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.RepairHistoryCountArgs<ExtArgs>,
            result: $Utils.Optional<RepairHistoryCountAggregateOutputType> | number
          }
        }
      }
      LearningPattern: {
        payload: Prisma.$LearningPatternPayload<ExtArgs>
        fields: Prisma.LearningPatternFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningPatternFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LearningPatternPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningPatternFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LearningPatternPayload>
          }
          findFirst: {
            args: Prisma.LearningPatternFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LearningPatternPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningPatternFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LearningPatternPayload>
          }
          findMany: {
            args: Prisma.LearningPatternFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LearningPatternPayload>[]
          }
          create: {
            args: Prisma.LearningPatternCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LearningPatternPayload>
          }
          createMany: {
            args: Prisma.LearningPatternCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LearningPatternDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LearningPatternPayload>
          }
          update: {
            args: Prisma.LearningPatternUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LearningPatternPayload>
          }
          deleteMany: {
            args: Prisma.LearningPatternDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LearningPatternUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LearningPatternUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LearningPatternPayload>
          }
          aggregate: {
            args: Prisma.LearningPatternAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLearningPattern>
          }
          groupBy: {
            args: Prisma.LearningPatternGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LearningPatternGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningPatternCountArgs<ExtArgs>,
            result: $Utils.Optional<LearningPatternCountAggregateOutputType> | number
          }
        }
      }
      Prediction: {
        payload: Prisma.$PredictionPayload<ExtArgs>
        fields: Prisma.PredictionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PredictionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PredictionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>
          }
          findFirst: {
            args: Prisma.PredictionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PredictionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>
          }
          findMany: {
            args: Prisma.PredictionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>[]
          }
          create: {
            args: Prisma.PredictionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>
          }
          createMany: {
            args: Prisma.PredictionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PredictionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>
          }
          update: {
            args: Prisma.PredictionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>
          }
          deleteMany: {
            args: Prisma.PredictionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PredictionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PredictionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>
          }
          aggregate: {
            args: Prisma.PredictionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePrediction>
          }
          groupBy: {
            args: Prisma.PredictionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PredictionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PredictionCountArgs<ExtArgs>,
            result: $Utils.Optional<PredictionCountAggregateOutputType> | number
          }
        }
      }
      SecurityIncident: {
        payload: Prisma.$SecurityIncidentPayload<ExtArgs>
        fields: Prisma.SecurityIncidentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecurityIncidentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecurityIncidentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecurityIncidentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecurityIncidentPayload>
          }
          findFirst: {
            args: Prisma.SecurityIncidentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecurityIncidentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecurityIncidentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecurityIncidentPayload>
          }
          findMany: {
            args: Prisma.SecurityIncidentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecurityIncidentPayload>[]
          }
          create: {
            args: Prisma.SecurityIncidentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecurityIncidentPayload>
          }
          createMany: {
            args: Prisma.SecurityIncidentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SecurityIncidentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecurityIncidentPayload>
          }
          update: {
            args: Prisma.SecurityIncidentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecurityIncidentPayload>
          }
          deleteMany: {
            args: Prisma.SecurityIncidentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SecurityIncidentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SecurityIncidentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecurityIncidentPayload>
          }
          aggregate: {
            args: Prisma.SecurityIncidentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSecurityIncident>
          }
          groupBy: {
            args: Prisma.SecurityIncidentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SecurityIncidentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecurityIncidentCountArgs<ExtArgs>,
            result: $Utils.Optional<SecurityIncidentCountAggregateOutputType> | number
          }
        }
      }
      PerformanceMetric: {
        payload: Prisma.$PerformanceMetricPayload<ExtArgs>
        fields: Prisma.PerformanceMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformanceMetricFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformanceMetricFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          findFirst: {
            args: Prisma.PerformanceMetricFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformanceMetricFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          findMany: {
            args: Prisma.PerformanceMetricFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>[]
          }
          create: {
            args: Prisma.PerformanceMetricCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          createMany: {
            args: Prisma.PerformanceMetricCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PerformanceMetricDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          update: {
            args: Prisma.PerformanceMetricUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          deleteMany: {
            args: Prisma.PerformanceMetricDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PerformanceMetricUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PerformanceMetricUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          aggregate: {
            args: Prisma.PerformanceMetricAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePerformanceMetric>
          }
          groupBy: {
            args: Prisma.PerformanceMetricGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PerformanceMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerformanceMetricCountArgs<ExtArgs>,
            result: $Utils.Optional<PerformanceMetricCountAggregateOutputType> | number
          }
        }
      }
      SystemAlert: {
        payload: Prisma.$SystemAlertPayload<ExtArgs>
        fields: Prisma.SystemAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemAlertFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemAlertFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemAlertPayload>
          }
          findFirst: {
            args: Prisma.SystemAlertFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemAlertFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemAlertPayload>
          }
          findMany: {
            args: Prisma.SystemAlertFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemAlertPayload>[]
          }
          create: {
            args: Prisma.SystemAlertCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemAlertPayload>
          }
          createMany: {
            args: Prisma.SystemAlertCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SystemAlertDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemAlertPayload>
          }
          update: {
            args: Prisma.SystemAlertUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemAlertPayload>
          }
          deleteMany: {
            args: Prisma.SystemAlertDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SystemAlertUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SystemAlertUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemAlertPayload>
          }
          aggregate: {
            args: Prisma.SystemAlertAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSystemAlert>
          }
          groupBy: {
            args: Prisma.SystemAlertGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SystemAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemAlertCountArgs<ExtArgs>,
            result: $Utils.Optional<SystemAlertCountAggregateOutputType> | number
          }
        }
      }
      AdminUser: {
        payload: Prisma.$AdminUserPayload<ExtArgs>
        fields: Prisma.AdminUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          findFirst: {
            args: Prisma.AdminUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          findMany: {
            args: Prisma.AdminUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>[]
          }
          create: {
            args: Prisma.AdminUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          createMany: {
            args: Prisma.AdminUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdminUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          update: {
            args: Prisma.AdminUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          deleteMany: {
            args: Prisma.AdminUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdminUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          aggregate: {
            args: Prisma.AdminUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdminUser>
          }
          groupBy: {
            args: Prisma.AdminUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdminUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminUserCountArgs<ExtArgs>,
            result: $Utils.Optional<AdminUserCountAggregateOutputType> | number
          }
        }
      }
      AdminAuditLog: {
        payload: Prisma.$AdminAuditLogPayload<ExtArgs>
        fields: Prisma.AdminAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminAuditLogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminAuditLogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          findFirst: {
            args: Prisma.AdminAuditLogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminAuditLogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          findMany: {
            args: Prisma.AdminAuditLogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>[]
          }
          create: {
            args: Prisma.AdminAuditLogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          createMany: {
            args: Prisma.AdminAuditLogCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdminAuditLogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          update: {
            args: Prisma.AdminAuditLogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AdminAuditLogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdminAuditLogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdminAuditLogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          aggregate: {
            args: Prisma.AdminAuditLogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdminAuditLog>
          }
          groupBy: {
            args: Prisma.AdminAuditLogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdminAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminAuditLogCountArgs<ExtArgs>,
            result: $Utils.Optional<AdminAuditLogCountAggregateOutputType> | number
          }
        }
      }
      AdminSession: {
        payload: Prisma.$AdminSessionPayload<ExtArgs>
        fields: Prisma.AdminSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminSessionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminSessionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          findFirst: {
            args: Prisma.AdminSessionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminSessionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          findMany: {
            args: Prisma.AdminSessionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>[]
          }
          create: {
            args: Prisma.AdminSessionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          createMany: {
            args: Prisma.AdminSessionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdminSessionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          update: {
            args: Prisma.AdminSessionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          deleteMany: {
            args: Prisma.AdminSessionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdminSessionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdminSessionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          aggregate: {
            args: Prisma.AdminSessionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdminSession>
          }
          groupBy: {
            args: Prisma.AdminSessionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdminSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminSessionCountArgs<ExtArgs>,
            result: $Utils.Optional<AdminSessionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    leads: number
    campaigns: number
    emailTemplates: number
    websites: number
    videos: number
    apiKeys: number
    conversations: number
    messages: number
    cannedResponses: number
    autoResponses: number
    conversationNotes: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leads?: boolean | UserCountOutputTypeCountLeadsArgs
    campaigns?: boolean | UserCountOutputTypeCountCampaignsArgs
    emailTemplates?: boolean | UserCountOutputTypeCountEmailTemplatesArgs
    websites?: boolean | UserCountOutputTypeCountWebsitesArgs
    videos?: boolean | UserCountOutputTypeCountVideosArgs
    apiKeys?: boolean | UserCountOutputTypeCountApiKeysArgs
    conversations?: boolean | UserCountOutputTypeCountConversationsArgs
    messages?: boolean | UserCountOutputTypeCountMessagesArgs
    cannedResponses?: boolean | UserCountOutputTypeCountCannedResponsesArgs
    autoResponses?: boolean | UserCountOutputTypeCountAutoResponsesArgs
    conversationNotes?: boolean | UserCountOutputTypeCountConversationNotesArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTemplateWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWebsitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebsiteWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCannedResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CannedResponseWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAutoResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoResponseWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationNoteWhereInput
  }



  /**
   * Count Type LeadCountOutputType
   */

  export type LeadCountOutputType = {
    campaignLeads: number
    emailEvents: number
  }

  export type LeadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaignLeads?: boolean | LeadCountOutputTypeCountCampaignLeadsArgs
    emailEvents?: boolean | LeadCountOutputTypeCountEmailEventsArgs
  }

  // Custom InputTypes

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCountOutputType
     */
    select?: LeadCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountCampaignLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignLeadWhereInput
  }


  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountEmailEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailEventWhereInput
  }



  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    campaignLeads: number
    emailEvents: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaignLeads?: boolean | CampaignCountOutputTypeCountCampaignLeadsArgs
    emailEvents?: boolean | CampaignCountOutputTypeCountEmailEventsArgs
  }

  // Custom InputTypes

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountCampaignLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignLeadWhereInput
  }


  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountEmailEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailEventWhereInput
  }



  /**
   * Count Type EmailTemplateCountOutputType
   */

  export type EmailTemplateCountOutputType = {
    campaigns: number
  }

  export type EmailTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | EmailTemplateCountOutputTypeCountCampaignsArgs
  }

  // Custom InputTypes

  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplateCountOutputType
     */
    select?: EmailTemplateCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }



  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    messages: number
    notes: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
    notes?: boolean | ConversationCountOutputTypeCountNotesArgs
  }

  // Custom InputTypes

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationNoteWhereInput
  }



  /**
   * Count Type CannedResponseCountOutputType
   */

  export type CannedResponseCountOutputType = {
    AutoResponse: number
  }

  export type CannedResponseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AutoResponse?: boolean | CannedResponseCountOutputTypeCountAutoResponseArgs
  }

  // Custom InputTypes

  /**
   * CannedResponseCountOutputType without action
   */
  export type CannedResponseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CannedResponseCountOutputType
     */
    select?: CannedResponseCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CannedResponseCountOutputType without action
   */
  export type CannedResponseCountOutputTypeCountAutoResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoResponseWhereInput
  }



  /**
   * Count Type DiagnosticReportCountOutputType
   */

  export type DiagnosticReportCountOutputType = {
    repairs: number
  }

  export type DiagnosticReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    repairs?: boolean | DiagnosticReportCountOutputTypeCountRepairsArgs
  }

  // Custom InputTypes

  /**
   * DiagnosticReportCountOutputType without action
   */
  export type DiagnosticReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReportCountOutputType
     */
    select?: DiagnosticReportCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DiagnosticReportCountOutputType without action
   */
  export type DiagnosticReportCountOutputTypeCountRepairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepairHistoryWhereInput
  }



  /**
   * Count Type AdminUserCountOutputType
   */

  export type AdminUserCountOutputType = {
    auditLogs: number
  }

  export type AdminUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | AdminUserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUserCountOutputType
     */
    select?: AdminUserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuditLogWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    tier: number | null
  }

  export type UserSumAggregateOutputType = {
    tier: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    company: string | null
    tier: number | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    subscriptionStatus: string | null
    trialEndsAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    company: string | null
    tier: number | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    subscriptionStatus: string | null
    trialEndsAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    name: number
    company: number
    tier: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    subscriptionStatus: number
    trialEndsAt: number
    createdAt: number
    updatedAt: number
    lastLoginAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    tier?: true
  }

  export type UserSumAggregateInputType = {
    tier?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    company?: true
    tier?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    subscriptionStatus?: true
    trialEndsAt?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    company?: true
    tier?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    subscriptionStatus?: true
    trialEndsAt?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    company?: true
    tier?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    subscriptionStatus?: true
    trialEndsAt?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    name: string | null
    company: string | null
    tier: number
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    subscriptionStatus: string | null
    trialEndsAt: Date | null
    createdAt: Date
    updatedAt: Date
    lastLoginAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    company?: boolean
    tier?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    subscriptionStatus?: boolean
    trialEndsAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    leads?: boolean | User$leadsArgs<ExtArgs>
    campaigns?: boolean | User$campaignsArgs<ExtArgs>
    emailTemplates?: boolean | User$emailTemplatesArgs<ExtArgs>
    websites?: boolean | User$websitesArgs<ExtArgs>
    videos?: boolean | User$videosArgs<ExtArgs>
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    cannedResponses?: boolean | User$cannedResponsesArgs<ExtArgs>
    autoResponses?: boolean | User$autoResponsesArgs<ExtArgs>
    conversationNotes?: boolean | User$conversationNotesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    company?: boolean
    tier?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    subscriptionStatus?: boolean
    trialEndsAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leads?: boolean | User$leadsArgs<ExtArgs>
    campaigns?: boolean | User$campaignsArgs<ExtArgs>
    emailTemplates?: boolean | User$emailTemplatesArgs<ExtArgs>
    websites?: boolean | User$websitesArgs<ExtArgs>
    videos?: boolean | User$videosArgs<ExtArgs>
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    cannedResponses?: boolean | User$cannedResponsesArgs<ExtArgs>
    autoResponses?: boolean | User$autoResponsesArgs<ExtArgs>
    conversationNotes?: boolean | User$conversationNotesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      leads: Prisma.$LeadPayload<ExtArgs>[]
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      emailTemplates: Prisma.$EmailTemplatePayload<ExtArgs>[]
      websites: Prisma.$WebsitePayload<ExtArgs>[]
      videos: Prisma.$VideoPayload<ExtArgs>[]
      apiKeys: Prisma.$ApiKeyPayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      cannedResponses: Prisma.$CannedResponsePayload<ExtArgs>[]
      autoResponses: Prisma.$AutoResponsePayload<ExtArgs>[]
      conversationNotes: Prisma.$ConversationNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      name: string | null
      company: string | null
      tier: number
      stripeCustomerId: string | null
      stripeSubscriptionId: string | null
      subscriptionStatus: string | null
      trialEndsAt: Date | null
      createdAt: Date
      updatedAt: Date
      lastLoginAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    leads<T extends User$leadsArgs<ExtArgs> = {}>(args?: Subset<T, User$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, 'findMany'> | Null>;

    campaigns<T extends User$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, User$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'findMany'> | Null>;

    emailTemplates<T extends User$emailTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, User$emailTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'findMany'> | Null>;

    websites<T extends User$websitesArgs<ExtArgs> = {}>(args?: Subset<T, User$websitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsitePayload<ExtArgs>, T, 'findMany'> | Null>;

    videos<T extends User$videosArgs<ExtArgs> = {}>(args?: Subset<T, User$videosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, 'findMany'> | Null>;

    apiKeys<T extends User$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, User$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findMany'> | Null>;

    conversations<T extends User$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findMany'> | Null>;

    messages<T extends User$messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findMany'> | Null>;

    cannedResponses<T extends User$cannedResponsesArgs<ExtArgs> = {}>(args?: Subset<T, User$cannedResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CannedResponsePayload<ExtArgs>, T, 'findMany'> | Null>;

    autoResponses<T extends User$autoResponsesArgs<ExtArgs> = {}>(args?: Subset<T, User$autoResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoResponsePayload<ExtArgs>, T, 'findMany'> | Null>;

    conversationNotes<T extends User$conversationNotesArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationNotePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly company: FieldRef<"User", 'String'>
    readonly tier: FieldRef<"User", 'Int'>
    readonly stripeCustomerId: FieldRef<"User", 'String'>
    readonly stripeSubscriptionId: FieldRef<"User", 'String'>
    readonly subscriptionStatus: FieldRef<"User", 'String'>
    readonly trialEndsAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.leads
   */
  export type User$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }


  /**
   * User.campaigns
   */
  export type User$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }


  /**
   * User.emailTemplates
   */
  export type User$emailTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    where?: EmailTemplateWhereInput
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    cursor?: EmailTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }


  /**
   * User.websites
   */
  export type User$websitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WebsiteInclude<ExtArgs> | null
    where?: WebsiteWhereInput
    orderBy?: WebsiteOrderByWithRelationInput | WebsiteOrderByWithRelationInput[]
    cursor?: WebsiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebsiteScalarFieldEnum | WebsiteScalarFieldEnum[]
  }


  /**
   * User.videos
   */
  export type User$videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude<ExtArgs> | null
    where?: VideoWhereInput
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    cursor?: VideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }


  /**
   * User.apiKeys
   */
  export type User$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    cursor?: ApiKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }


  /**
   * User.conversations
   */
  export type User$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }


  /**
   * User.messages
   */
  export type User$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * User.cannedResponses
   */
  export type User$cannedResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CannedResponse
     */
    select?: CannedResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CannedResponseInclude<ExtArgs> | null
    where?: CannedResponseWhereInput
    orderBy?: CannedResponseOrderByWithRelationInput | CannedResponseOrderByWithRelationInput[]
    cursor?: CannedResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CannedResponseScalarFieldEnum | CannedResponseScalarFieldEnum[]
  }


  /**
   * User.autoResponses
   */
  export type User$autoResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoResponse
     */
    select?: AutoResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutoResponseInclude<ExtArgs> | null
    where?: AutoResponseWhereInput
    orderBy?: AutoResponseOrderByWithRelationInput | AutoResponseOrderByWithRelationInput[]
    cursor?: AutoResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutoResponseScalarFieldEnum | AutoResponseScalarFieldEnum[]
  }


  /**
   * User.conversationNotes
   */
  export type User$conversationNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationNote
     */
    select?: ConversationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationNoteInclude<ExtArgs> | null
    where?: ConversationNoteWhereInput
    orderBy?: ConversationNoteOrderByWithRelationInput | ConversationNoteOrderByWithRelationInput[]
    cursor?: ConversationNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationNoteScalarFieldEnum | ConversationNoteScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Lead
   */

  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadAvgAggregateOutputType = {
    score: number | null
  }

  export type LeadSumAggregateOutputType = {
    score: number | null
  }

  export type LeadMinAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    name: string | null
    company: string | null
    phone: string | null
    title: string | null
    website: string | null
    linkedinUrl: string | null
    source: string | null
    status: string | null
    score: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastContactedAt: Date | null
  }

  export type LeadMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    name: string | null
    company: string | null
    phone: string | null
    title: string | null
    website: string | null
    linkedinUrl: string | null
    source: string | null
    status: string | null
    score: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastContactedAt: Date | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    userId: number
    email: number
    name: number
    company: number
    phone: number
    title: number
    website: number
    linkedinUrl: number
    source: number
    status: number
    score: number
    notes: number
    tags: number
    customFields: number
    createdAt: number
    updatedAt: number
    lastContactedAt: number
    _all: number
  }


  export type LeadAvgAggregateInputType = {
    score?: true
  }

  export type LeadSumAggregateInputType = {
    score?: true
  }

  export type LeadMinAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    name?: true
    company?: true
    phone?: true
    title?: true
    website?: true
    linkedinUrl?: true
    source?: true
    status?: true
    score?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    lastContactedAt?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    name?: true
    company?: true
    phone?: true
    title?: true
    website?: true
    linkedinUrl?: true
    source?: true
    status?: true
    score?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    lastContactedAt?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    name?: true
    company?: true
    phone?: true
    title?: true
    website?: true
    linkedinUrl?: true
    source?: true
    status?: true
    score?: true
    notes?: true
    tags?: true
    customFields?: true
    createdAt?: true
    updatedAt?: true
    lastContactedAt?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lead to aggregate.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type LeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithAggregationInput | LeadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: LeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _avg?: LeadAvgAggregateInputType
    _sum?: LeadSumAggregateInputType
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }

  export type LeadGroupByOutputType = {
    id: string
    userId: string
    email: string
    name: string | null
    company: string | null
    phone: string | null
    title: string | null
    website: string | null
    linkedinUrl: string | null
    source: string | null
    status: string
    score: number | null
    notes: string | null
    tags: string[]
    customFields: JsonValue | null
    createdAt: Date
    updatedAt: Date
    lastContactedAt: Date | null
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends LeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type LeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    name?: boolean
    company?: boolean
    phone?: boolean
    title?: boolean
    website?: boolean
    linkedinUrl?: boolean
    source?: boolean
    status?: boolean
    score?: boolean
    notes?: boolean
    tags?: boolean
    customFields?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastContactedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaignLeads?: boolean | Lead$campaignLeadsArgs<ExtArgs>
    emailEvents?: boolean | Lead$emailEventsArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectScalar = {
    id?: boolean
    userId?: boolean
    email?: boolean
    name?: boolean
    company?: boolean
    phone?: boolean
    title?: boolean
    website?: boolean
    linkedinUrl?: boolean
    source?: boolean
    status?: boolean
    score?: boolean
    notes?: boolean
    tags?: boolean
    customFields?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastContactedAt?: boolean
  }

  export type LeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaignLeads?: boolean | Lead$campaignLeadsArgs<ExtArgs>
    emailEvents?: boolean | Lead$emailEventsArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $LeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lead"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      campaignLeads: Prisma.$CampaignLeadPayload<ExtArgs>[]
      emailEvents: Prisma.$EmailEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      email: string
      name: string | null
      company: string | null
      phone: string | null
      title: string | null
      website: string | null
      linkedinUrl: string | null
      source: string | null
      status: string
      score: number | null
      notes: string | null
      tags: string[]
      customFields: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      lastContactedAt: Date | null
    }, ExtArgs["result"]["lead"]>
    composites: {}
  }


  type LeadGetPayload<S extends boolean | null | undefined | LeadDefaultArgs> = $Result.GetResult<Prisma.$LeadPayload, S>

  type LeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeadFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: LeadCountAggregateInputType | true
    }

  export interface LeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lead'], meta: { name: 'Lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {LeadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LeadFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LeadFindUniqueArgs<ExtArgs>>
    ): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Lead that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LeadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LeadFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LeadFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LeadFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LeadFindFirstArgs<ExtArgs>>
    ): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LeadFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LeadFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LeadFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeadFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Lead.
     * @param {LeadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
    **/
    create<T extends LeadCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LeadCreateArgs<ExtArgs>>
    ): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Leads.
     *     @param {LeadCreateManyArgs} args - Arguments to create many Leads.
     *     @example
     *     // Create many Leads
     *     const lead = await prisma.lead.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LeadCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeadCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lead.
     * @param {LeadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
    **/
    delete<T extends LeadDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LeadDeleteArgs<ExtArgs>>
    ): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Lead.
     * @param {LeadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LeadUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LeadUpdateArgs<ExtArgs>>
    ): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Leads.
     * @param {LeadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LeadDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeadDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LeadUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LeadUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lead.
     * @param {LeadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
    **/
    upsert<T extends LeadUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LeadUpsertArgs<ExtArgs>>
    ): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends LeadCountArgs>(
      args?: Subset<T, LeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadGroupByArgs['orderBy'] }
        : { orderBy?: LeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lead model
   */
  readonly fields: LeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    campaignLeads<T extends Lead$campaignLeadsArgs<ExtArgs> = {}>(args?: Subset<T, Lead$campaignLeadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, 'findMany'> | Null>;

    emailEvents<T extends Lead$emailEventsArgs<ExtArgs> = {}>(args?: Subset<T, Lead$emailEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Lead model
   */ 
  interface LeadFieldRefs {
    readonly id: FieldRef<"Lead", 'String'>
    readonly userId: FieldRef<"Lead", 'String'>
    readonly email: FieldRef<"Lead", 'String'>
    readonly name: FieldRef<"Lead", 'String'>
    readonly company: FieldRef<"Lead", 'String'>
    readonly phone: FieldRef<"Lead", 'String'>
    readonly title: FieldRef<"Lead", 'String'>
    readonly website: FieldRef<"Lead", 'String'>
    readonly linkedinUrl: FieldRef<"Lead", 'String'>
    readonly source: FieldRef<"Lead", 'String'>
    readonly status: FieldRef<"Lead", 'String'>
    readonly score: FieldRef<"Lead", 'Int'>
    readonly notes: FieldRef<"Lead", 'String'>
    readonly tags: FieldRef<"Lead", 'String[]'>
    readonly customFields: FieldRef<"Lead", 'Json'>
    readonly createdAt: FieldRef<"Lead", 'DateTime'>
    readonly updatedAt: FieldRef<"Lead", 'DateTime'>
    readonly lastContactedAt: FieldRef<"Lead", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Lead findUnique
   */
  export type LeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }


  /**
   * Lead findUniqueOrThrow
   */
  export type LeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }


  /**
   * Lead findFirst
   */
  export type LeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }


  /**
   * Lead findFirstOrThrow
   */
  export type LeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }


  /**
   * Lead findMany
   */
  export type LeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Leads to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }


  /**
   * Lead create
   */
  export type LeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to create a Lead.
     */
    data: XOR<LeadCreateInput, LeadUncheckedCreateInput>
  }


  /**
   * Lead createMany
   */
  export type LeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Lead update
   */
  export type LeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to update a Lead.
     */
    data: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
    /**
     * Choose, which Lead to update.
     */
    where: LeadWhereUniqueInput
  }


  /**
   * Lead updateMany
   */
  export type LeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
  }


  /**
   * Lead upsert
   */
  export type LeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The filter to search for the Lead to update in case it exists.
     */
    where: LeadWhereUniqueInput
    /**
     * In case the Lead found by the `where` argument doesn't exist, create a new Lead with this data.
     */
    create: XOR<LeadCreateInput, LeadUncheckedCreateInput>
    /**
     * In case the Lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
  }


  /**
   * Lead delete
   */
  export type LeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter which Lead to delete.
     */
    where: LeadWhereUniqueInput
  }


  /**
   * Lead deleteMany
   */
  export type LeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leads to delete
     */
    where?: LeadWhereInput
  }


  /**
   * Lead.campaignLeads
   */
  export type Lead$campaignLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    where?: CampaignLeadWhereInput
    orderBy?: CampaignLeadOrderByWithRelationInput | CampaignLeadOrderByWithRelationInput[]
    cursor?: CampaignLeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignLeadScalarFieldEnum | CampaignLeadScalarFieldEnum[]
  }


  /**
   * Lead.emailEvents
   */
  export type Lead$emailEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailEventInclude<ExtArgs> | null
    where?: EmailEventWhereInput
    orderBy?: EmailEventOrderByWithRelationInput | EmailEventOrderByWithRelationInput[]
    cursor?: EmailEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailEventScalarFieldEnum | EmailEventScalarFieldEnum[]
  }


  /**
   * Lead without action
   */
  export type LeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeadInclude<ExtArgs> | null
  }



  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    totalLeads: number | null
    sentCount: number | null
    openCount: number | null
    clickCount: number | null
    replyCount: number | null
    bounceCount: number | null
  }

  export type CampaignSumAggregateOutputType = {
    totalLeads: number | null
    sentCount: number | null
    openCount: number | null
    clickCount: number | null
    replyCount: number | null
    bounceCount: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    type: string | null
    status: string | null
    subject: string | null
    fromName: string | null
    fromEmail: string | null
    replyTo: string | null
    templateId: string | null
    htmlContent: string | null
    textContent: string | null
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    totalLeads: number | null
    sentCount: number | null
    openCount: number | null
    clickCount: number | null
    replyCount: number | null
    bounceCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    type: string | null
    status: string | null
    subject: string | null
    fromName: string | null
    fromEmail: string | null
    replyTo: string | null
    templateId: string | null
    htmlContent: string | null
    textContent: string | null
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    totalLeads: number | null
    sentCount: number | null
    openCount: number | null
    clickCount: number | null
    replyCount: number | null
    bounceCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    description: number
    type: number
    status: number
    subject: number
    fromName: number
    fromEmail: number
    replyTo: number
    templateId: number
    htmlContent: number
    textContent: number
    scheduledAt: number
    startedAt: number
    completedAt: number
    totalLeads: number
    sentCount: number
    openCount: number
    clickCount: number
    replyCount: number
    bounceCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    totalLeads?: true
    sentCount?: true
    openCount?: true
    clickCount?: true
    replyCount?: true
    bounceCount?: true
  }

  export type CampaignSumAggregateInputType = {
    totalLeads?: true
    sentCount?: true
    openCount?: true
    clickCount?: true
    replyCount?: true
    bounceCount?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    type?: true
    status?: true
    subject?: true
    fromName?: true
    fromEmail?: true
    replyTo?: true
    templateId?: true
    htmlContent?: true
    textContent?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
    totalLeads?: true
    sentCount?: true
    openCount?: true
    clickCount?: true
    replyCount?: true
    bounceCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    type?: true
    status?: true
    subject?: true
    fromName?: true
    fromEmail?: true
    replyTo?: true
    templateId?: true
    htmlContent?: true
    textContent?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
    totalLeads?: true
    sentCount?: true
    openCount?: true
    clickCount?: true
    replyCount?: true
    bounceCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    type?: true
    status?: true
    subject?: true
    fromName?: true
    fromEmail?: true
    replyTo?: true
    templateId?: true
    htmlContent?: true
    textContent?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
    totalLeads?: true
    sentCount?: true
    openCount?: true
    clickCount?: true
    replyCount?: true
    bounceCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    userId: string
    name: string
    description: string | null
    type: string
    status: string
    subject: string | null
    fromName: string | null
    fromEmail: string | null
    replyTo: string | null
    templateId: string | null
    htmlContent: string | null
    textContent: string | null
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    totalLeads: number
    sentCount: number
    openCount: number
    clickCount: number
    replyCount: number
    bounceCount: number
    createdAt: Date
    updatedAt: Date
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    subject?: boolean
    fromName?: boolean
    fromEmail?: boolean
    replyTo?: boolean
    templateId?: boolean
    htmlContent?: boolean
    textContent?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    totalLeads?: boolean
    sentCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    replyCount?: boolean
    bounceCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | Campaign$templateArgs<ExtArgs>
    campaignLeads?: boolean | Campaign$campaignLeadsArgs<ExtArgs>
    emailEvents?: boolean | Campaign$emailEventsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    subject?: boolean
    fromName?: boolean
    fromEmail?: boolean
    replyTo?: boolean
    templateId?: boolean
    htmlContent?: boolean
    textContent?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    totalLeads?: boolean
    sentCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    replyCount?: boolean
    bounceCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | Campaign$templateArgs<ExtArgs>
    campaignLeads?: boolean | Campaign$campaignLeadsArgs<ExtArgs>
    emailEvents?: boolean | Campaign$emailEventsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      template: Prisma.$EmailTemplatePayload<ExtArgs> | null
      campaignLeads: Prisma.$CampaignLeadPayload<ExtArgs>[]
      emailEvents: Prisma.$EmailEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      description: string | null
      type: string
      status: string
      subject: string | null
      fromName: string | null
      fromEmail: string | null
      replyTo: string | null
      templateId: string | null
      htmlContent: string | null
      textContent: string | null
      scheduledAt: Date | null
      startedAt: Date | null
      completedAt: Date | null
      totalLeads: number
      sentCount: number
      openCount: number
      clickCount: number
      replyCount: number
      bounceCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }


  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CampaignFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>
    ): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Campaign that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CampaignFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>
    ): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CampaignFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
    **/
    create<T extends CampaignCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>
    ): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Campaigns.
     *     @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     *     @example
     *     // Create many Campaigns
     *     const campaign = await prisma.campaign.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CampaignCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
    **/
    delete<T extends CampaignDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>
    ): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CampaignUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>
    ): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CampaignDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CampaignUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
    **/
    upsert<T extends CampaignUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>
    ): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    template<T extends Campaign$templateArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$templateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    campaignLeads<T extends Campaign$campaignLeadsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$campaignLeadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, 'findMany'> | Null>;

    emailEvents<T extends Campaign$emailEventsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$emailEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Campaign model
   */ 
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly userId: FieldRef<"Campaign", 'String'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly description: FieldRef<"Campaign", 'String'>
    readonly type: FieldRef<"Campaign", 'String'>
    readonly status: FieldRef<"Campaign", 'String'>
    readonly subject: FieldRef<"Campaign", 'String'>
    readonly fromName: FieldRef<"Campaign", 'String'>
    readonly fromEmail: FieldRef<"Campaign", 'String'>
    readonly replyTo: FieldRef<"Campaign", 'String'>
    readonly templateId: FieldRef<"Campaign", 'String'>
    readonly htmlContent: FieldRef<"Campaign", 'String'>
    readonly textContent: FieldRef<"Campaign", 'String'>
    readonly scheduledAt: FieldRef<"Campaign", 'DateTime'>
    readonly startedAt: FieldRef<"Campaign", 'DateTime'>
    readonly completedAt: FieldRef<"Campaign", 'DateTime'>
    readonly totalLeads: FieldRef<"Campaign", 'Int'>
    readonly sentCount: FieldRef<"Campaign", 'Int'>
    readonly openCount: FieldRef<"Campaign", 'Int'>
    readonly clickCount: FieldRef<"Campaign", 'Int'>
    readonly replyCount: FieldRef<"Campaign", 'Int'>
    readonly bounceCount: FieldRef<"Campaign", 'Int'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }


  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }


  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }


  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }


  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }


  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }


  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }


  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
  }


  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }


  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }


  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
  }


  /**
   * Campaign.template
   */
  export type Campaign$templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    where?: EmailTemplateWhereInput
  }


  /**
   * Campaign.campaignLeads
   */
  export type Campaign$campaignLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    where?: CampaignLeadWhereInput
    orderBy?: CampaignLeadOrderByWithRelationInput | CampaignLeadOrderByWithRelationInput[]
    cursor?: CampaignLeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignLeadScalarFieldEnum | CampaignLeadScalarFieldEnum[]
  }


  /**
   * Campaign.emailEvents
   */
  export type Campaign$emailEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailEventInclude<ExtArgs> | null
    where?: EmailEventWhereInput
    orderBy?: EmailEventOrderByWithRelationInput | EmailEventOrderByWithRelationInput[]
    cursor?: EmailEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailEventScalarFieldEnum | EmailEventScalarFieldEnum[]
  }


  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
  }



  /**
   * Model CampaignLead
   */

  export type AggregateCampaignLead = {
    _count: CampaignLeadCountAggregateOutputType | null
    _min: CampaignLeadMinAggregateOutputType | null
    _max: CampaignLeadMaxAggregateOutputType | null
  }

  export type CampaignLeadMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    leadId: string | null
    status: string | null
    sentAt: Date | null
    openedAt: Date | null
    clickedAt: Date | null
    repliedAt: Date | null
  }

  export type CampaignLeadMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    leadId: string | null
    status: string | null
    sentAt: Date | null
    openedAt: Date | null
    clickedAt: Date | null
    repliedAt: Date | null
  }

  export type CampaignLeadCountAggregateOutputType = {
    id: number
    campaignId: number
    leadId: number
    status: number
    sentAt: number
    openedAt: number
    clickedAt: number
    repliedAt: number
    _all: number
  }


  export type CampaignLeadMinAggregateInputType = {
    id?: true
    campaignId?: true
    leadId?: true
    status?: true
    sentAt?: true
    openedAt?: true
    clickedAt?: true
    repliedAt?: true
  }

  export type CampaignLeadMaxAggregateInputType = {
    id?: true
    campaignId?: true
    leadId?: true
    status?: true
    sentAt?: true
    openedAt?: true
    clickedAt?: true
    repliedAt?: true
  }

  export type CampaignLeadCountAggregateInputType = {
    id?: true
    campaignId?: true
    leadId?: true
    status?: true
    sentAt?: true
    openedAt?: true
    clickedAt?: true
    repliedAt?: true
    _all?: true
  }

  export type CampaignLeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignLead to aggregate.
     */
    where?: CampaignLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLeads to fetch.
     */
    orderBy?: CampaignLeadOrderByWithRelationInput | CampaignLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignLeads
    **/
    _count?: true | CampaignLeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignLeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignLeadMaxAggregateInputType
  }

  export type GetCampaignLeadAggregateType<T extends CampaignLeadAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignLead[P]>
      : GetScalarType<T[P], AggregateCampaignLead[P]>
  }




  export type CampaignLeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignLeadWhereInput
    orderBy?: CampaignLeadOrderByWithAggregationInput | CampaignLeadOrderByWithAggregationInput[]
    by: CampaignLeadScalarFieldEnum[] | CampaignLeadScalarFieldEnum
    having?: CampaignLeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignLeadCountAggregateInputType | true
    _min?: CampaignLeadMinAggregateInputType
    _max?: CampaignLeadMaxAggregateInputType
  }

  export type CampaignLeadGroupByOutputType = {
    id: string
    campaignId: string
    leadId: string
    status: string
    sentAt: Date | null
    openedAt: Date | null
    clickedAt: Date | null
    repliedAt: Date | null
    _count: CampaignLeadCountAggregateOutputType | null
    _min: CampaignLeadMinAggregateOutputType | null
    _max: CampaignLeadMaxAggregateOutputType | null
  }

  type GetCampaignLeadGroupByPayload<T extends CampaignLeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignLeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignLeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignLeadGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignLeadGroupByOutputType[P]>
        }
      >
    >


  export type CampaignLeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    leadId?: boolean
    status?: boolean
    sentAt?: boolean
    openedAt?: boolean
    clickedAt?: boolean
    repliedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignLead"]>

  export type CampaignLeadSelectScalar = {
    id?: boolean
    campaignId?: boolean
    leadId?: boolean
    status?: boolean
    sentAt?: boolean
    openedAt?: boolean
    clickedAt?: boolean
    repliedAt?: boolean
  }

  export type CampaignLeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }


  export type $CampaignLeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignLead"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      lead: Prisma.$LeadPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      leadId: string
      status: string
      sentAt: Date | null
      openedAt: Date | null
      clickedAt: Date | null
      repliedAt: Date | null
    }, ExtArgs["result"]["campaignLead"]>
    composites: {}
  }


  type CampaignLeadGetPayload<S extends boolean | null | undefined | CampaignLeadDefaultArgs> = $Result.GetResult<Prisma.$CampaignLeadPayload, S>

  type CampaignLeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignLeadFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CampaignLeadCountAggregateInputType | true
    }

  export interface CampaignLeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignLead'], meta: { name: 'CampaignLead' } }
    /**
     * Find zero or one CampaignLead that matches the filter.
     * @param {CampaignLeadFindUniqueArgs} args - Arguments to find a CampaignLead
     * @example
     * // Get one CampaignLead
     * const campaignLead = await prisma.campaignLead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CampaignLeadFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignLeadFindUniqueArgs<ExtArgs>>
    ): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CampaignLead that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CampaignLeadFindUniqueOrThrowArgs} args - Arguments to find a CampaignLead
     * @example
     * // Get one CampaignLead
     * const campaignLead = await prisma.campaignLead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CampaignLeadFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignLeadFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CampaignLead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLeadFindFirstArgs} args - Arguments to find a CampaignLead
     * @example
     * // Get one CampaignLead
     * const campaignLead = await prisma.campaignLead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CampaignLeadFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignLeadFindFirstArgs<ExtArgs>>
    ): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CampaignLead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLeadFindFirstOrThrowArgs} args - Arguments to find a CampaignLead
     * @example
     * // Get one CampaignLead
     * const campaignLead = await prisma.campaignLead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CampaignLeadFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignLeadFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CampaignLeads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLeadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignLeads
     * const campaignLeads = await prisma.campaignLead.findMany()
     * 
     * // Get first 10 CampaignLeads
     * const campaignLeads = await prisma.campaignLead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignLeadWithIdOnly = await prisma.campaignLead.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CampaignLeadFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignLeadFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CampaignLead.
     * @param {CampaignLeadCreateArgs} args - Arguments to create a CampaignLead.
     * @example
     * // Create one CampaignLead
     * const CampaignLead = await prisma.campaignLead.create({
     *   data: {
     *     // ... data to create a CampaignLead
     *   }
     * })
     * 
    **/
    create<T extends CampaignLeadCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignLeadCreateArgs<ExtArgs>>
    ): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CampaignLeads.
     *     @param {CampaignLeadCreateManyArgs} args - Arguments to create many CampaignLeads.
     *     @example
     *     // Create many CampaignLeads
     *     const campaignLead = await prisma.campaignLead.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CampaignLeadCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignLeadCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CampaignLead.
     * @param {CampaignLeadDeleteArgs} args - Arguments to delete one CampaignLead.
     * @example
     * // Delete one CampaignLead
     * const CampaignLead = await prisma.campaignLead.delete({
     *   where: {
     *     // ... filter to delete one CampaignLead
     *   }
     * })
     * 
    **/
    delete<T extends CampaignLeadDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignLeadDeleteArgs<ExtArgs>>
    ): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CampaignLead.
     * @param {CampaignLeadUpdateArgs} args - Arguments to update one CampaignLead.
     * @example
     * // Update one CampaignLead
     * const campaignLead = await prisma.campaignLead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CampaignLeadUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignLeadUpdateArgs<ExtArgs>>
    ): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CampaignLeads.
     * @param {CampaignLeadDeleteManyArgs} args - Arguments to filter CampaignLeads to delete.
     * @example
     * // Delete a few CampaignLeads
     * const { count } = await prisma.campaignLead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CampaignLeadDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignLeadDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignLeads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignLeads
     * const campaignLead = await prisma.campaignLead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CampaignLeadUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignLeadUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignLead.
     * @param {CampaignLeadUpsertArgs} args - Arguments to update or create a CampaignLead.
     * @example
     * // Update or create a CampaignLead
     * const campaignLead = await prisma.campaignLead.upsert({
     *   create: {
     *     // ... data to create a CampaignLead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignLead we want to update
     *   }
     * })
    **/
    upsert<T extends CampaignLeadUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignLeadUpsertArgs<ExtArgs>>
    ): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CampaignLeads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLeadCountArgs} args - Arguments to filter CampaignLeads to count.
     * @example
     * // Count the number of CampaignLeads
     * const count = await prisma.campaignLead.count({
     *   where: {
     *     // ... the filter for the CampaignLeads we want to count
     *   }
     * })
    **/
    count<T extends CampaignLeadCountArgs>(
      args?: Subset<T, CampaignLeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignLeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignLead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignLeadAggregateArgs>(args: Subset<T, CampaignLeadAggregateArgs>): Prisma.PrismaPromise<GetCampaignLeadAggregateType<T>>

    /**
     * Group by CampaignLead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignLeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignLeadGroupByArgs['orderBy'] }
        : { orderBy?: CampaignLeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignLeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignLead model
   */
  readonly fields: CampaignLeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignLead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignLeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    lead<T extends LeadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeadDefaultArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CampaignLead model
   */ 
  interface CampaignLeadFieldRefs {
    readonly id: FieldRef<"CampaignLead", 'String'>
    readonly campaignId: FieldRef<"CampaignLead", 'String'>
    readonly leadId: FieldRef<"CampaignLead", 'String'>
    readonly status: FieldRef<"CampaignLead", 'String'>
    readonly sentAt: FieldRef<"CampaignLead", 'DateTime'>
    readonly openedAt: FieldRef<"CampaignLead", 'DateTime'>
    readonly clickedAt: FieldRef<"CampaignLead", 'DateTime'>
    readonly repliedAt: FieldRef<"CampaignLead", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * CampaignLead findUnique
   */
  export type CampaignLeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLead to fetch.
     */
    where: CampaignLeadWhereUniqueInput
  }


  /**
   * CampaignLead findUniqueOrThrow
   */
  export type CampaignLeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLead to fetch.
     */
    where: CampaignLeadWhereUniqueInput
  }


  /**
   * CampaignLead findFirst
   */
  export type CampaignLeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLead to fetch.
     */
    where?: CampaignLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLeads to fetch.
     */
    orderBy?: CampaignLeadOrderByWithRelationInput | CampaignLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignLeads.
     */
    cursor?: CampaignLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignLeads.
     */
    distinct?: CampaignLeadScalarFieldEnum | CampaignLeadScalarFieldEnum[]
  }


  /**
   * CampaignLead findFirstOrThrow
   */
  export type CampaignLeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLead to fetch.
     */
    where?: CampaignLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLeads to fetch.
     */
    orderBy?: CampaignLeadOrderByWithRelationInput | CampaignLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignLeads.
     */
    cursor?: CampaignLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignLeads.
     */
    distinct?: CampaignLeadScalarFieldEnum | CampaignLeadScalarFieldEnum[]
  }


  /**
   * CampaignLead findMany
   */
  export type CampaignLeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLeads to fetch.
     */
    where?: CampaignLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLeads to fetch.
     */
    orderBy?: CampaignLeadOrderByWithRelationInput | CampaignLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignLeads.
     */
    cursor?: CampaignLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLeads.
     */
    skip?: number
    distinct?: CampaignLeadScalarFieldEnum | CampaignLeadScalarFieldEnum[]
  }


  /**
   * CampaignLead create
   */
  export type CampaignLeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignLead.
     */
    data: XOR<CampaignLeadCreateInput, CampaignLeadUncheckedCreateInput>
  }


  /**
   * CampaignLead createMany
   */
  export type CampaignLeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignLeads.
     */
    data: CampaignLeadCreateManyInput | CampaignLeadCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CampaignLead update
   */
  export type CampaignLeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignLead.
     */
    data: XOR<CampaignLeadUpdateInput, CampaignLeadUncheckedUpdateInput>
    /**
     * Choose, which CampaignLead to update.
     */
    where: CampaignLeadWhereUniqueInput
  }


  /**
   * CampaignLead updateMany
   */
  export type CampaignLeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignLeads.
     */
    data: XOR<CampaignLeadUpdateManyMutationInput, CampaignLeadUncheckedUpdateManyInput>
    /**
     * Filter which CampaignLeads to update
     */
    where?: CampaignLeadWhereInput
  }


  /**
   * CampaignLead upsert
   */
  export type CampaignLeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignLead to update in case it exists.
     */
    where: CampaignLeadWhereUniqueInput
    /**
     * In case the CampaignLead found by the `where` argument doesn't exist, create a new CampaignLead with this data.
     */
    create: XOR<CampaignLeadCreateInput, CampaignLeadUncheckedCreateInput>
    /**
     * In case the CampaignLead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignLeadUpdateInput, CampaignLeadUncheckedUpdateInput>
  }


  /**
   * CampaignLead delete
   */
  export type CampaignLeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * Filter which CampaignLead to delete.
     */
    where: CampaignLeadWhereUniqueInput
  }


  /**
   * CampaignLead deleteMany
   */
  export type CampaignLeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignLeads to delete
     */
    where?: CampaignLeadWhereInput
  }


  /**
   * CampaignLead without action
   */
  export type CampaignLeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignLeadInclude<ExtArgs> | null
  }



  /**
   * Model EmailTemplate
   */

  export type AggregateEmailTemplate = {
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  export type EmailTemplateMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    subject: string | null
    htmlContent: string | null
    textContent: string | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTemplateMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    subject: string | null
    htmlContent: string | null
    textContent: string | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTemplateCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    subject: number
    htmlContent: number
    textContent: number
    variables: number
    isDefault: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailTemplateMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    subject?: true
    htmlContent?: true
    textContent?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTemplateMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    subject?: true
    htmlContent?: true
    textContent?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTemplateCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    subject?: true
    htmlContent?: true
    textContent?: true
    variables?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplate to aggregate.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailTemplates
    **/
    _count?: true | EmailTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type GetEmailTemplateAggregateType<T extends EmailTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailTemplate[P]>
      : GetScalarType<T[P], AggregateEmailTemplate[P]>
  }




  export type EmailTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTemplateWhereInput
    orderBy?: EmailTemplateOrderByWithAggregationInput | EmailTemplateOrderByWithAggregationInput[]
    by: EmailTemplateScalarFieldEnum[] | EmailTemplateScalarFieldEnum
    having?: EmailTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailTemplateCountAggregateInputType | true
    _min?: EmailTemplateMinAggregateInputType
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type EmailTemplateGroupByOutputType = {
    id: string
    userId: string
    name: string
    subject: string | null
    htmlContent: string | null
    textContent: string | null
    variables: string[]
    isDefault: boolean
    createdAt: Date
    updatedAt: Date
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  type GetEmailTemplateGroupByPayload<T extends EmailTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
        }
      >
    >


  export type EmailTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    subject?: boolean
    htmlContent?: boolean
    textContent?: boolean
    variables?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaigns?: boolean | EmailTemplate$campaignsArgs<ExtArgs>
    _count?: boolean | EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    subject?: boolean
    htmlContent?: boolean
    textContent?: boolean
    variables?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaigns?: boolean | EmailTemplate$campaignsArgs<ExtArgs>
    _count?: boolean | EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EmailTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailTemplate"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      subject: string | null
      htmlContent: string | null
      textContent: string | null
      variables: string[]
      isDefault: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailTemplate"]>
    composites: {}
  }


  type EmailTemplateGetPayload<S extends boolean | null | undefined | EmailTemplateDefaultArgs> = $Result.GetResult<Prisma.$EmailTemplatePayload, S>

  type EmailTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailTemplateFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: EmailTemplateCountAggregateInputType | true
    }

  export interface EmailTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailTemplate'], meta: { name: 'EmailTemplate' } }
    /**
     * Find zero or one EmailTemplate that matches the filter.
     * @param {EmailTemplateFindUniqueArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailTemplateFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTemplateFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmailTemplate that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmailTemplateFindUniqueOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailTemplateFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTemplateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmailTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailTemplateFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTemplateFindFirstArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmailTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailTemplateFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTemplateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmailTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany()
     * 
     * // Get first 10 EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailTemplateFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTemplateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmailTemplate.
     * @param {EmailTemplateCreateArgs} args - Arguments to create a EmailTemplate.
     * @example
     * // Create one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.create({
     *   data: {
     *     // ... data to create a EmailTemplate
     *   }
     * })
     * 
    **/
    create<T extends EmailTemplateCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTemplateCreateArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmailTemplates.
     *     @param {EmailTemplateCreateManyArgs} args - Arguments to create many EmailTemplates.
     *     @example
     *     // Create many EmailTemplates
     *     const emailTemplate = await prisma.emailTemplate.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmailTemplateCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTemplateCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailTemplate.
     * @param {EmailTemplateDeleteArgs} args - Arguments to delete one EmailTemplate.
     * @example
     * // Delete one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.delete({
     *   where: {
     *     // ... filter to delete one EmailTemplate
     *   }
     * })
     * 
    **/
    delete<T extends EmailTemplateDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTemplateDeleteArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmailTemplate.
     * @param {EmailTemplateUpdateArgs} args - Arguments to update one EmailTemplate.
     * @example
     * // Update one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailTemplateUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTemplateUpdateArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmailTemplates.
     * @param {EmailTemplateDeleteManyArgs} args - Arguments to filter EmailTemplates to delete.
     * @example
     * // Delete a few EmailTemplates
     * const { count } = await prisma.emailTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailTemplateDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTemplateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailTemplateUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTemplateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailTemplate.
     * @param {EmailTemplateUpsertArgs} args - Arguments to update or create a EmailTemplate.
     * @example
     * // Update or create a EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.upsert({
     *   create: {
     *     // ... data to create a EmailTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailTemplate we want to update
     *   }
     * })
    **/
    upsert<T extends EmailTemplateUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTemplateUpsertArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateCountArgs} args - Arguments to filter EmailTemplates to count.
     * @example
     * // Count the number of EmailTemplates
     * const count = await prisma.emailTemplate.count({
     *   where: {
     *     // ... the filter for the EmailTemplates we want to count
     *   }
     * })
    **/
    count<T extends EmailTemplateCountArgs>(
      args?: Subset<T, EmailTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailTemplateAggregateArgs>(args: Subset<T, EmailTemplateAggregateArgs>): Prisma.PrismaPromise<GetEmailTemplateAggregateType<T>>

    /**
     * Group by EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailTemplateGroupByArgs['orderBy'] }
        : { orderBy?: EmailTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailTemplate model
   */
  readonly fields: EmailTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    campaigns<T extends EmailTemplate$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, EmailTemplate$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmailTemplate model
   */ 
  interface EmailTemplateFieldRefs {
    readonly id: FieldRef<"EmailTemplate", 'String'>
    readonly userId: FieldRef<"EmailTemplate", 'String'>
    readonly name: FieldRef<"EmailTemplate", 'String'>
    readonly subject: FieldRef<"EmailTemplate", 'String'>
    readonly htmlContent: FieldRef<"EmailTemplate", 'String'>
    readonly textContent: FieldRef<"EmailTemplate", 'String'>
    readonly variables: FieldRef<"EmailTemplate", 'String[]'>
    readonly isDefault: FieldRef<"EmailTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"EmailTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailTemplate", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * EmailTemplate findUnique
   */
  export type EmailTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }


  /**
   * EmailTemplate findUniqueOrThrow
   */
  export type EmailTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }


  /**
   * EmailTemplate findFirst
   */
  export type EmailTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }


  /**
   * EmailTemplate findFirstOrThrow
   */
  export type EmailTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }


  /**
   * EmailTemplate findMany
   */
  export type EmailTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplates to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }


  /**
   * EmailTemplate create
   */
  export type EmailTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailTemplate.
     */
    data: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
  }


  /**
   * EmailTemplate createMany
   */
  export type EmailTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmailTemplate update
   */
  export type EmailTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailTemplate.
     */
    data: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
    /**
     * Choose, which EmailTemplate to update.
     */
    where: EmailTemplateWhereUniqueInput
  }


  /**
   * EmailTemplate updateMany
   */
  export type EmailTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
  }


  /**
   * EmailTemplate upsert
   */
  export type EmailTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailTemplate to update in case it exists.
     */
    where: EmailTemplateWhereUniqueInput
    /**
     * In case the EmailTemplate found by the `where` argument doesn't exist, create a new EmailTemplate with this data.
     */
    create: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
    /**
     * In case the EmailTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
  }


  /**
   * EmailTemplate delete
   */
  export type EmailTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter which EmailTemplate to delete.
     */
    where: EmailTemplateWhereUniqueInput
  }


  /**
   * EmailTemplate deleteMany
   */
  export type EmailTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplates to delete
     */
    where?: EmailTemplateWhereInput
  }


  /**
   * EmailTemplate.campaigns
   */
  export type EmailTemplate$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }


  /**
   * EmailTemplate without action
   */
  export type EmailTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTemplateInclude<ExtArgs> | null
  }



  /**
   * Model EmailEvent
   */

  export type AggregateEmailEvent = {
    _count: EmailEventCountAggregateOutputType | null
    _min: EmailEventMinAggregateOutputType | null
    _max: EmailEventMaxAggregateOutputType | null
  }

  export type EmailEventMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    leadId: string | null
    eventType: string | null
    createdAt: Date | null
  }

  export type EmailEventMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    leadId: string | null
    eventType: string | null
    createdAt: Date | null
  }

  export type EmailEventCountAggregateOutputType = {
    id: number
    campaignId: number
    leadId: number
    eventType: number
    eventData: number
    createdAt: number
    _all: number
  }


  export type EmailEventMinAggregateInputType = {
    id?: true
    campaignId?: true
    leadId?: true
    eventType?: true
    createdAt?: true
  }

  export type EmailEventMaxAggregateInputType = {
    id?: true
    campaignId?: true
    leadId?: true
    eventType?: true
    createdAt?: true
  }

  export type EmailEventCountAggregateInputType = {
    id?: true
    campaignId?: true
    leadId?: true
    eventType?: true
    eventData?: true
    createdAt?: true
    _all?: true
  }

  export type EmailEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailEvent to aggregate.
     */
    where?: EmailEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailEvents to fetch.
     */
    orderBy?: EmailEventOrderByWithRelationInput | EmailEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailEvents
    **/
    _count?: true | EmailEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailEventMaxAggregateInputType
  }

  export type GetEmailEventAggregateType<T extends EmailEventAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailEvent[P]>
      : GetScalarType<T[P], AggregateEmailEvent[P]>
  }




  export type EmailEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailEventWhereInput
    orderBy?: EmailEventOrderByWithAggregationInput | EmailEventOrderByWithAggregationInput[]
    by: EmailEventScalarFieldEnum[] | EmailEventScalarFieldEnum
    having?: EmailEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailEventCountAggregateInputType | true
    _min?: EmailEventMinAggregateInputType
    _max?: EmailEventMaxAggregateInputType
  }

  export type EmailEventGroupByOutputType = {
    id: string
    campaignId: string
    leadId: string
    eventType: string
    eventData: JsonValue | null
    createdAt: Date
    _count: EmailEventCountAggregateOutputType | null
    _min: EmailEventMinAggregateOutputType | null
    _max: EmailEventMaxAggregateOutputType | null
  }

  type GetEmailEventGroupByPayload<T extends EmailEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailEventGroupByOutputType[P]>
            : GetScalarType<T[P], EmailEventGroupByOutputType[P]>
        }
      >
    >


  export type EmailEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    leadId?: boolean
    eventType?: boolean
    eventData?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailEvent"]>

  export type EmailEventSelectScalar = {
    id?: boolean
    campaignId?: boolean
    leadId?: boolean
    eventType?: boolean
    eventData?: boolean
    createdAt?: boolean
  }

  export type EmailEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }


  export type $EmailEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailEvent"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      lead: Prisma.$LeadPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      leadId: string
      eventType: string
      eventData: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["emailEvent"]>
    composites: {}
  }


  type EmailEventGetPayload<S extends boolean | null | undefined | EmailEventDefaultArgs> = $Result.GetResult<Prisma.$EmailEventPayload, S>

  type EmailEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailEventFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: EmailEventCountAggregateInputType | true
    }

  export interface EmailEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailEvent'], meta: { name: 'EmailEvent' } }
    /**
     * Find zero or one EmailEvent that matches the filter.
     * @param {EmailEventFindUniqueArgs} args - Arguments to find a EmailEvent
     * @example
     * // Get one EmailEvent
     * const emailEvent = await prisma.emailEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailEventFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmailEventFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailEventClient<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmailEvent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmailEventFindUniqueOrThrowArgs} args - Arguments to find a EmailEvent
     * @example
     * // Get one EmailEvent
     * const emailEvent = await prisma.emailEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailEventFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailEventFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailEventClient<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmailEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailEventFindFirstArgs} args - Arguments to find a EmailEvent
     * @example
     * // Get one EmailEvent
     * const emailEvent = await prisma.emailEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailEventFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailEventFindFirstArgs<ExtArgs>>
    ): Prisma__EmailEventClient<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmailEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailEventFindFirstOrThrowArgs} args - Arguments to find a EmailEvent
     * @example
     * // Get one EmailEvent
     * const emailEvent = await prisma.emailEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailEventFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailEventFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailEventClient<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmailEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailEventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailEvents
     * const emailEvents = await prisma.emailEvent.findMany()
     * 
     * // Get first 10 EmailEvents
     * const emailEvents = await prisma.emailEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailEventWithIdOnly = await prisma.emailEvent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailEventFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailEventFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmailEvent.
     * @param {EmailEventCreateArgs} args - Arguments to create a EmailEvent.
     * @example
     * // Create one EmailEvent
     * const EmailEvent = await prisma.emailEvent.create({
     *   data: {
     *     // ... data to create a EmailEvent
     *   }
     * })
     * 
    **/
    create<T extends EmailEventCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailEventCreateArgs<ExtArgs>>
    ): Prisma__EmailEventClient<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmailEvents.
     *     @param {EmailEventCreateManyArgs} args - Arguments to create many EmailEvents.
     *     @example
     *     // Create many EmailEvents
     *     const emailEvent = await prisma.emailEvent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmailEventCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailEventCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailEvent.
     * @param {EmailEventDeleteArgs} args - Arguments to delete one EmailEvent.
     * @example
     * // Delete one EmailEvent
     * const EmailEvent = await prisma.emailEvent.delete({
     *   where: {
     *     // ... filter to delete one EmailEvent
     *   }
     * })
     * 
    **/
    delete<T extends EmailEventDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmailEventDeleteArgs<ExtArgs>>
    ): Prisma__EmailEventClient<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmailEvent.
     * @param {EmailEventUpdateArgs} args - Arguments to update one EmailEvent.
     * @example
     * // Update one EmailEvent
     * const emailEvent = await prisma.emailEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailEventUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailEventUpdateArgs<ExtArgs>>
    ): Prisma__EmailEventClient<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmailEvents.
     * @param {EmailEventDeleteManyArgs} args - Arguments to filter EmailEvents to delete.
     * @example
     * // Delete a few EmailEvents
     * const { count } = await prisma.emailEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailEventDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailEventDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailEvents
     * const emailEvent = await prisma.emailEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailEventUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmailEventUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailEvent.
     * @param {EmailEventUpsertArgs} args - Arguments to update or create a EmailEvent.
     * @example
     * // Update or create a EmailEvent
     * const emailEvent = await prisma.emailEvent.upsert({
     *   create: {
     *     // ... data to create a EmailEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailEvent we want to update
     *   }
     * })
    **/
    upsert<T extends EmailEventUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmailEventUpsertArgs<ExtArgs>>
    ): Prisma__EmailEventClient<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmailEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailEventCountArgs} args - Arguments to filter EmailEvents to count.
     * @example
     * // Count the number of EmailEvents
     * const count = await prisma.emailEvent.count({
     *   where: {
     *     // ... the filter for the EmailEvents we want to count
     *   }
     * })
    **/
    count<T extends EmailEventCountArgs>(
      args?: Subset<T, EmailEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailEventAggregateArgs>(args: Subset<T, EmailEventAggregateArgs>): Prisma.PrismaPromise<GetEmailEventAggregateType<T>>

    /**
     * Group by EmailEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailEventGroupByArgs['orderBy'] }
        : { orderBy?: EmailEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailEvent model
   */
  readonly fields: EmailEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    lead<T extends LeadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeadDefaultArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmailEvent model
   */ 
  interface EmailEventFieldRefs {
    readonly id: FieldRef<"EmailEvent", 'String'>
    readonly campaignId: FieldRef<"EmailEvent", 'String'>
    readonly leadId: FieldRef<"EmailEvent", 'String'>
    readonly eventType: FieldRef<"EmailEvent", 'String'>
    readonly eventData: FieldRef<"EmailEvent", 'Json'>
    readonly createdAt: FieldRef<"EmailEvent", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * EmailEvent findUnique
   */
  export type EmailEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailEventInclude<ExtArgs> | null
    /**
     * Filter, which EmailEvent to fetch.
     */
    where: EmailEventWhereUniqueInput
  }


  /**
   * EmailEvent findUniqueOrThrow
   */
  export type EmailEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailEventInclude<ExtArgs> | null
    /**
     * Filter, which EmailEvent to fetch.
     */
    where: EmailEventWhereUniqueInput
  }


  /**
   * EmailEvent findFirst
   */
  export type EmailEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailEventInclude<ExtArgs> | null
    /**
     * Filter, which EmailEvent to fetch.
     */
    where?: EmailEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailEvents to fetch.
     */
    orderBy?: EmailEventOrderByWithRelationInput | EmailEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailEvents.
     */
    cursor?: EmailEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailEvents.
     */
    distinct?: EmailEventScalarFieldEnum | EmailEventScalarFieldEnum[]
  }


  /**
   * EmailEvent findFirstOrThrow
   */
  export type EmailEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailEventInclude<ExtArgs> | null
    /**
     * Filter, which EmailEvent to fetch.
     */
    where?: EmailEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailEvents to fetch.
     */
    orderBy?: EmailEventOrderByWithRelationInput | EmailEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailEvents.
     */
    cursor?: EmailEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailEvents.
     */
    distinct?: EmailEventScalarFieldEnum | EmailEventScalarFieldEnum[]
  }


  /**
   * EmailEvent findMany
   */
  export type EmailEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailEventInclude<ExtArgs> | null
    /**
     * Filter, which EmailEvents to fetch.
     */
    where?: EmailEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailEvents to fetch.
     */
    orderBy?: EmailEventOrderByWithRelationInput | EmailEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailEvents.
     */
    cursor?: EmailEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailEvents.
     */
    skip?: number
    distinct?: EmailEventScalarFieldEnum | EmailEventScalarFieldEnum[]
  }


  /**
   * EmailEvent create
   */
  export type EmailEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailEventInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailEvent.
     */
    data: XOR<EmailEventCreateInput, EmailEventUncheckedCreateInput>
  }


  /**
   * EmailEvent createMany
   */
  export type EmailEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailEvents.
     */
    data: EmailEventCreateManyInput | EmailEventCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmailEvent update
   */
  export type EmailEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailEventInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailEvent.
     */
    data: XOR<EmailEventUpdateInput, EmailEventUncheckedUpdateInput>
    /**
     * Choose, which EmailEvent to update.
     */
    where: EmailEventWhereUniqueInput
  }


  /**
   * EmailEvent updateMany
   */
  export type EmailEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailEvents.
     */
    data: XOR<EmailEventUpdateManyMutationInput, EmailEventUncheckedUpdateManyInput>
    /**
     * Filter which EmailEvents to update
     */
    where?: EmailEventWhereInput
  }


  /**
   * EmailEvent upsert
   */
  export type EmailEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailEventInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailEvent to update in case it exists.
     */
    where: EmailEventWhereUniqueInput
    /**
     * In case the EmailEvent found by the `where` argument doesn't exist, create a new EmailEvent with this data.
     */
    create: XOR<EmailEventCreateInput, EmailEventUncheckedCreateInput>
    /**
     * In case the EmailEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailEventUpdateInput, EmailEventUncheckedUpdateInput>
  }


  /**
   * EmailEvent delete
   */
  export type EmailEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailEventInclude<ExtArgs> | null
    /**
     * Filter which EmailEvent to delete.
     */
    where: EmailEventWhereUniqueInput
  }


  /**
   * EmailEvent deleteMany
   */
  export type EmailEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailEvents to delete
     */
    where?: EmailEventWhereInput
  }


  /**
   * EmailEvent without action
   */
  export type EmailEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailEventInclude<ExtArgs> | null
  }



  /**
   * Model Website
   */

  export type AggregateWebsite = {
    _count: WebsiteCountAggregateOutputType | null
    _min: WebsiteMinAggregateOutputType | null
    _max: WebsiteMaxAggregateOutputType | null
  }

  export type WebsiteMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    domain: string | null
    subdomain: string | null
    theme: string | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebsiteMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    domain: string | null
    subdomain: string | null
    theme: string | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebsiteCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    domain: number
    subdomain: number
    pages: number
    settings: number
    theme: number
    isPublished: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebsiteMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    domain?: true
    subdomain?: true
    theme?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebsiteMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    domain?: true
    subdomain?: true
    theme?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebsiteCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    domain?: true
    subdomain?: true
    pages?: true
    settings?: true
    theme?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebsiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Website to aggregate.
     */
    where?: WebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Websites to fetch.
     */
    orderBy?: WebsiteOrderByWithRelationInput | WebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Websites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Websites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Websites
    **/
    _count?: true | WebsiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebsiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebsiteMaxAggregateInputType
  }

  export type GetWebsiteAggregateType<T extends WebsiteAggregateArgs> = {
        [P in keyof T & keyof AggregateWebsite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebsite[P]>
      : GetScalarType<T[P], AggregateWebsite[P]>
  }




  export type WebsiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebsiteWhereInput
    orderBy?: WebsiteOrderByWithAggregationInput | WebsiteOrderByWithAggregationInput[]
    by: WebsiteScalarFieldEnum[] | WebsiteScalarFieldEnum
    having?: WebsiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebsiteCountAggregateInputType | true
    _min?: WebsiteMinAggregateInputType
    _max?: WebsiteMaxAggregateInputType
  }

  export type WebsiteGroupByOutputType = {
    id: string
    userId: string
    name: string
    domain: string | null
    subdomain: string | null
    pages: JsonValue | null
    settings: JsonValue | null
    theme: string | null
    isPublished: boolean
    createdAt: Date
    updatedAt: Date
    _count: WebsiteCountAggregateOutputType | null
    _min: WebsiteMinAggregateOutputType | null
    _max: WebsiteMaxAggregateOutputType | null
  }

  type GetWebsiteGroupByPayload<T extends WebsiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebsiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebsiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebsiteGroupByOutputType[P]>
            : GetScalarType<T[P], WebsiteGroupByOutputType[P]>
        }
      >
    >


  export type WebsiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    domain?: boolean
    subdomain?: boolean
    pages?: boolean
    settings?: boolean
    theme?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["website"]>

  export type WebsiteSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    domain?: boolean
    subdomain?: boolean
    pages?: boolean
    settings?: boolean
    theme?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WebsiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $WebsitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Website"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      domain: string | null
      subdomain: string | null
      pages: Prisma.JsonValue | null
      settings: Prisma.JsonValue | null
      theme: string | null
      isPublished: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["website"]>
    composites: {}
  }


  type WebsiteGetPayload<S extends boolean | null | undefined | WebsiteDefaultArgs> = $Result.GetResult<Prisma.$WebsitePayload, S>

  type WebsiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebsiteFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: WebsiteCountAggregateInputType | true
    }

  export interface WebsiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Website'], meta: { name: 'Website' } }
    /**
     * Find zero or one Website that matches the filter.
     * @param {WebsiteFindUniqueArgs} args - Arguments to find a Website
     * @example
     * // Get one Website
     * const website = await prisma.website.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WebsiteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WebsiteFindUniqueArgs<ExtArgs>>
    ): Prisma__WebsiteClient<$Result.GetResult<Prisma.$WebsitePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Website that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WebsiteFindUniqueOrThrowArgs} args - Arguments to find a Website
     * @example
     * // Get one Website
     * const website = await prisma.website.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WebsiteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WebsiteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WebsiteClient<$Result.GetResult<Prisma.$WebsitePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Website that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteFindFirstArgs} args - Arguments to find a Website
     * @example
     * // Get one Website
     * const website = await prisma.website.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WebsiteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WebsiteFindFirstArgs<ExtArgs>>
    ): Prisma__WebsiteClient<$Result.GetResult<Prisma.$WebsitePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Website that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteFindFirstOrThrowArgs} args - Arguments to find a Website
     * @example
     * // Get one Website
     * const website = await prisma.website.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WebsiteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WebsiteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WebsiteClient<$Result.GetResult<Prisma.$WebsitePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Websites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Websites
     * const websites = await prisma.website.findMany()
     * 
     * // Get first 10 Websites
     * const websites = await prisma.website.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const websiteWithIdOnly = await prisma.website.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WebsiteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WebsiteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsitePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Website.
     * @param {WebsiteCreateArgs} args - Arguments to create a Website.
     * @example
     * // Create one Website
     * const Website = await prisma.website.create({
     *   data: {
     *     // ... data to create a Website
     *   }
     * })
     * 
    **/
    create<T extends WebsiteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WebsiteCreateArgs<ExtArgs>>
    ): Prisma__WebsiteClient<$Result.GetResult<Prisma.$WebsitePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Websites.
     *     @param {WebsiteCreateManyArgs} args - Arguments to create many Websites.
     *     @example
     *     // Create many Websites
     *     const website = await prisma.website.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WebsiteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WebsiteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Website.
     * @param {WebsiteDeleteArgs} args - Arguments to delete one Website.
     * @example
     * // Delete one Website
     * const Website = await prisma.website.delete({
     *   where: {
     *     // ... filter to delete one Website
     *   }
     * })
     * 
    **/
    delete<T extends WebsiteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WebsiteDeleteArgs<ExtArgs>>
    ): Prisma__WebsiteClient<$Result.GetResult<Prisma.$WebsitePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Website.
     * @param {WebsiteUpdateArgs} args - Arguments to update one Website.
     * @example
     * // Update one Website
     * const website = await prisma.website.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WebsiteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WebsiteUpdateArgs<ExtArgs>>
    ): Prisma__WebsiteClient<$Result.GetResult<Prisma.$WebsitePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Websites.
     * @param {WebsiteDeleteManyArgs} args - Arguments to filter Websites to delete.
     * @example
     * // Delete a few Websites
     * const { count } = await prisma.website.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WebsiteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WebsiteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Websites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Websites
     * const website = await prisma.website.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WebsiteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WebsiteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Website.
     * @param {WebsiteUpsertArgs} args - Arguments to update or create a Website.
     * @example
     * // Update or create a Website
     * const website = await prisma.website.upsert({
     *   create: {
     *     // ... data to create a Website
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Website we want to update
     *   }
     * })
    **/
    upsert<T extends WebsiteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WebsiteUpsertArgs<ExtArgs>>
    ): Prisma__WebsiteClient<$Result.GetResult<Prisma.$WebsitePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Websites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteCountArgs} args - Arguments to filter Websites to count.
     * @example
     * // Count the number of Websites
     * const count = await prisma.website.count({
     *   where: {
     *     // ... the filter for the Websites we want to count
     *   }
     * })
    **/
    count<T extends WebsiteCountArgs>(
      args?: Subset<T, WebsiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebsiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Website.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebsiteAggregateArgs>(args: Subset<T, WebsiteAggregateArgs>): Prisma.PrismaPromise<GetWebsiteAggregateType<T>>

    /**
     * Group by Website.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebsiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebsiteGroupByArgs['orderBy'] }
        : { orderBy?: WebsiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebsiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebsiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Website model
   */
  readonly fields: WebsiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Website.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebsiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Website model
   */ 
  interface WebsiteFieldRefs {
    readonly id: FieldRef<"Website", 'String'>
    readonly userId: FieldRef<"Website", 'String'>
    readonly name: FieldRef<"Website", 'String'>
    readonly domain: FieldRef<"Website", 'String'>
    readonly subdomain: FieldRef<"Website", 'String'>
    readonly pages: FieldRef<"Website", 'Json'>
    readonly settings: FieldRef<"Website", 'Json'>
    readonly theme: FieldRef<"Website", 'String'>
    readonly isPublished: FieldRef<"Website", 'Boolean'>
    readonly createdAt: FieldRef<"Website", 'DateTime'>
    readonly updatedAt: FieldRef<"Website", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Website findUnique
   */
  export type WebsiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WebsiteInclude<ExtArgs> | null
    /**
     * Filter, which Website to fetch.
     */
    where: WebsiteWhereUniqueInput
  }


  /**
   * Website findUniqueOrThrow
   */
  export type WebsiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WebsiteInclude<ExtArgs> | null
    /**
     * Filter, which Website to fetch.
     */
    where: WebsiteWhereUniqueInput
  }


  /**
   * Website findFirst
   */
  export type WebsiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WebsiteInclude<ExtArgs> | null
    /**
     * Filter, which Website to fetch.
     */
    where?: WebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Websites to fetch.
     */
    orderBy?: WebsiteOrderByWithRelationInput | WebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Websites.
     */
    cursor?: WebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Websites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Websites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Websites.
     */
    distinct?: WebsiteScalarFieldEnum | WebsiteScalarFieldEnum[]
  }


  /**
   * Website findFirstOrThrow
   */
  export type WebsiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WebsiteInclude<ExtArgs> | null
    /**
     * Filter, which Website to fetch.
     */
    where?: WebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Websites to fetch.
     */
    orderBy?: WebsiteOrderByWithRelationInput | WebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Websites.
     */
    cursor?: WebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Websites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Websites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Websites.
     */
    distinct?: WebsiteScalarFieldEnum | WebsiteScalarFieldEnum[]
  }


  /**
   * Website findMany
   */
  export type WebsiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WebsiteInclude<ExtArgs> | null
    /**
     * Filter, which Websites to fetch.
     */
    where?: WebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Websites to fetch.
     */
    orderBy?: WebsiteOrderByWithRelationInput | WebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Websites.
     */
    cursor?: WebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Websites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Websites.
     */
    skip?: number
    distinct?: WebsiteScalarFieldEnum | WebsiteScalarFieldEnum[]
  }


  /**
   * Website create
   */
  export type WebsiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WebsiteInclude<ExtArgs> | null
    /**
     * The data needed to create a Website.
     */
    data: XOR<WebsiteCreateInput, WebsiteUncheckedCreateInput>
  }


  /**
   * Website createMany
   */
  export type WebsiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Websites.
     */
    data: WebsiteCreateManyInput | WebsiteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Website update
   */
  export type WebsiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WebsiteInclude<ExtArgs> | null
    /**
     * The data needed to update a Website.
     */
    data: XOR<WebsiteUpdateInput, WebsiteUncheckedUpdateInput>
    /**
     * Choose, which Website to update.
     */
    where: WebsiteWhereUniqueInput
  }


  /**
   * Website updateMany
   */
  export type WebsiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Websites.
     */
    data: XOR<WebsiteUpdateManyMutationInput, WebsiteUncheckedUpdateManyInput>
    /**
     * Filter which Websites to update
     */
    where?: WebsiteWhereInput
  }


  /**
   * Website upsert
   */
  export type WebsiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WebsiteInclude<ExtArgs> | null
    /**
     * The filter to search for the Website to update in case it exists.
     */
    where: WebsiteWhereUniqueInput
    /**
     * In case the Website found by the `where` argument doesn't exist, create a new Website with this data.
     */
    create: XOR<WebsiteCreateInput, WebsiteUncheckedCreateInput>
    /**
     * In case the Website was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebsiteUpdateInput, WebsiteUncheckedUpdateInput>
  }


  /**
   * Website delete
   */
  export type WebsiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WebsiteInclude<ExtArgs> | null
    /**
     * Filter which Website to delete.
     */
    where: WebsiteWhereUniqueInput
  }


  /**
   * Website deleteMany
   */
  export type WebsiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Websites to delete
     */
    where?: WebsiteWhereInput
  }


  /**
   * Website without action
   */
  export type WebsiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WebsiteInclude<ExtArgs> | null
  }



  /**
   * Model Video
   */

  export type AggregateVideo = {
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  export type VideoAvgAggregateOutputType = {
    duration: number | null
    fileSize: number | null
    viewCount: number | null
    earnings: Decimal | null
  }

  export type VideoSumAggregateOutputType = {
    duration: number | null
    fileSize: number | null
    viewCount: number | null
    earnings: Decimal | null
  }

  export type VideoMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    filename: string | null
    fileUrl: string | null
    thumbnailUrl: string | null
    duration: number | null
    fileSize: number | null
    isMonetized: boolean | null
    viewCount: number | null
    earnings: Decimal | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    filename: string | null
    fileUrl: string | null
    thumbnailUrl: string | null
    duration: number | null
    fileSize: number | null
    isMonetized: boolean | null
    viewCount: number | null
    earnings: Decimal | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    filename: number
    fileUrl: number
    thumbnailUrl: number
    duration: number
    fileSize: number
    isMonetized: number
    viewCount: number
    earnings: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VideoAvgAggregateInputType = {
    duration?: true
    fileSize?: true
    viewCount?: true
    earnings?: true
  }

  export type VideoSumAggregateInputType = {
    duration?: true
    fileSize?: true
    viewCount?: true
    earnings?: true
  }

  export type VideoMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    filename?: true
    fileUrl?: true
    thumbnailUrl?: true
    duration?: true
    fileSize?: true
    isMonetized?: true
    viewCount?: true
    earnings?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    filename?: true
    fileUrl?: true
    thumbnailUrl?: true
    duration?: true
    fileSize?: true
    isMonetized?: true
    viewCount?: true
    earnings?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    filename?: true
    fileUrl?: true
    thumbnailUrl?: true
    duration?: true
    fileSize?: true
    isMonetized?: true
    viewCount?: true
    earnings?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VideoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Video to aggregate.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Videos
    **/
    _count?: true | VideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoMaxAggregateInputType
  }

  export type GetVideoAggregateType<T extends VideoAggregateArgs> = {
        [P in keyof T & keyof AggregateVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideo[P]>
      : GetScalarType<T[P], AggregateVideo[P]>
  }




  export type VideoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoWhereInput
    orderBy?: VideoOrderByWithAggregationInput | VideoOrderByWithAggregationInput[]
    by: VideoScalarFieldEnum[] | VideoScalarFieldEnum
    having?: VideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoCountAggregateInputType | true
    _avg?: VideoAvgAggregateInputType
    _sum?: VideoSumAggregateInputType
    _min?: VideoMinAggregateInputType
    _max?: VideoMaxAggregateInputType
  }

  export type VideoGroupByOutputType = {
    id: string
    userId: string
    title: string
    description: string | null
    filename: string | null
    fileUrl: string | null
    thumbnailUrl: string | null
    duration: number | null
    fileSize: number | null
    isMonetized: boolean
    viewCount: number
    earnings: Decimal
    status: string
    createdAt: Date
    updatedAt: Date
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  type GetVideoGroupByPayload<T extends VideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoGroupByOutputType[P]>
            : GetScalarType<T[P], VideoGroupByOutputType[P]>
        }
      >
    >


  export type VideoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    filename?: boolean
    fileUrl?: boolean
    thumbnailUrl?: boolean
    duration?: boolean
    fileSize?: boolean
    isMonetized?: boolean
    viewCount?: boolean
    earnings?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["video"]>

  export type VideoSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    filename?: boolean
    fileUrl?: boolean
    thumbnailUrl?: boolean
    duration?: boolean
    fileSize?: boolean
    isMonetized?: boolean
    viewCount?: boolean
    earnings?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VideoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $VideoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Video"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      description: string | null
      filename: string | null
      fileUrl: string | null
      thumbnailUrl: string | null
      duration: number | null
      fileSize: number | null
      isMonetized: boolean
      viewCount: number
      earnings: Prisma.Decimal
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["video"]>
    composites: {}
  }


  type VideoGetPayload<S extends boolean | null | undefined | VideoDefaultArgs> = $Result.GetResult<Prisma.$VideoPayload, S>

  type VideoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VideoFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: VideoCountAggregateInputType | true
    }

  export interface VideoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Video'], meta: { name: 'Video' } }
    /**
     * Find zero or one Video that matches the filter.
     * @param {VideoFindUniqueArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VideoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, VideoFindUniqueArgs<ExtArgs>>
    ): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Video that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VideoFindUniqueOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VideoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VideoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Video that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VideoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, VideoFindFirstArgs<ExtArgs>>
    ): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Video that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VideoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VideoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos
     * const videos = await prisma.video.findMany()
     * 
     * // Get first 10 Videos
     * const videos = await prisma.video.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoWithIdOnly = await prisma.video.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VideoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VideoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Video.
     * @param {VideoCreateArgs} args - Arguments to create a Video.
     * @example
     * // Create one Video
     * const Video = await prisma.video.create({
     *   data: {
     *     // ... data to create a Video
     *   }
     * })
     * 
    **/
    create<T extends VideoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, VideoCreateArgs<ExtArgs>>
    ): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Videos.
     *     @param {VideoCreateManyArgs} args - Arguments to create many Videos.
     *     @example
     *     // Create many Videos
     *     const video = await prisma.video.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VideoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VideoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Video.
     * @param {VideoDeleteArgs} args - Arguments to delete one Video.
     * @example
     * // Delete one Video
     * const Video = await prisma.video.delete({
     *   where: {
     *     // ... filter to delete one Video
     *   }
     * })
     * 
    **/
    delete<T extends VideoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, VideoDeleteArgs<ExtArgs>>
    ): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Video.
     * @param {VideoUpdateArgs} args - Arguments to update one Video.
     * @example
     * // Update one Video
     * const video = await prisma.video.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VideoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, VideoUpdateArgs<ExtArgs>>
    ): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Videos.
     * @param {VideoDeleteManyArgs} args - Arguments to filter Videos to delete.
     * @example
     * // Delete a few Videos
     * const { count } = await prisma.video.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VideoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VideoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos
     * const video = await prisma.video.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VideoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, VideoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Video.
     * @param {VideoUpsertArgs} args - Arguments to update or create a Video.
     * @example
     * // Update or create a Video
     * const video = await prisma.video.upsert({
     *   create: {
     *     // ... data to create a Video
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Video we want to update
     *   }
     * })
    **/
    upsert<T extends VideoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, VideoUpsertArgs<ExtArgs>>
    ): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCountArgs} args - Arguments to filter Videos to count.
     * @example
     * // Count the number of Videos
     * const count = await prisma.video.count({
     *   where: {
     *     // ... the filter for the Videos we want to count
     *   }
     * })
    **/
    count<T extends VideoCountArgs>(
      args?: Subset<T, VideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoAggregateArgs>(args: Subset<T, VideoAggregateArgs>): Prisma.PrismaPromise<GetVideoAggregateType<T>>

    /**
     * Group by Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoGroupByArgs['orderBy'] }
        : { orderBy?: VideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Video model
   */
  readonly fields: VideoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Video.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Video model
   */ 
  interface VideoFieldRefs {
    readonly id: FieldRef<"Video", 'String'>
    readonly userId: FieldRef<"Video", 'String'>
    readonly title: FieldRef<"Video", 'String'>
    readonly description: FieldRef<"Video", 'String'>
    readonly filename: FieldRef<"Video", 'String'>
    readonly fileUrl: FieldRef<"Video", 'String'>
    readonly thumbnailUrl: FieldRef<"Video", 'String'>
    readonly duration: FieldRef<"Video", 'Int'>
    readonly fileSize: FieldRef<"Video", 'Int'>
    readonly isMonetized: FieldRef<"Video", 'Boolean'>
    readonly viewCount: FieldRef<"Video", 'Int'>
    readonly earnings: FieldRef<"Video", 'Decimal'>
    readonly status: FieldRef<"Video", 'String'>
    readonly createdAt: FieldRef<"Video", 'DateTime'>
    readonly updatedAt: FieldRef<"Video", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Video findUnique
   */
  export type VideoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }


  /**
   * Video findUniqueOrThrow
   */
  export type VideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }


  /**
   * Video findFirst
   */
  export type VideoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }


  /**
   * Video findFirstOrThrow
   */
  export type VideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }


  /**
   * Video findMany
   */
  export type VideoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Videos to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }


  /**
   * Video create
   */
  export type VideoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The data needed to create a Video.
     */
    data: XOR<VideoCreateInput, VideoUncheckedCreateInput>
  }


  /**
   * Video createMany
   */
  export type VideoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Videos.
     */
    data: VideoCreateManyInput | VideoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Video update
   */
  export type VideoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The data needed to update a Video.
     */
    data: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
    /**
     * Choose, which Video to update.
     */
    where: VideoWhereUniqueInput
  }


  /**
   * Video updateMany
   */
  export type VideoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Videos.
     */
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyInput>
    /**
     * Filter which Videos to update
     */
    where?: VideoWhereInput
  }


  /**
   * Video upsert
   */
  export type VideoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The filter to search for the Video to update in case it exists.
     */
    where: VideoWhereUniqueInput
    /**
     * In case the Video found by the `where` argument doesn't exist, create a new Video with this data.
     */
    create: XOR<VideoCreateInput, VideoUncheckedCreateInput>
    /**
     * In case the Video was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
  }


  /**
   * Video delete
   */
  export type VideoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter which Video to delete.
     */
    where: VideoWhereUniqueInput
  }


  /**
   * Video deleteMany
   */
  export type VideoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Videos to delete
     */
    where?: VideoWhereInput
  }


  /**
   * Video without action
   */
  export type VideoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude<ExtArgs> | null
  }



  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  export type ApiKeyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    key: string | null
    lastUsedAt: Date | null
    expiresAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ApiKeyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    key: string | null
    lastUsedAt: Date | null
    expiresAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ApiKeyCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    key: number
    permissions: number
    lastUsedAt: number
    expiresAt: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type ApiKeyMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    key?: true
    lastUsedAt?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
  }

  export type ApiKeyMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    key?: true
    lastUsedAt?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
  }

  export type ApiKeyCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    key?: true
    permissions?: true
    lastUsedAt?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type ApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeys
    **/
    _count?: true | ApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyMaxAggregateInputType
  }

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>
  }




  export type ApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[]
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum
    having?: ApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyCountAggregateInputType | true
    _min?: ApiKeyMinAggregateInputType
    _max?: ApiKeyMaxAggregateInputType
  }

  export type ApiKeyGroupByOutputType = {
    id: string
    userId: string
    name: string
    key: string
    permissions: string[]
    lastUsedAt: Date | null
    expiresAt: Date | null
    isActive: boolean
    createdAt: Date
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    key?: boolean
    permissions?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    key?: boolean
    permissions?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKey"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      key: string
      permissions: string[]
      lastUsedAt: Date | null
      expiresAt: Date | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["apiKey"]>
    composites: {}
  }


  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyPayload, S>

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiKeyFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ApiKeyCountAggregateInputType | true
    }

  export interface ApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey'], meta: { name: 'ApiKey' } }
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ApiKeyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ApiKey that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ApiKeyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     * 
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ApiKeyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     * 
    **/
    create<T extends ApiKeyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ApiKeys.
     *     @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     *     @example
     *     // Create many ApiKeys
     *     const apiKey = await prisma.apiKey.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ApiKeyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     * 
    **/
    delete<T extends ApiKeyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ApiKeyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ApiKeyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ApiKeyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
    **/
    upsert<T extends ApiKeyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyAggregateArgs>(args: Subset<T, ApiKeyAggregateArgs>): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKey model
   */
  readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ApiKey model
   */ 
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<"ApiKey", 'String'>
    readonly userId: FieldRef<"ApiKey", 'String'>
    readonly name: FieldRef<"ApiKey", 'String'>
    readonly key: FieldRef<"ApiKey", 'String'>
    readonly permissions: FieldRef<"ApiKey", 'String[]'>
    readonly lastUsedAt: FieldRef<"ApiKey", 'DateTime'>
    readonly expiresAt: FieldRef<"ApiKey", 'DateTime'>
    readonly isActive: FieldRef<"ApiKey", 'Boolean'>
    readonly createdAt: FieldRef<"ApiKey", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }


  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }


  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }


  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }


  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }


  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKey.
     */
    data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
  }


  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKey.
     */
    data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    /**
     * Choose, which ApiKey to update.
     */
    where: ApiKeyWhereUniqueInput
  }


  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
  }


  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKey to update in case it exists.
     */
    where: ApiKeyWhereUniqueInput
    /**
     * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
     */
    create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    /**
     * In case the ApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
  }


  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter which ApiKey to delete.
     */
    where: ApiKeyWhereUniqueInput
  }


  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput
  }


  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
  }



  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _avg: ConversationAvgAggregateOutputType | null
    _sum: ConversationSumAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationAvgAggregateOutputType = {
    messageCount: number | null
    unreadCount: number | null
  }

  export type ConversationSumAggregateOutputType = {
    messageCount: number | null
    unreadCount: number | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    contactName: string | null
    contactEmail: string | null
    contactPhone: string | null
    contactId: string | null
    channel: string | null
    channelId: string | null
    subject: string | null
    status: string | null
    priority: string | null
    assignedTo: string | null
    messageCount: number | null
    unreadCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastMessageAt: Date | null
    closedAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    contactName: string | null
    contactEmail: string | null
    contactPhone: string | null
    contactId: string | null
    channel: string | null
    channelId: string | null
    subject: string | null
    status: string | null
    priority: string | null
    assignedTo: string | null
    messageCount: number | null
    unreadCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastMessageAt: Date | null
    closedAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    userId: number
    contactName: number
    contactEmail: number
    contactPhone: number
    contactId: number
    channel: number
    channelId: number
    subject: number
    status: number
    priority: number
    assignedTo: number
    tags: number
    labels: number
    messageCount: number
    unreadCount: number
    createdAt: number
    updatedAt: number
    lastMessageAt: number
    closedAt: number
    _all: number
  }


  export type ConversationAvgAggregateInputType = {
    messageCount?: true
    unreadCount?: true
  }

  export type ConversationSumAggregateInputType = {
    messageCount?: true
    unreadCount?: true
  }

  export type ConversationMinAggregateInputType = {
    id?: true
    userId?: true
    contactName?: true
    contactEmail?: true
    contactPhone?: true
    contactId?: true
    channel?: true
    channelId?: true
    subject?: true
    status?: true
    priority?: true
    assignedTo?: true
    messageCount?: true
    unreadCount?: true
    createdAt?: true
    updatedAt?: true
    lastMessageAt?: true
    closedAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    userId?: true
    contactName?: true
    contactEmail?: true
    contactPhone?: true
    contactId?: true
    channel?: true
    channelId?: true
    subject?: true
    status?: true
    priority?: true
    assignedTo?: true
    messageCount?: true
    unreadCount?: true
    createdAt?: true
    updatedAt?: true
    lastMessageAt?: true
    closedAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    userId?: true
    contactName?: true
    contactEmail?: true
    contactPhone?: true
    contactId?: true
    channel?: true
    channelId?: true
    subject?: true
    status?: true
    priority?: true
    assignedTo?: true
    tags?: true
    labels?: true
    messageCount?: true
    unreadCount?: true
    createdAt?: true
    updatedAt?: true
    lastMessageAt?: true
    closedAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _avg?: ConversationAvgAggregateInputType
    _sum?: ConversationSumAggregateInputType
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    userId: string
    contactName: string | null
    contactEmail: string | null
    contactPhone: string | null
    contactId: string | null
    channel: string
    channelId: string | null
    subject: string | null
    status: string
    priority: string
    assignedTo: string | null
    tags: string[]
    labels: string[]
    messageCount: number
    unreadCount: number
    createdAt: Date
    updatedAt: Date
    lastMessageAt: Date | null
    closedAt: Date | null
    _count: ConversationCountAggregateOutputType | null
    _avg: ConversationAvgAggregateOutputType | null
    _sum: ConversationSumAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    contactName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    contactId?: boolean
    channel?: boolean
    channelId?: boolean
    subject?: boolean
    status?: boolean
    priority?: boolean
    assignedTo?: boolean
    tags?: boolean
    labels?: boolean
    messageCount?: boolean
    unreadCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastMessageAt?: boolean
    closedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    notes?: boolean | Conversation$notesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    userId?: boolean
    contactName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    contactId?: boolean
    channel?: boolean
    channelId?: boolean
    subject?: boolean
    status?: boolean
    priority?: boolean
    assignedTo?: boolean
    tags?: boolean
    labels?: boolean
    messageCount?: boolean
    unreadCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastMessageAt?: boolean
    closedAt?: boolean
  }

  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    notes?: boolean | Conversation$notesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
      notes: Prisma.$ConversationNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      contactName: string | null
      contactEmail: string | null
      contactPhone: string | null
      contactId: string | null
      channel: string
      channelId: string | null
      subject: string | null
      status: string
      priority: string
      assignedTo: string | null
      tags: string[]
      labels: string[]
      messageCount: number
      unreadCount: number
      createdAt: Date
      updatedAt: Date
      lastMessageAt: Date | null
      closedAt: Date | null
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }


  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConversationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Conversation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConversationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConversationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
    **/
    create<T extends ConversationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Conversations.
     *     @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     *     @example
     *     // Create many Conversations
     *     const conversation = await prisma.conversation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConversationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
    **/
    delete<T extends ConversationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConversationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConversationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConversationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
    **/
    upsert<T extends ConversationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findMany'> | Null>;

    notes<T extends Conversation$notesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationNotePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Conversation model
   */ 
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly userId: FieldRef<"Conversation", 'String'>
    readonly contactName: FieldRef<"Conversation", 'String'>
    readonly contactEmail: FieldRef<"Conversation", 'String'>
    readonly contactPhone: FieldRef<"Conversation", 'String'>
    readonly contactId: FieldRef<"Conversation", 'String'>
    readonly channel: FieldRef<"Conversation", 'String'>
    readonly channelId: FieldRef<"Conversation", 'String'>
    readonly subject: FieldRef<"Conversation", 'String'>
    readonly status: FieldRef<"Conversation", 'String'>
    readonly priority: FieldRef<"Conversation", 'String'>
    readonly assignedTo: FieldRef<"Conversation", 'String'>
    readonly tags: FieldRef<"Conversation", 'String[]'>
    readonly labels: FieldRef<"Conversation", 'String[]'>
    readonly messageCount: FieldRef<"Conversation", 'Int'>
    readonly unreadCount: FieldRef<"Conversation", 'Int'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
    readonly lastMessageAt: FieldRef<"Conversation", 'DateTime'>
    readonly closedAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }


  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }


  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }


  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }


  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }


  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }


  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }


  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
  }


  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }


  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }


  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
  }


  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Conversation.notes
   */
  export type Conversation$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationNote
     */
    select?: ConversationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationNoteInclude<ExtArgs> | null
    where?: ConversationNoteWhereInput
    orderBy?: ConversationNoteOrderByWithRelationInput | ConversationNoteOrderByWithRelationInput[]
    cursor?: ConversationNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationNoteScalarFieldEnum | ConversationNoteScalarFieldEnum[]
  }


  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
  }



  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    userId: string | null
    content: string | null
    htmlContent: string | null
    subject: string | null
    channel: string | null
    channelMessageId: string | null
    direction: string | null
    status: string | null
    isRead: boolean | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    userId: string | null
    content: string | null
    htmlContent: string | null
    subject: string | null
    channel: string | null
    channelMessageId: string | null
    direction: string | null
    status: string | null
    isRead: boolean | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    userId: number
    content: number
    htmlContent: number
    subject: number
    channel: number
    channelMessageId: number
    direction: number
    status: number
    isRead: number
    attachments: number
    metadata: number
    createdAt: number
    readAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    content?: true
    htmlContent?: true
    subject?: true
    channel?: true
    channelMessageId?: true
    direction?: true
    status?: true
    isRead?: true
    createdAt?: true
    readAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    content?: true
    htmlContent?: true
    subject?: true
    channel?: true
    channelMessageId?: true
    direction?: true
    status?: true
    isRead?: true
    createdAt?: true
    readAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    content?: true
    htmlContent?: true
    subject?: true
    channel?: true
    channelMessageId?: true
    direction?: true
    status?: true
    isRead?: true
    attachments?: true
    metadata?: true
    createdAt?: true
    readAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    conversationId: string
    userId: string
    content: string
    htmlContent: string | null
    subject: string | null
    channel: string
    channelMessageId: string | null
    direction: string
    status: string
    isRead: boolean
    attachments: JsonValue | null
    metadata: JsonValue | null
    createdAt: Date
    readAt: Date | null
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    content?: boolean
    htmlContent?: boolean
    subject?: boolean
    channel?: boolean
    channelMessageId?: boolean
    direction?: boolean
    status?: boolean
    isRead?: boolean
    attachments?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    content?: boolean
    htmlContent?: boolean
    subject?: boolean
    channel?: boolean
    channelMessageId?: boolean
    direction?: boolean
    status?: boolean
    isRead?: boolean
    attachments?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      userId: string
      content: string
      htmlContent: string | null
      subject: string | null
      channel: string
      channelMessageId: string | null
      direction: string
      status: string
      isRead: boolean
      attachments: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      readAt: Date | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }


  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
    **/
    create<T extends MessageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageCreateArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Messages.
     *     @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     *     @example
     *     // Create many Messages
     *     const message = await prisma.message.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
    **/
    delete<T extends MessageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
    **/
    upsert<T extends MessageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly userId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly htmlContent: FieldRef<"Message", 'String'>
    readonly subject: FieldRef<"Message", 'String'>
    readonly channel: FieldRef<"Message", 'String'>
    readonly channelMessageId: FieldRef<"Message", 'String'>
    readonly direction: FieldRef<"Message", 'String'>
    readonly status: FieldRef<"Message", 'String'>
    readonly isRead: FieldRef<"Message", 'Boolean'>
    readonly attachments: FieldRef<"Message", 'Json'>
    readonly metadata: FieldRef<"Message", 'Json'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly readAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }


  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }


  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }


  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }


  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
  }



  /**
   * Model CannedResponse
   */

  export type AggregateCannedResponse = {
    _count: CannedResponseCountAggregateOutputType | null
    _avg: CannedResponseAvgAggregateOutputType | null
    _sum: CannedResponseSumAggregateOutputType | null
    _min: CannedResponseMinAggregateOutputType | null
    _max: CannedResponseMaxAggregateOutputType | null
  }

  export type CannedResponseAvgAggregateOutputType = {
    useCount: number | null
  }

  export type CannedResponseSumAggregateOutputType = {
    useCount: number | null
  }

  export type CannedResponseMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    content: string | null
    htmlContent: string | null
    subject: string | null
    category: string | null
    useCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CannedResponseMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    content: string | null
    htmlContent: string | null
    subject: string | null
    category: string | null
    useCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CannedResponseCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    content: number
    htmlContent: number
    subject: number
    category: number
    tags: number
    channels: number
    variables: number
    useCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CannedResponseAvgAggregateInputType = {
    useCount?: true
  }

  export type CannedResponseSumAggregateInputType = {
    useCount?: true
  }

  export type CannedResponseMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    content?: true
    htmlContent?: true
    subject?: true
    category?: true
    useCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CannedResponseMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    content?: true
    htmlContent?: true
    subject?: true
    category?: true
    useCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CannedResponseCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    content?: true
    htmlContent?: true
    subject?: true
    category?: true
    tags?: true
    channels?: true
    variables?: true
    useCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CannedResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CannedResponse to aggregate.
     */
    where?: CannedResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CannedResponses to fetch.
     */
    orderBy?: CannedResponseOrderByWithRelationInput | CannedResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CannedResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CannedResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CannedResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CannedResponses
    **/
    _count?: true | CannedResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CannedResponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CannedResponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CannedResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CannedResponseMaxAggregateInputType
  }

  export type GetCannedResponseAggregateType<T extends CannedResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateCannedResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCannedResponse[P]>
      : GetScalarType<T[P], AggregateCannedResponse[P]>
  }




  export type CannedResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CannedResponseWhereInput
    orderBy?: CannedResponseOrderByWithAggregationInput | CannedResponseOrderByWithAggregationInput[]
    by: CannedResponseScalarFieldEnum[] | CannedResponseScalarFieldEnum
    having?: CannedResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CannedResponseCountAggregateInputType | true
    _avg?: CannedResponseAvgAggregateInputType
    _sum?: CannedResponseSumAggregateInputType
    _min?: CannedResponseMinAggregateInputType
    _max?: CannedResponseMaxAggregateInputType
  }

  export type CannedResponseGroupByOutputType = {
    id: string
    userId: string
    name: string
    content: string
    htmlContent: string | null
    subject: string | null
    category: string | null
    tags: string[]
    channels: string[]
    variables: string[]
    useCount: number
    createdAt: Date
    updatedAt: Date
    _count: CannedResponseCountAggregateOutputType | null
    _avg: CannedResponseAvgAggregateOutputType | null
    _sum: CannedResponseSumAggregateOutputType | null
    _min: CannedResponseMinAggregateOutputType | null
    _max: CannedResponseMaxAggregateOutputType | null
  }

  type GetCannedResponseGroupByPayload<T extends CannedResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CannedResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CannedResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CannedResponseGroupByOutputType[P]>
            : GetScalarType<T[P], CannedResponseGroupByOutputType[P]>
        }
      >
    >


  export type CannedResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    content?: boolean
    htmlContent?: boolean
    subject?: boolean
    category?: boolean
    tags?: boolean
    channels?: boolean
    variables?: boolean
    useCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    AutoResponse?: boolean | CannedResponse$AutoResponseArgs<ExtArgs>
    _count?: boolean | CannedResponseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cannedResponse"]>

  export type CannedResponseSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    content?: boolean
    htmlContent?: boolean
    subject?: boolean
    category?: boolean
    tags?: boolean
    channels?: boolean
    variables?: boolean
    useCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CannedResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    AutoResponse?: boolean | CannedResponse$AutoResponseArgs<ExtArgs>
    _count?: boolean | CannedResponseCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CannedResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CannedResponse"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      AutoResponse: Prisma.$AutoResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      content: string
      htmlContent: string | null
      subject: string | null
      category: string | null
      tags: string[]
      channels: string[]
      variables: string[]
      useCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cannedResponse"]>
    composites: {}
  }


  type CannedResponseGetPayload<S extends boolean | null | undefined | CannedResponseDefaultArgs> = $Result.GetResult<Prisma.$CannedResponsePayload, S>

  type CannedResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CannedResponseFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CannedResponseCountAggregateInputType | true
    }

  export interface CannedResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CannedResponse'], meta: { name: 'CannedResponse' } }
    /**
     * Find zero or one CannedResponse that matches the filter.
     * @param {CannedResponseFindUniqueArgs} args - Arguments to find a CannedResponse
     * @example
     * // Get one CannedResponse
     * const cannedResponse = await prisma.cannedResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CannedResponseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CannedResponseFindUniqueArgs<ExtArgs>>
    ): Prisma__CannedResponseClient<$Result.GetResult<Prisma.$CannedResponsePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CannedResponse that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CannedResponseFindUniqueOrThrowArgs} args - Arguments to find a CannedResponse
     * @example
     * // Get one CannedResponse
     * const cannedResponse = await prisma.cannedResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CannedResponseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CannedResponseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CannedResponseClient<$Result.GetResult<Prisma.$CannedResponsePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CannedResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CannedResponseFindFirstArgs} args - Arguments to find a CannedResponse
     * @example
     * // Get one CannedResponse
     * const cannedResponse = await prisma.cannedResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CannedResponseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CannedResponseFindFirstArgs<ExtArgs>>
    ): Prisma__CannedResponseClient<$Result.GetResult<Prisma.$CannedResponsePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CannedResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CannedResponseFindFirstOrThrowArgs} args - Arguments to find a CannedResponse
     * @example
     * // Get one CannedResponse
     * const cannedResponse = await prisma.cannedResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CannedResponseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CannedResponseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CannedResponseClient<$Result.GetResult<Prisma.$CannedResponsePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CannedResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CannedResponseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CannedResponses
     * const cannedResponses = await prisma.cannedResponse.findMany()
     * 
     * // Get first 10 CannedResponses
     * const cannedResponses = await prisma.cannedResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cannedResponseWithIdOnly = await prisma.cannedResponse.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CannedResponseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CannedResponseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CannedResponsePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CannedResponse.
     * @param {CannedResponseCreateArgs} args - Arguments to create a CannedResponse.
     * @example
     * // Create one CannedResponse
     * const CannedResponse = await prisma.cannedResponse.create({
     *   data: {
     *     // ... data to create a CannedResponse
     *   }
     * })
     * 
    **/
    create<T extends CannedResponseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CannedResponseCreateArgs<ExtArgs>>
    ): Prisma__CannedResponseClient<$Result.GetResult<Prisma.$CannedResponsePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CannedResponses.
     *     @param {CannedResponseCreateManyArgs} args - Arguments to create many CannedResponses.
     *     @example
     *     // Create many CannedResponses
     *     const cannedResponse = await prisma.cannedResponse.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CannedResponseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CannedResponseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CannedResponse.
     * @param {CannedResponseDeleteArgs} args - Arguments to delete one CannedResponse.
     * @example
     * // Delete one CannedResponse
     * const CannedResponse = await prisma.cannedResponse.delete({
     *   where: {
     *     // ... filter to delete one CannedResponse
     *   }
     * })
     * 
    **/
    delete<T extends CannedResponseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CannedResponseDeleteArgs<ExtArgs>>
    ): Prisma__CannedResponseClient<$Result.GetResult<Prisma.$CannedResponsePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CannedResponse.
     * @param {CannedResponseUpdateArgs} args - Arguments to update one CannedResponse.
     * @example
     * // Update one CannedResponse
     * const cannedResponse = await prisma.cannedResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CannedResponseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CannedResponseUpdateArgs<ExtArgs>>
    ): Prisma__CannedResponseClient<$Result.GetResult<Prisma.$CannedResponsePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CannedResponses.
     * @param {CannedResponseDeleteManyArgs} args - Arguments to filter CannedResponses to delete.
     * @example
     * // Delete a few CannedResponses
     * const { count } = await prisma.cannedResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CannedResponseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CannedResponseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CannedResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CannedResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CannedResponses
     * const cannedResponse = await prisma.cannedResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CannedResponseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CannedResponseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CannedResponse.
     * @param {CannedResponseUpsertArgs} args - Arguments to update or create a CannedResponse.
     * @example
     * // Update or create a CannedResponse
     * const cannedResponse = await prisma.cannedResponse.upsert({
     *   create: {
     *     // ... data to create a CannedResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CannedResponse we want to update
     *   }
     * })
    **/
    upsert<T extends CannedResponseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CannedResponseUpsertArgs<ExtArgs>>
    ): Prisma__CannedResponseClient<$Result.GetResult<Prisma.$CannedResponsePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CannedResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CannedResponseCountArgs} args - Arguments to filter CannedResponses to count.
     * @example
     * // Count the number of CannedResponses
     * const count = await prisma.cannedResponse.count({
     *   where: {
     *     // ... the filter for the CannedResponses we want to count
     *   }
     * })
    **/
    count<T extends CannedResponseCountArgs>(
      args?: Subset<T, CannedResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CannedResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CannedResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CannedResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CannedResponseAggregateArgs>(args: Subset<T, CannedResponseAggregateArgs>): Prisma.PrismaPromise<GetCannedResponseAggregateType<T>>

    /**
     * Group by CannedResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CannedResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CannedResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CannedResponseGroupByArgs['orderBy'] }
        : { orderBy?: CannedResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CannedResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCannedResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CannedResponse model
   */
  readonly fields: CannedResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CannedResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CannedResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    AutoResponse<T extends CannedResponse$AutoResponseArgs<ExtArgs> = {}>(args?: Subset<T, CannedResponse$AutoResponseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoResponsePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CannedResponse model
   */ 
  interface CannedResponseFieldRefs {
    readonly id: FieldRef<"CannedResponse", 'String'>
    readonly userId: FieldRef<"CannedResponse", 'String'>
    readonly name: FieldRef<"CannedResponse", 'String'>
    readonly content: FieldRef<"CannedResponse", 'String'>
    readonly htmlContent: FieldRef<"CannedResponse", 'String'>
    readonly subject: FieldRef<"CannedResponse", 'String'>
    readonly category: FieldRef<"CannedResponse", 'String'>
    readonly tags: FieldRef<"CannedResponse", 'String[]'>
    readonly channels: FieldRef<"CannedResponse", 'String[]'>
    readonly variables: FieldRef<"CannedResponse", 'String[]'>
    readonly useCount: FieldRef<"CannedResponse", 'Int'>
    readonly createdAt: FieldRef<"CannedResponse", 'DateTime'>
    readonly updatedAt: FieldRef<"CannedResponse", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * CannedResponse findUnique
   */
  export type CannedResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CannedResponse
     */
    select?: CannedResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CannedResponseInclude<ExtArgs> | null
    /**
     * Filter, which CannedResponse to fetch.
     */
    where: CannedResponseWhereUniqueInput
  }


  /**
   * CannedResponse findUniqueOrThrow
   */
  export type CannedResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CannedResponse
     */
    select?: CannedResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CannedResponseInclude<ExtArgs> | null
    /**
     * Filter, which CannedResponse to fetch.
     */
    where: CannedResponseWhereUniqueInput
  }


  /**
   * CannedResponse findFirst
   */
  export type CannedResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CannedResponse
     */
    select?: CannedResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CannedResponseInclude<ExtArgs> | null
    /**
     * Filter, which CannedResponse to fetch.
     */
    where?: CannedResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CannedResponses to fetch.
     */
    orderBy?: CannedResponseOrderByWithRelationInput | CannedResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CannedResponses.
     */
    cursor?: CannedResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CannedResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CannedResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CannedResponses.
     */
    distinct?: CannedResponseScalarFieldEnum | CannedResponseScalarFieldEnum[]
  }


  /**
   * CannedResponse findFirstOrThrow
   */
  export type CannedResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CannedResponse
     */
    select?: CannedResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CannedResponseInclude<ExtArgs> | null
    /**
     * Filter, which CannedResponse to fetch.
     */
    where?: CannedResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CannedResponses to fetch.
     */
    orderBy?: CannedResponseOrderByWithRelationInput | CannedResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CannedResponses.
     */
    cursor?: CannedResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CannedResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CannedResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CannedResponses.
     */
    distinct?: CannedResponseScalarFieldEnum | CannedResponseScalarFieldEnum[]
  }


  /**
   * CannedResponse findMany
   */
  export type CannedResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CannedResponse
     */
    select?: CannedResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CannedResponseInclude<ExtArgs> | null
    /**
     * Filter, which CannedResponses to fetch.
     */
    where?: CannedResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CannedResponses to fetch.
     */
    orderBy?: CannedResponseOrderByWithRelationInput | CannedResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CannedResponses.
     */
    cursor?: CannedResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CannedResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CannedResponses.
     */
    skip?: number
    distinct?: CannedResponseScalarFieldEnum | CannedResponseScalarFieldEnum[]
  }


  /**
   * CannedResponse create
   */
  export type CannedResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CannedResponse
     */
    select?: CannedResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CannedResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a CannedResponse.
     */
    data: XOR<CannedResponseCreateInput, CannedResponseUncheckedCreateInput>
  }


  /**
   * CannedResponse createMany
   */
  export type CannedResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CannedResponses.
     */
    data: CannedResponseCreateManyInput | CannedResponseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CannedResponse update
   */
  export type CannedResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CannedResponse
     */
    select?: CannedResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CannedResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a CannedResponse.
     */
    data: XOR<CannedResponseUpdateInput, CannedResponseUncheckedUpdateInput>
    /**
     * Choose, which CannedResponse to update.
     */
    where: CannedResponseWhereUniqueInput
  }


  /**
   * CannedResponse updateMany
   */
  export type CannedResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CannedResponses.
     */
    data: XOR<CannedResponseUpdateManyMutationInput, CannedResponseUncheckedUpdateManyInput>
    /**
     * Filter which CannedResponses to update
     */
    where?: CannedResponseWhereInput
  }


  /**
   * CannedResponse upsert
   */
  export type CannedResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CannedResponse
     */
    select?: CannedResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CannedResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the CannedResponse to update in case it exists.
     */
    where: CannedResponseWhereUniqueInput
    /**
     * In case the CannedResponse found by the `where` argument doesn't exist, create a new CannedResponse with this data.
     */
    create: XOR<CannedResponseCreateInput, CannedResponseUncheckedCreateInput>
    /**
     * In case the CannedResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CannedResponseUpdateInput, CannedResponseUncheckedUpdateInput>
  }


  /**
   * CannedResponse delete
   */
  export type CannedResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CannedResponse
     */
    select?: CannedResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CannedResponseInclude<ExtArgs> | null
    /**
     * Filter which CannedResponse to delete.
     */
    where: CannedResponseWhereUniqueInput
  }


  /**
   * CannedResponse deleteMany
   */
  export type CannedResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CannedResponses to delete
     */
    where?: CannedResponseWhereInput
  }


  /**
   * CannedResponse.AutoResponse
   */
  export type CannedResponse$AutoResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoResponse
     */
    select?: AutoResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutoResponseInclude<ExtArgs> | null
    where?: AutoResponseWhereInput
    orderBy?: AutoResponseOrderByWithRelationInput | AutoResponseOrderByWithRelationInput[]
    cursor?: AutoResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutoResponseScalarFieldEnum | AutoResponseScalarFieldEnum[]
  }


  /**
   * CannedResponse without action
   */
  export type CannedResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CannedResponse
     */
    select?: CannedResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CannedResponseInclude<ExtArgs> | null
  }



  /**
   * Model AutoResponse
   */

  export type AggregateAutoResponse = {
    _count: AutoResponseCountAggregateOutputType | null
    _avg: AutoResponseAvgAggregateOutputType | null
    _sum: AutoResponseSumAggregateOutputType | null
    _min: AutoResponseMinAggregateOutputType | null
    _max: AutoResponseMaxAggregateOutputType | null
  }

  export type AutoResponseAvgAggregateOutputType = {
    priority: number | null
    delaySeconds: number | null
    maxPerDay: number | null
    maxPerContact: number | null
    triggerCount: number | null
  }

  export type AutoResponseSumAggregateOutputType = {
    priority: number | null
    delaySeconds: number | null
    maxPerDay: number | null
    maxPerContact: number | null
    triggerCount: number | null
  }

  export type AutoResponseMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    enabled: boolean | null
    triggerType: string | null
    cannedResponseId: string | null
    responseContent: string | null
    responseSubject: string | null
    priority: number | null
    delaySeconds: number | null
    maxPerDay: number | null
    maxPerContact: number | null
    triggerCount: number | null
    lastTriggeredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutoResponseMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    enabled: boolean | null
    triggerType: string | null
    cannedResponseId: string | null
    responseContent: string | null
    responseSubject: string | null
    priority: number | null
    delaySeconds: number | null
    maxPerDay: number | null
    maxPerContact: number | null
    triggerCount: number | null
    lastTriggeredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutoResponseCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    description: number
    enabled: number
    triggerType: number
    conditions: number
    cannedResponseId: number
    responseContent: number
    responseSubject: number
    channels: number
    priority: number
    delaySeconds: number
    maxPerDay: number
    maxPerContact: number
    triggerCount: number
    lastTriggeredAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AutoResponseAvgAggregateInputType = {
    priority?: true
    delaySeconds?: true
    maxPerDay?: true
    maxPerContact?: true
    triggerCount?: true
  }

  export type AutoResponseSumAggregateInputType = {
    priority?: true
    delaySeconds?: true
    maxPerDay?: true
    maxPerContact?: true
    triggerCount?: true
  }

  export type AutoResponseMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    enabled?: true
    triggerType?: true
    cannedResponseId?: true
    responseContent?: true
    responseSubject?: true
    priority?: true
    delaySeconds?: true
    maxPerDay?: true
    maxPerContact?: true
    triggerCount?: true
    lastTriggeredAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutoResponseMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    enabled?: true
    triggerType?: true
    cannedResponseId?: true
    responseContent?: true
    responseSubject?: true
    priority?: true
    delaySeconds?: true
    maxPerDay?: true
    maxPerContact?: true
    triggerCount?: true
    lastTriggeredAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutoResponseCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    enabled?: true
    triggerType?: true
    conditions?: true
    cannedResponseId?: true
    responseContent?: true
    responseSubject?: true
    channels?: true
    priority?: true
    delaySeconds?: true
    maxPerDay?: true
    maxPerContact?: true
    triggerCount?: true
    lastTriggeredAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AutoResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoResponse to aggregate.
     */
    where?: AutoResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoResponses to fetch.
     */
    orderBy?: AutoResponseOrderByWithRelationInput | AutoResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutoResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutoResponses
    **/
    _count?: true | AutoResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutoResponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutoResponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutoResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutoResponseMaxAggregateInputType
  }

  export type GetAutoResponseAggregateType<T extends AutoResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateAutoResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutoResponse[P]>
      : GetScalarType<T[P], AggregateAutoResponse[P]>
  }




  export type AutoResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoResponseWhereInput
    orderBy?: AutoResponseOrderByWithAggregationInput | AutoResponseOrderByWithAggregationInput[]
    by: AutoResponseScalarFieldEnum[] | AutoResponseScalarFieldEnum
    having?: AutoResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutoResponseCountAggregateInputType | true
    _avg?: AutoResponseAvgAggregateInputType
    _sum?: AutoResponseSumAggregateInputType
    _min?: AutoResponseMinAggregateInputType
    _max?: AutoResponseMaxAggregateInputType
  }

  export type AutoResponseGroupByOutputType = {
    id: string
    userId: string
    name: string
    description: string | null
    enabled: boolean
    triggerType: string
    conditions: JsonValue
    cannedResponseId: string | null
    responseContent: string | null
    responseSubject: string | null
    channels: string[]
    priority: number
    delaySeconds: number
    maxPerDay: number | null
    maxPerContact: number | null
    triggerCount: number
    lastTriggeredAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AutoResponseCountAggregateOutputType | null
    _avg: AutoResponseAvgAggregateOutputType | null
    _sum: AutoResponseSumAggregateOutputType | null
    _min: AutoResponseMinAggregateOutputType | null
    _max: AutoResponseMaxAggregateOutputType | null
  }

  type GetAutoResponseGroupByPayload<T extends AutoResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutoResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutoResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutoResponseGroupByOutputType[P]>
            : GetScalarType<T[P], AutoResponseGroupByOutputType[P]>
        }
      >
    >


  export type AutoResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    enabled?: boolean
    triggerType?: boolean
    conditions?: boolean
    cannedResponseId?: boolean
    responseContent?: boolean
    responseSubject?: boolean
    channels?: boolean
    priority?: boolean
    delaySeconds?: boolean
    maxPerDay?: boolean
    maxPerContact?: boolean
    triggerCount?: boolean
    lastTriggeredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    cannedResponse?: boolean | AutoResponse$cannedResponseArgs<ExtArgs>
  }, ExtArgs["result"]["autoResponse"]>

  export type AutoResponseSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    enabled?: boolean
    triggerType?: boolean
    conditions?: boolean
    cannedResponseId?: boolean
    responseContent?: boolean
    responseSubject?: boolean
    channels?: boolean
    priority?: boolean
    delaySeconds?: boolean
    maxPerDay?: boolean
    maxPerContact?: boolean
    triggerCount?: boolean
    lastTriggeredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AutoResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    cannedResponse?: boolean | AutoResponse$cannedResponseArgs<ExtArgs>
  }


  export type $AutoResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutoResponse"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      cannedResponse: Prisma.$CannedResponsePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      description: string | null
      enabled: boolean
      triggerType: string
      conditions: Prisma.JsonValue
      cannedResponseId: string | null
      responseContent: string | null
      responseSubject: string | null
      channels: string[]
      priority: number
      delaySeconds: number
      maxPerDay: number | null
      maxPerContact: number | null
      triggerCount: number
      lastTriggeredAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["autoResponse"]>
    composites: {}
  }


  type AutoResponseGetPayload<S extends boolean | null | undefined | AutoResponseDefaultArgs> = $Result.GetResult<Prisma.$AutoResponsePayload, S>

  type AutoResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AutoResponseFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AutoResponseCountAggregateInputType | true
    }

  export interface AutoResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutoResponse'], meta: { name: 'AutoResponse' } }
    /**
     * Find zero or one AutoResponse that matches the filter.
     * @param {AutoResponseFindUniqueArgs} args - Arguments to find a AutoResponse
     * @example
     * // Get one AutoResponse
     * const autoResponse = await prisma.autoResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AutoResponseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AutoResponseFindUniqueArgs<ExtArgs>>
    ): Prisma__AutoResponseClient<$Result.GetResult<Prisma.$AutoResponsePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AutoResponse that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AutoResponseFindUniqueOrThrowArgs} args - Arguments to find a AutoResponse
     * @example
     * // Get one AutoResponse
     * const autoResponse = await prisma.autoResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AutoResponseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AutoResponseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AutoResponseClient<$Result.GetResult<Prisma.$AutoResponsePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AutoResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoResponseFindFirstArgs} args - Arguments to find a AutoResponse
     * @example
     * // Get one AutoResponse
     * const autoResponse = await prisma.autoResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AutoResponseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AutoResponseFindFirstArgs<ExtArgs>>
    ): Prisma__AutoResponseClient<$Result.GetResult<Prisma.$AutoResponsePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AutoResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoResponseFindFirstOrThrowArgs} args - Arguments to find a AutoResponse
     * @example
     * // Get one AutoResponse
     * const autoResponse = await prisma.autoResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AutoResponseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AutoResponseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AutoResponseClient<$Result.GetResult<Prisma.$AutoResponsePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AutoResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoResponseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutoResponses
     * const autoResponses = await prisma.autoResponse.findMany()
     * 
     * // Get first 10 AutoResponses
     * const autoResponses = await prisma.autoResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const autoResponseWithIdOnly = await prisma.autoResponse.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AutoResponseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AutoResponseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoResponsePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AutoResponse.
     * @param {AutoResponseCreateArgs} args - Arguments to create a AutoResponse.
     * @example
     * // Create one AutoResponse
     * const AutoResponse = await prisma.autoResponse.create({
     *   data: {
     *     // ... data to create a AutoResponse
     *   }
     * })
     * 
    **/
    create<T extends AutoResponseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AutoResponseCreateArgs<ExtArgs>>
    ): Prisma__AutoResponseClient<$Result.GetResult<Prisma.$AutoResponsePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AutoResponses.
     *     @param {AutoResponseCreateManyArgs} args - Arguments to create many AutoResponses.
     *     @example
     *     // Create many AutoResponses
     *     const autoResponse = await prisma.autoResponse.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AutoResponseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AutoResponseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AutoResponse.
     * @param {AutoResponseDeleteArgs} args - Arguments to delete one AutoResponse.
     * @example
     * // Delete one AutoResponse
     * const AutoResponse = await prisma.autoResponse.delete({
     *   where: {
     *     // ... filter to delete one AutoResponse
     *   }
     * })
     * 
    **/
    delete<T extends AutoResponseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AutoResponseDeleteArgs<ExtArgs>>
    ): Prisma__AutoResponseClient<$Result.GetResult<Prisma.$AutoResponsePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AutoResponse.
     * @param {AutoResponseUpdateArgs} args - Arguments to update one AutoResponse.
     * @example
     * // Update one AutoResponse
     * const autoResponse = await prisma.autoResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AutoResponseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AutoResponseUpdateArgs<ExtArgs>>
    ): Prisma__AutoResponseClient<$Result.GetResult<Prisma.$AutoResponsePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AutoResponses.
     * @param {AutoResponseDeleteManyArgs} args - Arguments to filter AutoResponses to delete.
     * @example
     * // Delete a few AutoResponses
     * const { count } = await prisma.autoResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AutoResponseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AutoResponseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutoResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutoResponses
     * const autoResponse = await prisma.autoResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AutoResponseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AutoResponseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AutoResponse.
     * @param {AutoResponseUpsertArgs} args - Arguments to update or create a AutoResponse.
     * @example
     * // Update or create a AutoResponse
     * const autoResponse = await prisma.autoResponse.upsert({
     *   create: {
     *     // ... data to create a AutoResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutoResponse we want to update
     *   }
     * })
    **/
    upsert<T extends AutoResponseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AutoResponseUpsertArgs<ExtArgs>>
    ): Prisma__AutoResponseClient<$Result.GetResult<Prisma.$AutoResponsePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AutoResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoResponseCountArgs} args - Arguments to filter AutoResponses to count.
     * @example
     * // Count the number of AutoResponses
     * const count = await prisma.autoResponse.count({
     *   where: {
     *     // ... the filter for the AutoResponses we want to count
     *   }
     * })
    **/
    count<T extends AutoResponseCountArgs>(
      args?: Subset<T, AutoResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutoResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutoResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutoResponseAggregateArgs>(args: Subset<T, AutoResponseAggregateArgs>): Prisma.PrismaPromise<GetAutoResponseAggregateType<T>>

    /**
     * Group by AutoResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutoResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutoResponseGroupByArgs['orderBy'] }
        : { orderBy?: AutoResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutoResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutoResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutoResponse model
   */
  readonly fields: AutoResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutoResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutoResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    cannedResponse<T extends AutoResponse$cannedResponseArgs<ExtArgs> = {}>(args?: Subset<T, AutoResponse$cannedResponseArgs<ExtArgs>>): Prisma__CannedResponseClient<$Result.GetResult<Prisma.$CannedResponsePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AutoResponse model
   */ 
  interface AutoResponseFieldRefs {
    readonly id: FieldRef<"AutoResponse", 'String'>
    readonly userId: FieldRef<"AutoResponse", 'String'>
    readonly name: FieldRef<"AutoResponse", 'String'>
    readonly description: FieldRef<"AutoResponse", 'String'>
    readonly enabled: FieldRef<"AutoResponse", 'Boolean'>
    readonly triggerType: FieldRef<"AutoResponse", 'String'>
    readonly conditions: FieldRef<"AutoResponse", 'Json'>
    readonly cannedResponseId: FieldRef<"AutoResponse", 'String'>
    readonly responseContent: FieldRef<"AutoResponse", 'String'>
    readonly responseSubject: FieldRef<"AutoResponse", 'String'>
    readonly channels: FieldRef<"AutoResponse", 'String[]'>
    readonly priority: FieldRef<"AutoResponse", 'Int'>
    readonly delaySeconds: FieldRef<"AutoResponse", 'Int'>
    readonly maxPerDay: FieldRef<"AutoResponse", 'Int'>
    readonly maxPerContact: FieldRef<"AutoResponse", 'Int'>
    readonly triggerCount: FieldRef<"AutoResponse", 'Int'>
    readonly lastTriggeredAt: FieldRef<"AutoResponse", 'DateTime'>
    readonly createdAt: FieldRef<"AutoResponse", 'DateTime'>
    readonly updatedAt: FieldRef<"AutoResponse", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * AutoResponse findUnique
   */
  export type AutoResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoResponse
     */
    select?: AutoResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutoResponseInclude<ExtArgs> | null
    /**
     * Filter, which AutoResponse to fetch.
     */
    where: AutoResponseWhereUniqueInput
  }


  /**
   * AutoResponse findUniqueOrThrow
   */
  export type AutoResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoResponse
     */
    select?: AutoResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutoResponseInclude<ExtArgs> | null
    /**
     * Filter, which AutoResponse to fetch.
     */
    where: AutoResponseWhereUniqueInput
  }


  /**
   * AutoResponse findFirst
   */
  export type AutoResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoResponse
     */
    select?: AutoResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutoResponseInclude<ExtArgs> | null
    /**
     * Filter, which AutoResponse to fetch.
     */
    where?: AutoResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoResponses to fetch.
     */
    orderBy?: AutoResponseOrderByWithRelationInput | AutoResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoResponses.
     */
    cursor?: AutoResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoResponses.
     */
    distinct?: AutoResponseScalarFieldEnum | AutoResponseScalarFieldEnum[]
  }


  /**
   * AutoResponse findFirstOrThrow
   */
  export type AutoResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoResponse
     */
    select?: AutoResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutoResponseInclude<ExtArgs> | null
    /**
     * Filter, which AutoResponse to fetch.
     */
    where?: AutoResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoResponses to fetch.
     */
    orderBy?: AutoResponseOrderByWithRelationInput | AutoResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoResponses.
     */
    cursor?: AutoResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoResponses.
     */
    distinct?: AutoResponseScalarFieldEnum | AutoResponseScalarFieldEnum[]
  }


  /**
   * AutoResponse findMany
   */
  export type AutoResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoResponse
     */
    select?: AutoResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutoResponseInclude<ExtArgs> | null
    /**
     * Filter, which AutoResponses to fetch.
     */
    where?: AutoResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoResponses to fetch.
     */
    orderBy?: AutoResponseOrderByWithRelationInput | AutoResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutoResponses.
     */
    cursor?: AutoResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoResponses.
     */
    skip?: number
    distinct?: AutoResponseScalarFieldEnum | AutoResponseScalarFieldEnum[]
  }


  /**
   * AutoResponse create
   */
  export type AutoResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoResponse
     */
    select?: AutoResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutoResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a AutoResponse.
     */
    data: XOR<AutoResponseCreateInput, AutoResponseUncheckedCreateInput>
  }


  /**
   * AutoResponse createMany
   */
  export type AutoResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutoResponses.
     */
    data: AutoResponseCreateManyInput | AutoResponseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AutoResponse update
   */
  export type AutoResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoResponse
     */
    select?: AutoResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutoResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a AutoResponse.
     */
    data: XOR<AutoResponseUpdateInput, AutoResponseUncheckedUpdateInput>
    /**
     * Choose, which AutoResponse to update.
     */
    where: AutoResponseWhereUniqueInput
  }


  /**
   * AutoResponse updateMany
   */
  export type AutoResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutoResponses.
     */
    data: XOR<AutoResponseUpdateManyMutationInput, AutoResponseUncheckedUpdateManyInput>
    /**
     * Filter which AutoResponses to update
     */
    where?: AutoResponseWhereInput
  }


  /**
   * AutoResponse upsert
   */
  export type AutoResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoResponse
     */
    select?: AutoResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutoResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the AutoResponse to update in case it exists.
     */
    where: AutoResponseWhereUniqueInput
    /**
     * In case the AutoResponse found by the `where` argument doesn't exist, create a new AutoResponse with this data.
     */
    create: XOR<AutoResponseCreateInput, AutoResponseUncheckedCreateInput>
    /**
     * In case the AutoResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutoResponseUpdateInput, AutoResponseUncheckedUpdateInput>
  }


  /**
   * AutoResponse delete
   */
  export type AutoResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoResponse
     */
    select?: AutoResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutoResponseInclude<ExtArgs> | null
    /**
     * Filter which AutoResponse to delete.
     */
    where: AutoResponseWhereUniqueInput
  }


  /**
   * AutoResponse deleteMany
   */
  export type AutoResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoResponses to delete
     */
    where?: AutoResponseWhereInput
  }


  /**
   * AutoResponse.cannedResponse
   */
  export type AutoResponse$cannedResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CannedResponse
     */
    select?: CannedResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CannedResponseInclude<ExtArgs> | null
    where?: CannedResponseWhereInput
  }


  /**
   * AutoResponse without action
   */
  export type AutoResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoResponse
     */
    select?: AutoResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutoResponseInclude<ExtArgs> | null
  }



  /**
   * Model ConversationNote
   */

  export type AggregateConversationNote = {
    _count: ConversationNoteCountAggregateOutputType | null
    _min: ConversationNoteMinAggregateOutputType | null
    _max: ConversationNoteMaxAggregateOutputType | null
  }

  export type ConversationNoteMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    userId: string | null
    content: string | null
    isInternal: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationNoteMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    userId: string | null
    content: string | null
    isInternal: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationNoteCountAggregateOutputType = {
    id: number
    conversationId: number
    userId: number
    content: number
    isInternal: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationNoteMinAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    content?: true
    isInternal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationNoteMaxAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    content?: true
    isInternal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationNoteCountAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    content?: true
    isInternal?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationNote to aggregate.
     */
    where?: ConversationNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationNotes to fetch.
     */
    orderBy?: ConversationNoteOrderByWithRelationInput | ConversationNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationNotes
    **/
    _count?: true | ConversationNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationNoteMaxAggregateInputType
  }

  export type GetConversationNoteAggregateType<T extends ConversationNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationNote[P]>
      : GetScalarType<T[P], AggregateConversationNote[P]>
  }




  export type ConversationNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationNoteWhereInput
    orderBy?: ConversationNoteOrderByWithAggregationInput | ConversationNoteOrderByWithAggregationInput[]
    by: ConversationNoteScalarFieldEnum[] | ConversationNoteScalarFieldEnum
    having?: ConversationNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationNoteCountAggregateInputType | true
    _min?: ConversationNoteMinAggregateInputType
    _max?: ConversationNoteMaxAggregateInputType
  }

  export type ConversationNoteGroupByOutputType = {
    id: string
    conversationId: string
    userId: string
    content: string
    isInternal: boolean
    createdAt: Date
    updatedAt: Date
    _count: ConversationNoteCountAggregateOutputType | null
    _min: ConversationNoteMinAggregateOutputType | null
    _max: ConversationNoteMaxAggregateOutputType | null
  }

  type GetConversationNoteGroupByPayload<T extends ConversationNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationNoteGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationNoteGroupByOutputType[P]>
        }
      >
    >


  export type ConversationNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    content?: boolean
    isInternal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationNote"]>

  export type ConversationNoteSelectScalar = {
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    content?: boolean
    isInternal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConversationNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $ConversationNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversationNote"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      userId: string
      content: string
      isInternal: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conversationNote"]>
    composites: {}
  }


  type ConversationNoteGetPayload<S extends boolean | null | undefined | ConversationNoteDefaultArgs> = $Result.GetResult<Prisma.$ConversationNotePayload, S>

  type ConversationNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConversationNoteFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ConversationNoteCountAggregateInputType | true
    }

  export interface ConversationNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationNote'], meta: { name: 'ConversationNote' } }
    /**
     * Find zero or one ConversationNote that matches the filter.
     * @param {ConversationNoteFindUniqueArgs} args - Arguments to find a ConversationNote
     * @example
     * // Get one ConversationNote
     * const conversationNote = await prisma.conversationNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConversationNoteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationNoteFindUniqueArgs<ExtArgs>>
    ): Prisma__ConversationNoteClient<$Result.GetResult<Prisma.$ConversationNotePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ConversationNote that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConversationNoteFindUniqueOrThrowArgs} args - Arguments to find a ConversationNote
     * @example
     * // Get one ConversationNote
     * const conversationNote = await prisma.conversationNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConversationNoteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationNoteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConversationNoteClient<$Result.GetResult<Prisma.$ConversationNotePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ConversationNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationNoteFindFirstArgs} args - Arguments to find a ConversationNote
     * @example
     * // Get one ConversationNote
     * const conversationNote = await prisma.conversationNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConversationNoteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationNoteFindFirstArgs<ExtArgs>>
    ): Prisma__ConversationNoteClient<$Result.GetResult<Prisma.$ConversationNotePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ConversationNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationNoteFindFirstOrThrowArgs} args - Arguments to find a ConversationNote
     * @example
     * // Get one ConversationNote
     * const conversationNote = await prisma.conversationNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConversationNoteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationNoteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConversationNoteClient<$Result.GetResult<Prisma.$ConversationNotePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ConversationNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationNoteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationNotes
     * const conversationNotes = await prisma.conversationNote.findMany()
     * 
     * // Get first 10 ConversationNotes
     * const conversationNotes = await prisma.conversationNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationNoteWithIdOnly = await prisma.conversationNote.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConversationNoteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationNoteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationNotePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ConversationNote.
     * @param {ConversationNoteCreateArgs} args - Arguments to create a ConversationNote.
     * @example
     * // Create one ConversationNote
     * const ConversationNote = await prisma.conversationNote.create({
     *   data: {
     *     // ... data to create a ConversationNote
     *   }
     * })
     * 
    **/
    create<T extends ConversationNoteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationNoteCreateArgs<ExtArgs>>
    ): Prisma__ConversationNoteClient<$Result.GetResult<Prisma.$ConversationNotePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ConversationNotes.
     *     @param {ConversationNoteCreateManyArgs} args - Arguments to create many ConversationNotes.
     *     @example
     *     // Create many ConversationNotes
     *     const conversationNote = await prisma.conversationNote.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConversationNoteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationNoteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConversationNote.
     * @param {ConversationNoteDeleteArgs} args - Arguments to delete one ConversationNote.
     * @example
     * // Delete one ConversationNote
     * const ConversationNote = await prisma.conversationNote.delete({
     *   where: {
     *     // ... filter to delete one ConversationNote
     *   }
     * })
     * 
    **/
    delete<T extends ConversationNoteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationNoteDeleteArgs<ExtArgs>>
    ): Prisma__ConversationNoteClient<$Result.GetResult<Prisma.$ConversationNotePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ConversationNote.
     * @param {ConversationNoteUpdateArgs} args - Arguments to update one ConversationNote.
     * @example
     * // Update one ConversationNote
     * const conversationNote = await prisma.conversationNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConversationNoteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationNoteUpdateArgs<ExtArgs>>
    ): Prisma__ConversationNoteClient<$Result.GetResult<Prisma.$ConversationNotePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ConversationNotes.
     * @param {ConversationNoteDeleteManyArgs} args - Arguments to filter ConversationNotes to delete.
     * @example
     * // Delete a few ConversationNotes
     * const { count } = await prisma.conversationNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConversationNoteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationNoteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationNotes
     * const conversationNote = await prisma.conversationNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConversationNoteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationNoteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConversationNote.
     * @param {ConversationNoteUpsertArgs} args - Arguments to update or create a ConversationNote.
     * @example
     * // Update or create a ConversationNote
     * const conversationNote = await prisma.conversationNote.upsert({
     *   create: {
     *     // ... data to create a ConversationNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationNote we want to update
     *   }
     * })
    **/
    upsert<T extends ConversationNoteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationNoteUpsertArgs<ExtArgs>>
    ): Prisma__ConversationNoteClient<$Result.GetResult<Prisma.$ConversationNotePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ConversationNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationNoteCountArgs} args - Arguments to filter ConversationNotes to count.
     * @example
     * // Count the number of ConversationNotes
     * const count = await prisma.conversationNote.count({
     *   where: {
     *     // ... the filter for the ConversationNotes we want to count
     *   }
     * })
    **/
    count<T extends ConversationNoteCountArgs>(
      args?: Subset<T, ConversationNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationNoteAggregateArgs>(args: Subset<T, ConversationNoteAggregateArgs>): Prisma.PrismaPromise<GetConversationNoteAggregateType<T>>

    /**
     * Group by ConversationNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationNoteGroupByArgs['orderBy'] }
        : { orderBy?: ConversationNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationNote model
   */
  readonly fields: ConversationNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ConversationNote model
   */ 
  interface ConversationNoteFieldRefs {
    readonly id: FieldRef<"ConversationNote", 'String'>
    readonly conversationId: FieldRef<"ConversationNote", 'String'>
    readonly userId: FieldRef<"ConversationNote", 'String'>
    readonly content: FieldRef<"ConversationNote", 'String'>
    readonly isInternal: FieldRef<"ConversationNote", 'Boolean'>
    readonly createdAt: FieldRef<"ConversationNote", 'DateTime'>
    readonly updatedAt: FieldRef<"ConversationNote", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ConversationNote findUnique
   */
  export type ConversationNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationNote
     */
    select?: ConversationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationNoteInclude<ExtArgs> | null
    /**
     * Filter, which ConversationNote to fetch.
     */
    where: ConversationNoteWhereUniqueInput
  }


  /**
   * ConversationNote findUniqueOrThrow
   */
  export type ConversationNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationNote
     */
    select?: ConversationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationNoteInclude<ExtArgs> | null
    /**
     * Filter, which ConversationNote to fetch.
     */
    where: ConversationNoteWhereUniqueInput
  }


  /**
   * ConversationNote findFirst
   */
  export type ConversationNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationNote
     */
    select?: ConversationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationNoteInclude<ExtArgs> | null
    /**
     * Filter, which ConversationNote to fetch.
     */
    where?: ConversationNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationNotes to fetch.
     */
    orderBy?: ConversationNoteOrderByWithRelationInput | ConversationNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationNotes.
     */
    cursor?: ConversationNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationNotes.
     */
    distinct?: ConversationNoteScalarFieldEnum | ConversationNoteScalarFieldEnum[]
  }


  /**
   * ConversationNote findFirstOrThrow
   */
  export type ConversationNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationNote
     */
    select?: ConversationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationNoteInclude<ExtArgs> | null
    /**
     * Filter, which ConversationNote to fetch.
     */
    where?: ConversationNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationNotes to fetch.
     */
    orderBy?: ConversationNoteOrderByWithRelationInput | ConversationNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationNotes.
     */
    cursor?: ConversationNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationNotes.
     */
    distinct?: ConversationNoteScalarFieldEnum | ConversationNoteScalarFieldEnum[]
  }


  /**
   * ConversationNote findMany
   */
  export type ConversationNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationNote
     */
    select?: ConversationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationNoteInclude<ExtArgs> | null
    /**
     * Filter, which ConversationNotes to fetch.
     */
    where?: ConversationNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationNotes to fetch.
     */
    orderBy?: ConversationNoteOrderByWithRelationInput | ConversationNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationNotes.
     */
    cursor?: ConversationNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationNotes.
     */
    skip?: number
    distinct?: ConversationNoteScalarFieldEnum | ConversationNoteScalarFieldEnum[]
  }


  /**
   * ConversationNote create
   */
  export type ConversationNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationNote
     */
    select?: ConversationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a ConversationNote.
     */
    data: XOR<ConversationNoteCreateInput, ConversationNoteUncheckedCreateInput>
  }


  /**
   * ConversationNote createMany
   */
  export type ConversationNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationNotes.
     */
    data: ConversationNoteCreateManyInput | ConversationNoteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ConversationNote update
   */
  export type ConversationNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationNote
     */
    select?: ConversationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a ConversationNote.
     */
    data: XOR<ConversationNoteUpdateInput, ConversationNoteUncheckedUpdateInput>
    /**
     * Choose, which ConversationNote to update.
     */
    where: ConversationNoteWhereUniqueInput
  }


  /**
   * ConversationNote updateMany
   */
  export type ConversationNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationNotes.
     */
    data: XOR<ConversationNoteUpdateManyMutationInput, ConversationNoteUncheckedUpdateManyInput>
    /**
     * Filter which ConversationNotes to update
     */
    where?: ConversationNoteWhereInput
  }


  /**
   * ConversationNote upsert
   */
  export type ConversationNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationNote
     */
    select?: ConversationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the ConversationNote to update in case it exists.
     */
    where: ConversationNoteWhereUniqueInput
    /**
     * In case the ConversationNote found by the `where` argument doesn't exist, create a new ConversationNote with this data.
     */
    create: XOR<ConversationNoteCreateInput, ConversationNoteUncheckedCreateInput>
    /**
     * In case the ConversationNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationNoteUpdateInput, ConversationNoteUncheckedUpdateInput>
  }


  /**
   * ConversationNote delete
   */
  export type ConversationNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationNote
     */
    select?: ConversationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationNoteInclude<ExtArgs> | null
    /**
     * Filter which ConversationNote to delete.
     */
    where: ConversationNoteWhereUniqueInput
  }


  /**
   * ConversationNote deleteMany
   */
  export type ConversationNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationNotes to delete
     */
    where?: ConversationNoteWhereInput
  }


  /**
   * ConversationNote without action
   */
  export type ConversationNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationNote
     */
    select?: ConversationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationNoteInclude<ExtArgs> | null
  }



  /**
   * Model SystemHealthMetric
   */

  export type AggregateSystemHealthMetric = {
    _count: SystemHealthMetricCountAggregateOutputType | null
    _avg: SystemHealthMetricAvgAggregateOutputType | null
    _sum: SystemHealthMetricSumAggregateOutputType | null
    _min: SystemHealthMetricMinAggregateOutputType | null
    _max: SystemHealthMetricMaxAggregateOutputType | null
  }

  export type SystemHealthMetricAvgAggregateOutputType = {
    metricValue: Decimal | null
  }

  export type SystemHealthMetricSumAggregateOutputType = {
    metricValue: Decimal | null
  }

  export type SystemHealthMetricMinAggregateOutputType = {
    id: string | null
    metricName: string | null
    metricValue: Decimal | null
    metricUnit: string | null
    component: string | null
    severity: string | null
    createdAt: Date | null
  }

  export type SystemHealthMetricMaxAggregateOutputType = {
    id: string | null
    metricName: string | null
    metricValue: Decimal | null
    metricUnit: string | null
    component: string | null
    severity: string | null
    createdAt: Date | null
  }

  export type SystemHealthMetricCountAggregateOutputType = {
    id: number
    metricName: number
    metricValue: number
    metricUnit: number
    component: number
    severity: number
    createdAt: number
    _all: number
  }


  export type SystemHealthMetricAvgAggregateInputType = {
    metricValue?: true
  }

  export type SystemHealthMetricSumAggregateInputType = {
    metricValue?: true
  }

  export type SystemHealthMetricMinAggregateInputType = {
    id?: true
    metricName?: true
    metricValue?: true
    metricUnit?: true
    component?: true
    severity?: true
    createdAt?: true
  }

  export type SystemHealthMetricMaxAggregateInputType = {
    id?: true
    metricName?: true
    metricValue?: true
    metricUnit?: true
    component?: true
    severity?: true
    createdAt?: true
  }

  export type SystemHealthMetricCountAggregateInputType = {
    id?: true
    metricName?: true
    metricValue?: true
    metricUnit?: true
    component?: true
    severity?: true
    createdAt?: true
    _all?: true
  }

  export type SystemHealthMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemHealthMetric to aggregate.
     */
    where?: SystemHealthMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemHealthMetrics to fetch.
     */
    orderBy?: SystemHealthMetricOrderByWithRelationInput | SystemHealthMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemHealthMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemHealthMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemHealthMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemHealthMetrics
    **/
    _count?: true | SystemHealthMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemHealthMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemHealthMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemHealthMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemHealthMetricMaxAggregateInputType
  }

  export type GetSystemHealthMetricAggregateType<T extends SystemHealthMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemHealthMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemHealthMetric[P]>
      : GetScalarType<T[P], AggregateSystemHealthMetric[P]>
  }




  export type SystemHealthMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemHealthMetricWhereInput
    orderBy?: SystemHealthMetricOrderByWithAggregationInput | SystemHealthMetricOrderByWithAggregationInput[]
    by: SystemHealthMetricScalarFieldEnum[] | SystemHealthMetricScalarFieldEnum
    having?: SystemHealthMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemHealthMetricCountAggregateInputType | true
    _avg?: SystemHealthMetricAvgAggregateInputType
    _sum?: SystemHealthMetricSumAggregateInputType
    _min?: SystemHealthMetricMinAggregateInputType
    _max?: SystemHealthMetricMaxAggregateInputType
  }

  export type SystemHealthMetricGroupByOutputType = {
    id: string
    metricName: string
    metricValue: Decimal
    metricUnit: string | null
    component: string
    severity: string
    createdAt: Date
    _count: SystemHealthMetricCountAggregateOutputType | null
    _avg: SystemHealthMetricAvgAggregateOutputType | null
    _sum: SystemHealthMetricSumAggregateOutputType | null
    _min: SystemHealthMetricMinAggregateOutputType | null
    _max: SystemHealthMetricMaxAggregateOutputType | null
  }

  type GetSystemHealthMetricGroupByPayload<T extends SystemHealthMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemHealthMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemHealthMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemHealthMetricGroupByOutputType[P]>
            : GetScalarType<T[P], SystemHealthMetricGroupByOutputType[P]>
        }
      >
    >


  export type SystemHealthMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metricName?: boolean
    metricValue?: boolean
    metricUnit?: boolean
    component?: boolean
    severity?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["systemHealthMetric"]>

  export type SystemHealthMetricSelectScalar = {
    id?: boolean
    metricName?: boolean
    metricValue?: boolean
    metricUnit?: boolean
    component?: boolean
    severity?: boolean
    createdAt?: boolean
  }


  export type $SystemHealthMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemHealthMetric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      metricName: string
      metricValue: Prisma.Decimal
      metricUnit: string | null
      component: string
      severity: string
      createdAt: Date
    }, ExtArgs["result"]["systemHealthMetric"]>
    composites: {}
  }


  type SystemHealthMetricGetPayload<S extends boolean | null | undefined | SystemHealthMetricDefaultArgs> = $Result.GetResult<Prisma.$SystemHealthMetricPayload, S>

  type SystemHealthMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemHealthMetricFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SystemHealthMetricCountAggregateInputType | true
    }

  export interface SystemHealthMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemHealthMetric'], meta: { name: 'SystemHealthMetric' } }
    /**
     * Find zero or one SystemHealthMetric that matches the filter.
     * @param {SystemHealthMetricFindUniqueArgs} args - Arguments to find a SystemHealthMetric
     * @example
     * // Get one SystemHealthMetric
     * const systemHealthMetric = await prisma.systemHealthMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SystemHealthMetricFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SystemHealthMetricFindUniqueArgs<ExtArgs>>
    ): Prisma__SystemHealthMetricClient<$Result.GetResult<Prisma.$SystemHealthMetricPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SystemHealthMetric that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SystemHealthMetricFindUniqueOrThrowArgs} args - Arguments to find a SystemHealthMetric
     * @example
     * // Get one SystemHealthMetric
     * const systemHealthMetric = await prisma.systemHealthMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SystemHealthMetricFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemHealthMetricFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SystemHealthMetricClient<$Result.GetResult<Prisma.$SystemHealthMetricPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SystemHealthMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthMetricFindFirstArgs} args - Arguments to find a SystemHealthMetric
     * @example
     * // Get one SystemHealthMetric
     * const systemHealthMetric = await prisma.systemHealthMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SystemHealthMetricFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemHealthMetricFindFirstArgs<ExtArgs>>
    ): Prisma__SystemHealthMetricClient<$Result.GetResult<Prisma.$SystemHealthMetricPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SystemHealthMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthMetricFindFirstOrThrowArgs} args - Arguments to find a SystemHealthMetric
     * @example
     * // Get one SystemHealthMetric
     * const systemHealthMetric = await prisma.systemHealthMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SystemHealthMetricFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemHealthMetricFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SystemHealthMetricClient<$Result.GetResult<Prisma.$SystemHealthMetricPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SystemHealthMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthMetricFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemHealthMetrics
     * const systemHealthMetrics = await prisma.systemHealthMetric.findMany()
     * 
     * // Get first 10 SystemHealthMetrics
     * const systemHealthMetrics = await prisma.systemHealthMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemHealthMetricWithIdOnly = await prisma.systemHealthMetric.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SystemHealthMetricFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemHealthMetricFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemHealthMetricPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SystemHealthMetric.
     * @param {SystemHealthMetricCreateArgs} args - Arguments to create a SystemHealthMetric.
     * @example
     * // Create one SystemHealthMetric
     * const SystemHealthMetric = await prisma.systemHealthMetric.create({
     *   data: {
     *     // ... data to create a SystemHealthMetric
     *   }
     * })
     * 
    **/
    create<T extends SystemHealthMetricCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SystemHealthMetricCreateArgs<ExtArgs>>
    ): Prisma__SystemHealthMetricClient<$Result.GetResult<Prisma.$SystemHealthMetricPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SystemHealthMetrics.
     *     @param {SystemHealthMetricCreateManyArgs} args - Arguments to create many SystemHealthMetrics.
     *     @example
     *     // Create many SystemHealthMetrics
     *     const systemHealthMetric = await prisma.systemHealthMetric.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SystemHealthMetricCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemHealthMetricCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemHealthMetric.
     * @param {SystemHealthMetricDeleteArgs} args - Arguments to delete one SystemHealthMetric.
     * @example
     * // Delete one SystemHealthMetric
     * const SystemHealthMetric = await prisma.systemHealthMetric.delete({
     *   where: {
     *     // ... filter to delete one SystemHealthMetric
     *   }
     * })
     * 
    **/
    delete<T extends SystemHealthMetricDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SystemHealthMetricDeleteArgs<ExtArgs>>
    ): Prisma__SystemHealthMetricClient<$Result.GetResult<Prisma.$SystemHealthMetricPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SystemHealthMetric.
     * @param {SystemHealthMetricUpdateArgs} args - Arguments to update one SystemHealthMetric.
     * @example
     * // Update one SystemHealthMetric
     * const systemHealthMetric = await prisma.systemHealthMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SystemHealthMetricUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SystemHealthMetricUpdateArgs<ExtArgs>>
    ): Prisma__SystemHealthMetricClient<$Result.GetResult<Prisma.$SystemHealthMetricPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SystemHealthMetrics.
     * @param {SystemHealthMetricDeleteManyArgs} args - Arguments to filter SystemHealthMetrics to delete.
     * @example
     * // Delete a few SystemHealthMetrics
     * const { count } = await prisma.systemHealthMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SystemHealthMetricDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemHealthMetricDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemHealthMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemHealthMetrics
     * const systemHealthMetric = await prisma.systemHealthMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SystemHealthMetricUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SystemHealthMetricUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemHealthMetric.
     * @param {SystemHealthMetricUpsertArgs} args - Arguments to update or create a SystemHealthMetric.
     * @example
     * // Update or create a SystemHealthMetric
     * const systemHealthMetric = await prisma.systemHealthMetric.upsert({
     *   create: {
     *     // ... data to create a SystemHealthMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemHealthMetric we want to update
     *   }
     * })
    **/
    upsert<T extends SystemHealthMetricUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SystemHealthMetricUpsertArgs<ExtArgs>>
    ): Prisma__SystemHealthMetricClient<$Result.GetResult<Prisma.$SystemHealthMetricPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SystemHealthMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthMetricCountArgs} args - Arguments to filter SystemHealthMetrics to count.
     * @example
     * // Count the number of SystemHealthMetrics
     * const count = await prisma.systemHealthMetric.count({
     *   where: {
     *     // ... the filter for the SystemHealthMetrics we want to count
     *   }
     * })
    **/
    count<T extends SystemHealthMetricCountArgs>(
      args?: Subset<T, SystemHealthMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemHealthMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemHealthMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemHealthMetricAggregateArgs>(args: Subset<T, SystemHealthMetricAggregateArgs>): Prisma.PrismaPromise<GetSystemHealthMetricAggregateType<T>>

    /**
     * Group by SystemHealthMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemHealthMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemHealthMetricGroupByArgs['orderBy'] }
        : { orderBy?: SystemHealthMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemHealthMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemHealthMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemHealthMetric model
   */
  readonly fields: SystemHealthMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemHealthMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemHealthMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SystemHealthMetric model
   */ 
  interface SystemHealthMetricFieldRefs {
    readonly id: FieldRef<"SystemHealthMetric", 'String'>
    readonly metricName: FieldRef<"SystemHealthMetric", 'String'>
    readonly metricValue: FieldRef<"SystemHealthMetric", 'Decimal'>
    readonly metricUnit: FieldRef<"SystemHealthMetric", 'String'>
    readonly component: FieldRef<"SystemHealthMetric", 'String'>
    readonly severity: FieldRef<"SystemHealthMetric", 'String'>
    readonly createdAt: FieldRef<"SystemHealthMetric", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * SystemHealthMetric findUnique
   */
  export type SystemHealthMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealthMetric
     */
    select?: SystemHealthMetricSelect<ExtArgs> | null
    /**
     * Filter, which SystemHealthMetric to fetch.
     */
    where: SystemHealthMetricWhereUniqueInput
  }


  /**
   * SystemHealthMetric findUniqueOrThrow
   */
  export type SystemHealthMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealthMetric
     */
    select?: SystemHealthMetricSelect<ExtArgs> | null
    /**
     * Filter, which SystemHealthMetric to fetch.
     */
    where: SystemHealthMetricWhereUniqueInput
  }


  /**
   * SystemHealthMetric findFirst
   */
  export type SystemHealthMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealthMetric
     */
    select?: SystemHealthMetricSelect<ExtArgs> | null
    /**
     * Filter, which SystemHealthMetric to fetch.
     */
    where?: SystemHealthMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemHealthMetrics to fetch.
     */
    orderBy?: SystemHealthMetricOrderByWithRelationInput | SystemHealthMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemHealthMetrics.
     */
    cursor?: SystemHealthMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemHealthMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemHealthMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemHealthMetrics.
     */
    distinct?: SystemHealthMetricScalarFieldEnum | SystemHealthMetricScalarFieldEnum[]
  }


  /**
   * SystemHealthMetric findFirstOrThrow
   */
  export type SystemHealthMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealthMetric
     */
    select?: SystemHealthMetricSelect<ExtArgs> | null
    /**
     * Filter, which SystemHealthMetric to fetch.
     */
    where?: SystemHealthMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemHealthMetrics to fetch.
     */
    orderBy?: SystemHealthMetricOrderByWithRelationInput | SystemHealthMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemHealthMetrics.
     */
    cursor?: SystemHealthMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemHealthMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemHealthMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemHealthMetrics.
     */
    distinct?: SystemHealthMetricScalarFieldEnum | SystemHealthMetricScalarFieldEnum[]
  }


  /**
   * SystemHealthMetric findMany
   */
  export type SystemHealthMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealthMetric
     */
    select?: SystemHealthMetricSelect<ExtArgs> | null
    /**
     * Filter, which SystemHealthMetrics to fetch.
     */
    where?: SystemHealthMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemHealthMetrics to fetch.
     */
    orderBy?: SystemHealthMetricOrderByWithRelationInput | SystemHealthMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemHealthMetrics.
     */
    cursor?: SystemHealthMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemHealthMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemHealthMetrics.
     */
    skip?: number
    distinct?: SystemHealthMetricScalarFieldEnum | SystemHealthMetricScalarFieldEnum[]
  }


  /**
   * SystemHealthMetric create
   */
  export type SystemHealthMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealthMetric
     */
    select?: SystemHealthMetricSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemHealthMetric.
     */
    data: XOR<SystemHealthMetricCreateInput, SystemHealthMetricUncheckedCreateInput>
  }


  /**
   * SystemHealthMetric createMany
   */
  export type SystemHealthMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemHealthMetrics.
     */
    data: SystemHealthMetricCreateManyInput | SystemHealthMetricCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SystemHealthMetric update
   */
  export type SystemHealthMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealthMetric
     */
    select?: SystemHealthMetricSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemHealthMetric.
     */
    data: XOR<SystemHealthMetricUpdateInput, SystemHealthMetricUncheckedUpdateInput>
    /**
     * Choose, which SystemHealthMetric to update.
     */
    where: SystemHealthMetricWhereUniqueInput
  }


  /**
   * SystemHealthMetric updateMany
   */
  export type SystemHealthMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemHealthMetrics.
     */
    data: XOR<SystemHealthMetricUpdateManyMutationInput, SystemHealthMetricUncheckedUpdateManyInput>
    /**
     * Filter which SystemHealthMetrics to update
     */
    where?: SystemHealthMetricWhereInput
  }


  /**
   * SystemHealthMetric upsert
   */
  export type SystemHealthMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealthMetric
     */
    select?: SystemHealthMetricSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemHealthMetric to update in case it exists.
     */
    where: SystemHealthMetricWhereUniqueInput
    /**
     * In case the SystemHealthMetric found by the `where` argument doesn't exist, create a new SystemHealthMetric with this data.
     */
    create: XOR<SystemHealthMetricCreateInput, SystemHealthMetricUncheckedCreateInput>
    /**
     * In case the SystemHealthMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemHealthMetricUpdateInput, SystemHealthMetricUncheckedUpdateInput>
  }


  /**
   * SystemHealthMetric delete
   */
  export type SystemHealthMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealthMetric
     */
    select?: SystemHealthMetricSelect<ExtArgs> | null
    /**
     * Filter which SystemHealthMetric to delete.
     */
    where: SystemHealthMetricWhereUniqueInput
  }


  /**
   * SystemHealthMetric deleteMany
   */
  export type SystemHealthMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemHealthMetrics to delete
     */
    where?: SystemHealthMetricWhereInput
  }


  /**
   * SystemHealthMetric without action
   */
  export type SystemHealthMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealthMetric
     */
    select?: SystemHealthMetricSelect<ExtArgs> | null
  }



  /**
   * Model DiagnosticReport
   */

  export type AggregateDiagnosticReport = {
    _count: DiagnosticReportCountAggregateOutputType | null
    _avg: DiagnosticReportAvgAggregateOutputType | null
    _sum: DiagnosticReportSumAggregateOutputType | null
    _min: DiagnosticReportMinAggregateOutputType | null
    _max: DiagnosticReportMaxAggregateOutputType | null
  }

  export type DiagnosticReportAvgAggregateOutputType = {
    confidenceScore: Decimal | null
    affectedUsers: number | null
  }

  export type DiagnosticReportSumAggregateOutputType = {
    confidenceScore: Decimal | null
    affectedUsers: number | null
  }

  export type DiagnosticReportMinAggregateOutputType = {
    id: string | null
    alertId: string | null
    issueType: string | null
    rootCause: string | null
    aiAnalysis: string | null
    aiModel: string | null
    confidenceScore: Decimal | null
    suggestedFix: string | null
    severity: string | null
    affectedUsers: number | null
    createdAt: Date | null
  }

  export type DiagnosticReportMaxAggregateOutputType = {
    id: string | null
    alertId: string | null
    issueType: string | null
    rootCause: string | null
    aiAnalysis: string | null
    aiModel: string | null
    confidenceScore: Decimal | null
    suggestedFix: string | null
    severity: string | null
    affectedUsers: number | null
    createdAt: Date | null
  }

  export type DiagnosticReportCountAggregateOutputType = {
    id: number
    alertId: number
    issueType: number
    rootCause: number
    evidence: number
    aiAnalysis: number
    aiModel: number
    confidenceScore: number
    suggestedFix: number
    severity: number
    affectedUsers: number
    createdAt: number
    _all: number
  }


  export type DiagnosticReportAvgAggregateInputType = {
    confidenceScore?: true
    affectedUsers?: true
  }

  export type DiagnosticReportSumAggregateInputType = {
    confidenceScore?: true
    affectedUsers?: true
  }

  export type DiagnosticReportMinAggregateInputType = {
    id?: true
    alertId?: true
    issueType?: true
    rootCause?: true
    aiAnalysis?: true
    aiModel?: true
    confidenceScore?: true
    suggestedFix?: true
    severity?: true
    affectedUsers?: true
    createdAt?: true
  }

  export type DiagnosticReportMaxAggregateInputType = {
    id?: true
    alertId?: true
    issueType?: true
    rootCause?: true
    aiAnalysis?: true
    aiModel?: true
    confidenceScore?: true
    suggestedFix?: true
    severity?: true
    affectedUsers?: true
    createdAt?: true
  }

  export type DiagnosticReportCountAggregateInputType = {
    id?: true
    alertId?: true
    issueType?: true
    rootCause?: true
    evidence?: true
    aiAnalysis?: true
    aiModel?: true
    confidenceScore?: true
    suggestedFix?: true
    severity?: true
    affectedUsers?: true
    createdAt?: true
    _all?: true
  }

  export type DiagnosticReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiagnosticReport to aggregate.
     */
    where?: DiagnosticReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiagnosticReports to fetch.
     */
    orderBy?: DiagnosticReportOrderByWithRelationInput | DiagnosticReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiagnosticReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiagnosticReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiagnosticReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiagnosticReports
    **/
    _count?: true | DiagnosticReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiagnosticReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiagnosticReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiagnosticReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiagnosticReportMaxAggregateInputType
  }

  export type GetDiagnosticReportAggregateType<T extends DiagnosticReportAggregateArgs> = {
        [P in keyof T & keyof AggregateDiagnosticReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiagnosticReport[P]>
      : GetScalarType<T[P], AggregateDiagnosticReport[P]>
  }




  export type DiagnosticReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiagnosticReportWhereInput
    orderBy?: DiagnosticReportOrderByWithAggregationInput | DiagnosticReportOrderByWithAggregationInput[]
    by: DiagnosticReportScalarFieldEnum[] | DiagnosticReportScalarFieldEnum
    having?: DiagnosticReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiagnosticReportCountAggregateInputType | true
    _avg?: DiagnosticReportAvgAggregateInputType
    _sum?: DiagnosticReportSumAggregateInputType
    _min?: DiagnosticReportMinAggregateInputType
    _max?: DiagnosticReportMaxAggregateInputType
  }

  export type DiagnosticReportGroupByOutputType = {
    id: string
    alertId: string | null
    issueType: string
    rootCause: string | null
    evidence: JsonValue | null
    aiAnalysis: string | null
    aiModel: string | null
    confidenceScore: Decimal | null
    suggestedFix: string | null
    severity: string | null
    affectedUsers: number | null
    createdAt: Date
    _count: DiagnosticReportCountAggregateOutputType | null
    _avg: DiagnosticReportAvgAggregateOutputType | null
    _sum: DiagnosticReportSumAggregateOutputType | null
    _min: DiagnosticReportMinAggregateOutputType | null
    _max: DiagnosticReportMaxAggregateOutputType | null
  }

  type GetDiagnosticReportGroupByPayload<T extends DiagnosticReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiagnosticReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiagnosticReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiagnosticReportGroupByOutputType[P]>
            : GetScalarType<T[P], DiagnosticReportGroupByOutputType[P]>
        }
      >
    >


  export type DiagnosticReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertId?: boolean
    issueType?: boolean
    rootCause?: boolean
    evidence?: boolean
    aiAnalysis?: boolean
    aiModel?: boolean
    confidenceScore?: boolean
    suggestedFix?: boolean
    severity?: boolean
    affectedUsers?: boolean
    createdAt?: boolean
    repairs?: boolean | DiagnosticReport$repairsArgs<ExtArgs>
    _count?: boolean | DiagnosticReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosticReport"]>

  export type DiagnosticReportSelectScalar = {
    id?: boolean
    alertId?: boolean
    issueType?: boolean
    rootCause?: boolean
    evidence?: boolean
    aiAnalysis?: boolean
    aiModel?: boolean
    confidenceScore?: boolean
    suggestedFix?: boolean
    severity?: boolean
    affectedUsers?: boolean
    createdAt?: boolean
  }

  export type DiagnosticReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    repairs?: boolean | DiagnosticReport$repairsArgs<ExtArgs>
    _count?: boolean | DiagnosticReportCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DiagnosticReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DiagnosticReport"
    objects: {
      repairs: Prisma.$RepairHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      alertId: string | null
      issueType: string
      rootCause: string | null
      evidence: Prisma.JsonValue | null
      aiAnalysis: string | null
      aiModel: string | null
      confidenceScore: Prisma.Decimal | null
      suggestedFix: string | null
      severity: string | null
      affectedUsers: number | null
      createdAt: Date
    }, ExtArgs["result"]["diagnosticReport"]>
    composites: {}
  }


  type DiagnosticReportGetPayload<S extends boolean | null | undefined | DiagnosticReportDefaultArgs> = $Result.GetResult<Prisma.$DiagnosticReportPayload, S>

  type DiagnosticReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DiagnosticReportFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: DiagnosticReportCountAggregateInputType | true
    }

  export interface DiagnosticReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DiagnosticReport'], meta: { name: 'DiagnosticReport' } }
    /**
     * Find zero or one DiagnosticReport that matches the filter.
     * @param {DiagnosticReportFindUniqueArgs} args - Arguments to find a DiagnosticReport
     * @example
     * // Get one DiagnosticReport
     * const diagnosticReport = await prisma.diagnosticReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DiagnosticReportFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DiagnosticReportFindUniqueArgs<ExtArgs>>
    ): Prisma__DiagnosticReportClient<$Result.GetResult<Prisma.$DiagnosticReportPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DiagnosticReport that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DiagnosticReportFindUniqueOrThrowArgs} args - Arguments to find a DiagnosticReport
     * @example
     * // Get one DiagnosticReport
     * const diagnosticReport = await prisma.diagnosticReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DiagnosticReportFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DiagnosticReportFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DiagnosticReportClient<$Result.GetResult<Prisma.$DiagnosticReportPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DiagnosticReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosticReportFindFirstArgs} args - Arguments to find a DiagnosticReport
     * @example
     * // Get one DiagnosticReport
     * const diagnosticReport = await prisma.diagnosticReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DiagnosticReportFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DiagnosticReportFindFirstArgs<ExtArgs>>
    ): Prisma__DiagnosticReportClient<$Result.GetResult<Prisma.$DiagnosticReportPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DiagnosticReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosticReportFindFirstOrThrowArgs} args - Arguments to find a DiagnosticReport
     * @example
     * // Get one DiagnosticReport
     * const diagnosticReport = await prisma.diagnosticReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DiagnosticReportFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DiagnosticReportFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DiagnosticReportClient<$Result.GetResult<Prisma.$DiagnosticReportPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DiagnosticReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosticReportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiagnosticReports
     * const diagnosticReports = await prisma.diagnosticReport.findMany()
     * 
     * // Get first 10 DiagnosticReports
     * const diagnosticReports = await prisma.diagnosticReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diagnosticReportWithIdOnly = await prisma.diagnosticReport.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DiagnosticReportFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiagnosticReportFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosticReportPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DiagnosticReport.
     * @param {DiagnosticReportCreateArgs} args - Arguments to create a DiagnosticReport.
     * @example
     * // Create one DiagnosticReport
     * const DiagnosticReport = await prisma.diagnosticReport.create({
     *   data: {
     *     // ... data to create a DiagnosticReport
     *   }
     * })
     * 
    **/
    create<T extends DiagnosticReportCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DiagnosticReportCreateArgs<ExtArgs>>
    ): Prisma__DiagnosticReportClient<$Result.GetResult<Prisma.$DiagnosticReportPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DiagnosticReports.
     *     @param {DiagnosticReportCreateManyArgs} args - Arguments to create many DiagnosticReports.
     *     @example
     *     // Create many DiagnosticReports
     *     const diagnosticReport = await prisma.diagnosticReport.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DiagnosticReportCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiagnosticReportCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DiagnosticReport.
     * @param {DiagnosticReportDeleteArgs} args - Arguments to delete one DiagnosticReport.
     * @example
     * // Delete one DiagnosticReport
     * const DiagnosticReport = await prisma.diagnosticReport.delete({
     *   where: {
     *     // ... filter to delete one DiagnosticReport
     *   }
     * })
     * 
    **/
    delete<T extends DiagnosticReportDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DiagnosticReportDeleteArgs<ExtArgs>>
    ): Prisma__DiagnosticReportClient<$Result.GetResult<Prisma.$DiagnosticReportPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DiagnosticReport.
     * @param {DiagnosticReportUpdateArgs} args - Arguments to update one DiagnosticReport.
     * @example
     * // Update one DiagnosticReport
     * const diagnosticReport = await prisma.diagnosticReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DiagnosticReportUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DiagnosticReportUpdateArgs<ExtArgs>>
    ): Prisma__DiagnosticReportClient<$Result.GetResult<Prisma.$DiagnosticReportPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DiagnosticReports.
     * @param {DiagnosticReportDeleteManyArgs} args - Arguments to filter DiagnosticReports to delete.
     * @example
     * // Delete a few DiagnosticReports
     * const { count } = await prisma.diagnosticReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DiagnosticReportDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiagnosticReportDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiagnosticReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosticReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiagnosticReports
     * const diagnosticReport = await prisma.diagnosticReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DiagnosticReportUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DiagnosticReportUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DiagnosticReport.
     * @param {DiagnosticReportUpsertArgs} args - Arguments to update or create a DiagnosticReport.
     * @example
     * // Update or create a DiagnosticReport
     * const diagnosticReport = await prisma.diagnosticReport.upsert({
     *   create: {
     *     // ... data to create a DiagnosticReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiagnosticReport we want to update
     *   }
     * })
    **/
    upsert<T extends DiagnosticReportUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DiagnosticReportUpsertArgs<ExtArgs>>
    ): Prisma__DiagnosticReportClient<$Result.GetResult<Prisma.$DiagnosticReportPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DiagnosticReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosticReportCountArgs} args - Arguments to filter DiagnosticReports to count.
     * @example
     * // Count the number of DiagnosticReports
     * const count = await prisma.diagnosticReport.count({
     *   where: {
     *     // ... the filter for the DiagnosticReports we want to count
     *   }
     * })
    **/
    count<T extends DiagnosticReportCountArgs>(
      args?: Subset<T, DiagnosticReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiagnosticReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiagnosticReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosticReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiagnosticReportAggregateArgs>(args: Subset<T, DiagnosticReportAggregateArgs>): Prisma.PrismaPromise<GetDiagnosticReportAggregateType<T>>

    /**
     * Group by DiagnosticReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosticReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiagnosticReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiagnosticReportGroupByArgs['orderBy'] }
        : { orderBy?: DiagnosticReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiagnosticReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiagnosticReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DiagnosticReport model
   */
  readonly fields: DiagnosticReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiagnosticReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiagnosticReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    repairs<T extends DiagnosticReport$repairsArgs<ExtArgs> = {}>(args?: Subset<T, DiagnosticReport$repairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepairHistoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DiagnosticReport model
   */ 
  interface DiagnosticReportFieldRefs {
    readonly id: FieldRef<"DiagnosticReport", 'String'>
    readonly alertId: FieldRef<"DiagnosticReport", 'String'>
    readonly issueType: FieldRef<"DiagnosticReport", 'String'>
    readonly rootCause: FieldRef<"DiagnosticReport", 'String'>
    readonly evidence: FieldRef<"DiagnosticReport", 'Json'>
    readonly aiAnalysis: FieldRef<"DiagnosticReport", 'String'>
    readonly aiModel: FieldRef<"DiagnosticReport", 'String'>
    readonly confidenceScore: FieldRef<"DiagnosticReport", 'Decimal'>
    readonly suggestedFix: FieldRef<"DiagnosticReport", 'String'>
    readonly severity: FieldRef<"DiagnosticReport", 'String'>
    readonly affectedUsers: FieldRef<"DiagnosticReport", 'Int'>
    readonly createdAt: FieldRef<"DiagnosticReport", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * DiagnosticReport findUnique
   */
  export type DiagnosticReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiagnosticReportInclude<ExtArgs> | null
    /**
     * Filter, which DiagnosticReport to fetch.
     */
    where: DiagnosticReportWhereUniqueInput
  }


  /**
   * DiagnosticReport findUniqueOrThrow
   */
  export type DiagnosticReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiagnosticReportInclude<ExtArgs> | null
    /**
     * Filter, which DiagnosticReport to fetch.
     */
    where: DiagnosticReportWhereUniqueInput
  }


  /**
   * DiagnosticReport findFirst
   */
  export type DiagnosticReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiagnosticReportInclude<ExtArgs> | null
    /**
     * Filter, which DiagnosticReport to fetch.
     */
    where?: DiagnosticReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiagnosticReports to fetch.
     */
    orderBy?: DiagnosticReportOrderByWithRelationInput | DiagnosticReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiagnosticReports.
     */
    cursor?: DiagnosticReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiagnosticReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiagnosticReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiagnosticReports.
     */
    distinct?: DiagnosticReportScalarFieldEnum | DiagnosticReportScalarFieldEnum[]
  }


  /**
   * DiagnosticReport findFirstOrThrow
   */
  export type DiagnosticReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiagnosticReportInclude<ExtArgs> | null
    /**
     * Filter, which DiagnosticReport to fetch.
     */
    where?: DiagnosticReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiagnosticReports to fetch.
     */
    orderBy?: DiagnosticReportOrderByWithRelationInput | DiagnosticReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiagnosticReports.
     */
    cursor?: DiagnosticReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiagnosticReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiagnosticReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiagnosticReports.
     */
    distinct?: DiagnosticReportScalarFieldEnum | DiagnosticReportScalarFieldEnum[]
  }


  /**
   * DiagnosticReport findMany
   */
  export type DiagnosticReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiagnosticReportInclude<ExtArgs> | null
    /**
     * Filter, which DiagnosticReports to fetch.
     */
    where?: DiagnosticReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiagnosticReports to fetch.
     */
    orderBy?: DiagnosticReportOrderByWithRelationInput | DiagnosticReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiagnosticReports.
     */
    cursor?: DiagnosticReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiagnosticReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiagnosticReports.
     */
    skip?: number
    distinct?: DiagnosticReportScalarFieldEnum | DiagnosticReportScalarFieldEnum[]
  }


  /**
   * DiagnosticReport create
   */
  export type DiagnosticReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiagnosticReportInclude<ExtArgs> | null
    /**
     * The data needed to create a DiagnosticReport.
     */
    data: XOR<DiagnosticReportCreateInput, DiagnosticReportUncheckedCreateInput>
  }


  /**
   * DiagnosticReport createMany
   */
  export type DiagnosticReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DiagnosticReports.
     */
    data: DiagnosticReportCreateManyInput | DiagnosticReportCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DiagnosticReport update
   */
  export type DiagnosticReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiagnosticReportInclude<ExtArgs> | null
    /**
     * The data needed to update a DiagnosticReport.
     */
    data: XOR<DiagnosticReportUpdateInput, DiagnosticReportUncheckedUpdateInput>
    /**
     * Choose, which DiagnosticReport to update.
     */
    where: DiagnosticReportWhereUniqueInput
  }


  /**
   * DiagnosticReport updateMany
   */
  export type DiagnosticReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DiagnosticReports.
     */
    data: XOR<DiagnosticReportUpdateManyMutationInput, DiagnosticReportUncheckedUpdateManyInput>
    /**
     * Filter which DiagnosticReports to update
     */
    where?: DiagnosticReportWhereInput
  }


  /**
   * DiagnosticReport upsert
   */
  export type DiagnosticReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiagnosticReportInclude<ExtArgs> | null
    /**
     * The filter to search for the DiagnosticReport to update in case it exists.
     */
    where: DiagnosticReportWhereUniqueInput
    /**
     * In case the DiagnosticReport found by the `where` argument doesn't exist, create a new DiagnosticReport with this data.
     */
    create: XOR<DiagnosticReportCreateInput, DiagnosticReportUncheckedCreateInput>
    /**
     * In case the DiagnosticReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiagnosticReportUpdateInput, DiagnosticReportUncheckedUpdateInput>
  }


  /**
   * DiagnosticReport delete
   */
  export type DiagnosticReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiagnosticReportInclude<ExtArgs> | null
    /**
     * Filter which DiagnosticReport to delete.
     */
    where: DiagnosticReportWhereUniqueInput
  }


  /**
   * DiagnosticReport deleteMany
   */
  export type DiagnosticReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiagnosticReports to delete
     */
    where?: DiagnosticReportWhereInput
  }


  /**
   * DiagnosticReport.repairs
   */
  export type DiagnosticReport$repairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude<ExtArgs> | null
    where?: RepairHistoryWhereInput
    orderBy?: RepairHistoryOrderByWithRelationInput | RepairHistoryOrderByWithRelationInput[]
    cursor?: RepairHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RepairHistoryScalarFieldEnum | RepairHistoryScalarFieldEnum[]
  }


  /**
   * DiagnosticReport without action
   */
  export type DiagnosticReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiagnosticReportInclude<ExtArgs> | null
  }



  /**
   * Model RepairHistory
   */

  export type AggregateRepairHistory = {
    _count: RepairHistoryCountAggregateOutputType | null
    _avg: RepairHistoryAvgAggregateOutputType | null
    _sum: RepairHistorySumAggregateOutputType | null
    _min: RepairHistoryMinAggregateOutputType | null
    _max: RepairHistoryMaxAggregateOutputType | null
  }

  export type RepairHistoryAvgAggregateOutputType = {
    timeToFixSeconds: number | null
  }

  export type RepairHistorySumAggregateOutputType = {
    timeToFixSeconds: number | null
  }

  export type RepairHistoryMinAggregateOutputType = {
    id: string | null
    diagnosticId: string | null
    repairType: string | null
    fixApplied: string | null
    fixCode: string | null
    success: boolean | null
    timeToFixSeconds: number | null
    rollbackPlan: string | null
    createdAt: Date | null
  }

  export type RepairHistoryMaxAggregateOutputType = {
    id: string | null
    diagnosticId: string | null
    repairType: string | null
    fixApplied: string | null
    fixCode: string | null
    success: boolean | null
    timeToFixSeconds: number | null
    rollbackPlan: string | null
    createdAt: Date | null
  }

  export type RepairHistoryCountAggregateOutputType = {
    id: number
    diagnosticId: number
    repairType: number
    fixApplied: number
    fixCode: number
    success: number
    timeToFixSeconds: number
    verificationResult: number
    rollbackPlan: number
    createdAt: number
    _all: number
  }


  export type RepairHistoryAvgAggregateInputType = {
    timeToFixSeconds?: true
  }

  export type RepairHistorySumAggregateInputType = {
    timeToFixSeconds?: true
  }

  export type RepairHistoryMinAggregateInputType = {
    id?: true
    diagnosticId?: true
    repairType?: true
    fixApplied?: true
    fixCode?: true
    success?: true
    timeToFixSeconds?: true
    rollbackPlan?: true
    createdAt?: true
  }

  export type RepairHistoryMaxAggregateInputType = {
    id?: true
    diagnosticId?: true
    repairType?: true
    fixApplied?: true
    fixCode?: true
    success?: true
    timeToFixSeconds?: true
    rollbackPlan?: true
    createdAt?: true
  }

  export type RepairHistoryCountAggregateInputType = {
    id?: true
    diagnosticId?: true
    repairType?: true
    fixApplied?: true
    fixCode?: true
    success?: true
    timeToFixSeconds?: true
    verificationResult?: true
    rollbackPlan?: true
    createdAt?: true
    _all?: true
  }

  export type RepairHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RepairHistory to aggregate.
     */
    where?: RepairHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairHistories to fetch.
     */
    orderBy?: RepairHistoryOrderByWithRelationInput | RepairHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RepairHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RepairHistories
    **/
    _count?: true | RepairHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepairHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepairHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepairHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepairHistoryMaxAggregateInputType
  }

  export type GetRepairHistoryAggregateType<T extends RepairHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateRepairHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepairHistory[P]>
      : GetScalarType<T[P], AggregateRepairHistory[P]>
  }




  export type RepairHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepairHistoryWhereInput
    orderBy?: RepairHistoryOrderByWithAggregationInput | RepairHistoryOrderByWithAggregationInput[]
    by: RepairHistoryScalarFieldEnum[] | RepairHistoryScalarFieldEnum
    having?: RepairHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepairHistoryCountAggregateInputType | true
    _avg?: RepairHistoryAvgAggregateInputType
    _sum?: RepairHistorySumAggregateInputType
    _min?: RepairHistoryMinAggregateInputType
    _max?: RepairHistoryMaxAggregateInputType
  }

  export type RepairHistoryGroupByOutputType = {
    id: string
    diagnosticId: string | null
    repairType: string
    fixApplied: string | null
    fixCode: string | null
    success: boolean
    timeToFixSeconds: number | null
    verificationResult: JsonValue | null
    rollbackPlan: string | null
    createdAt: Date
    _count: RepairHistoryCountAggregateOutputType | null
    _avg: RepairHistoryAvgAggregateOutputType | null
    _sum: RepairHistorySumAggregateOutputType | null
    _min: RepairHistoryMinAggregateOutputType | null
    _max: RepairHistoryMaxAggregateOutputType | null
  }

  type GetRepairHistoryGroupByPayload<T extends RepairHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RepairHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepairHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepairHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], RepairHistoryGroupByOutputType[P]>
        }
      >
    >


  export type RepairHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    diagnosticId?: boolean
    repairType?: boolean
    fixApplied?: boolean
    fixCode?: boolean
    success?: boolean
    timeToFixSeconds?: boolean
    verificationResult?: boolean
    rollbackPlan?: boolean
    createdAt?: boolean
    diagnostic?: boolean | RepairHistory$diagnosticArgs<ExtArgs>
  }, ExtArgs["result"]["repairHistory"]>

  export type RepairHistorySelectScalar = {
    id?: boolean
    diagnosticId?: boolean
    repairType?: boolean
    fixApplied?: boolean
    fixCode?: boolean
    success?: boolean
    timeToFixSeconds?: boolean
    verificationResult?: boolean
    rollbackPlan?: boolean
    createdAt?: boolean
  }

  export type RepairHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diagnostic?: boolean | RepairHistory$diagnosticArgs<ExtArgs>
  }


  export type $RepairHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RepairHistory"
    objects: {
      diagnostic: Prisma.$DiagnosticReportPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      diagnosticId: string | null
      repairType: string
      fixApplied: string | null
      fixCode: string | null
      success: boolean
      timeToFixSeconds: number | null
      verificationResult: Prisma.JsonValue | null
      rollbackPlan: string | null
      createdAt: Date
    }, ExtArgs["result"]["repairHistory"]>
    composites: {}
  }


  type RepairHistoryGetPayload<S extends boolean | null | undefined | RepairHistoryDefaultArgs> = $Result.GetResult<Prisma.$RepairHistoryPayload, S>

  type RepairHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RepairHistoryFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RepairHistoryCountAggregateInputType | true
    }

  export interface RepairHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RepairHistory'], meta: { name: 'RepairHistory' } }
    /**
     * Find zero or one RepairHistory that matches the filter.
     * @param {RepairHistoryFindUniqueArgs} args - Arguments to find a RepairHistory
     * @example
     * // Get one RepairHistory
     * const repairHistory = await prisma.repairHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RepairHistoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RepairHistoryFindUniqueArgs<ExtArgs>>
    ): Prisma__RepairHistoryClient<$Result.GetResult<Prisma.$RepairHistoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RepairHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RepairHistoryFindUniqueOrThrowArgs} args - Arguments to find a RepairHistory
     * @example
     * // Get one RepairHistory
     * const repairHistory = await prisma.repairHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RepairHistoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RepairHistoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RepairHistoryClient<$Result.GetResult<Prisma.$RepairHistoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RepairHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairHistoryFindFirstArgs} args - Arguments to find a RepairHistory
     * @example
     * // Get one RepairHistory
     * const repairHistory = await prisma.repairHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RepairHistoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RepairHistoryFindFirstArgs<ExtArgs>>
    ): Prisma__RepairHistoryClient<$Result.GetResult<Prisma.$RepairHistoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RepairHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairHistoryFindFirstOrThrowArgs} args - Arguments to find a RepairHistory
     * @example
     * // Get one RepairHistory
     * const repairHistory = await prisma.repairHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RepairHistoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RepairHistoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RepairHistoryClient<$Result.GetResult<Prisma.$RepairHistoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RepairHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RepairHistories
     * const repairHistories = await prisma.repairHistory.findMany()
     * 
     * // Get first 10 RepairHistories
     * const repairHistories = await prisma.repairHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const repairHistoryWithIdOnly = await prisma.repairHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RepairHistoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RepairHistoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepairHistoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RepairHistory.
     * @param {RepairHistoryCreateArgs} args - Arguments to create a RepairHistory.
     * @example
     * // Create one RepairHistory
     * const RepairHistory = await prisma.repairHistory.create({
     *   data: {
     *     // ... data to create a RepairHistory
     *   }
     * })
     * 
    **/
    create<T extends RepairHistoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RepairHistoryCreateArgs<ExtArgs>>
    ): Prisma__RepairHistoryClient<$Result.GetResult<Prisma.$RepairHistoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RepairHistories.
     *     @param {RepairHistoryCreateManyArgs} args - Arguments to create many RepairHistories.
     *     @example
     *     // Create many RepairHistories
     *     const repairHistory = await prisma.repairHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RepairHistoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RepairHistoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RepairHistory.
     * @param {RepairHistoryDeleteArgs} args - Arguments to delete one RepairHistory.
     * @example
     * // Delete one RepairHistory
     * const RepairHistory = await prisma.repairHistory.delete({
     *   where: {
     *     // ... filter to delete one RepairHistory
     *   }
     * })
     * 
    **/
    delete<T extends RepairHistoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RepairHistoryDeleteArgs<ExtArgs>>
    ): Prisma__RepairHistoryClient<$Result.GetResult<Prisma.$RepairHistoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RepairHistory.
     * @param {RepairHistoryUpdateArgs} args - Arguments to update one RepairHistory.
     * @example
     * // Update one RepairHistory
     * const repairHistory = await prisma.repairHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RepairHistoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RepairHistoryUpdateArgs<ExtArgs>>
    ): Prisma__RepairHistoryClient<$Result.GetResult<Prisma.$RepairHistoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RepairHistories.
     * @param {RepairHistoryDeleteManyArgs} args - Arguments to filter RepairHistories to delete.
     * @example
     * // Delete a few RepairHistories
     * const { count } = await prisma.repairHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RepairHistoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RepairHistoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RepairHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RepairHistories
     * const repairHistory = await prisma.repairHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RepairHistoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RepairHistoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RepairHistory.
     * @param {RepairHistoryUpsertArgs} args - Arguments to update or create a RepairHistory.
     * @example
     * // Update or create a RepairHistory
     * const repairHistory = await prisma.repairHistory.upsert({
     *   create: {
     *     // ... data to create a RepairHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RepairHistory we want to update
     *   }
     * })
    **/
    upsert<T extends RepairHistoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RepairHistoryUpsertArgs<ExtArgs>>
    ): Prisma__RepairHistoryClient<$Result.GetResult<Prisma.$RepairHistoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RepairHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairHistoryCountArgs} args - Arguments to filter RepairHistories to count.
     * @example
     * // Count the number of RepairHistories
     * const count = await prisma.repairHistory.count({
     *   where: {
     *     // ... the filter for the RepairHistories we want to count
     *   }
     * })
    **/
    count<T extends RepairHistoryCountArgs>(
      args?: Subset<T, RepairHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepairHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RepairHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepairHistoryAggregateArgs>(args: Subset<T, RepairHistoryAggregateArgs>): Prisma.PrismaPromise<GetRepairHistoryAggregateType<T>>

    /**
     * Group by RepairHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepairHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepairHistoryGroupByArgs['orderBy'] }
        : { orderBy?: RepairHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepairHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepairHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RepairHistory model
   */
  readonly fields: RepairHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RepairHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RepairHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    diagnostic<T extends RepairHistory$diagnosticArgs<ExtArgs> = {}>(args?: Subset<T, RepairHistory$diagnosticArgs<ExtArgs>>): Prisma__DiagnosticReportClient<$Result.GetResult<Prisma.$DiagnosticReportPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RepairHistory model
   */ 
  interface RepairHistoryFieldRefs {
    readonly id: FieldRef<"RepairHistory", 'String'>
    readonly diagnosticId: FieldRef<"RepairHistory", 'String'>
    readonly repairType: FieldRef<"RepairHistory", 'String'>
    readonly fixApplied: FieldRef<"RepairHistory", 'String'>
    readonly fixCode: FieldRef<"RepairHistory", 'String'>
    readonly success: FieldRef<"RepairHistory", 'Boolean'>
    readonly timeToFixSeconds: FieldRef<"RepairHistory", 'Int'>
    readonly verificationResult: FieldRef<"RepairHistory", 'Json'>
    readonly rollbackPlan: FieldRef<"RepairHistory", 'String'>
    readonly createdAt: FieldRef<"RepairHistory", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * RepairHistory findUnique
   */
  export type RepairHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RepairHistory to fetch.
     */
    where: RepairHistoryWhereUniqueInput
  }


  /**
   * RepairHistory findUniqueOrThrow
   */
  export type RepairHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RepairHistory to fetch.
     */
    where: RepairHistoryWhereUniqueInput
  }


  /**
   * RepairHistory findFirst
   */
  export type RepairHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RepairHistory to fetch.
     */
    where?: RepairHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairHistories to fetch.
     */
    orderBy?: RepairHistoryOrderByWithRelationInput | RepairHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairHistories.
     */
    cursor?: RepairHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairHistories.
     */
    distinct?: RepairHistoryScalarFieldEnum | RepairHistoryScalarFieldEnum[]
  }


  /**
   * RepairHistory findFirstOrThrow
   */
  export type RepairHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RepairHistory to fetch.
     */
    where?: RepairHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairHistories to fetch.
     */
    orderBy?: RepairHistoryOrderByWithRelationInput | RepairHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairHistories.
     */
    cursor?: RepairHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairHistories.
     */
    distinct?: RepairHistoryScalarFieldEnum | RepairHistoryScalarFieldEnum[]
  }


  /**
   * RepairHistory findMany
   */
  export type RepairHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RepairHistories to fetch.
     */
    where?: RepairHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairHistories to fetch.
     */
    orderBy?: RepairHistoryOrderByWithRelationInput | RepairHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RepairHistories.
     */
    cursor?: RepairHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairHistories.
     */
    skip?: number
    distinct?: RepairHistoryScalarFieldEnum | RepairHistoryScalarFieldEnum[]
  }


  /**
   * RepairHistory create
   */
  export type RepairHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a RepairHistory.
     */
    data: XOR<RepairHistoryCreateInput, RepairHistoryUncheckedCreateInput>
  }


  /**
   * RepairHistory createMany
   */
  export type RepairHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RepairHistories.
     */
    data: RepairHistoryCreateManyInput | RepairHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RepairHistory update
   */
  export type RepairHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a RepairHistory.
     */
    data: XOR<RepairHistoryUpdateInput, RepairHistoryUncheckedUpdateInput>
    /**
     * Choose, which RepairHistory to update.
     */
    where: RepairHistoryWhereUniqueInput
  }


  /**
   * RepairHistory updateMany
   */
  export type RepairHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RepairHistories.
     */
    data: XOR<RepairHistoryUpdateManyMutationInput, RepairHistoryUncheckedUpdateManyInput>
    /**
     * Filter which RepairHistories to update
     */
    where?: RepairHistoryWhereInput
  }


  /**
   * RepairHistory upsert
   */
  export type RepairHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the RepairHistory to update in case it exists.
     */
    where: RepairHistoryWhereUniqueInput
    /**
     * In case the RepairHistory found by the `where` argument doesn't exist, create a new RepairHistory with this data.
     */
    create: XOR<RepairHistoryCreateInput, RepairHistoryUncheckedCreateInput>
    /**
     * In case the RepairHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RepairHistoryUpdateInput, RepairHistoryUncheckedUpdateInput>
  }


  /**
   * RepairHistory delete
   */
  export type RepairHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude<ExtArgs> | null
    /**
     * Filter which RepairHistory to delete.
     */
    where: RepairHistoryWhereUniqueInput
  }


  /**
   * RepairHistory deleteMany
   */
  export type RepairHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RepairHistories to delete
     */
    where?: RepairHistoryWhereInput
  }


  /**
   * RepairHistory.diagnostic
   */
  export type RepairHistory$diagnosticArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiagnosticReportInclude<ExtArgs> | null
    where?: DiagnosticReportWhereInput
  }


  /**
   * RepairHistory without action
   */
  export type RepairHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude<ExtArgs> | null
  }



  /**
   * Model LearningPattern
   */

  export type AggregateLearningPattern = {
    _count: LearningPatternCountAggregateOutputType | null
    _avg: LearningPatternAvgAggregateOutputType | null
    _sum: LearningPatternSumAggregateOutputType | null
    _min: LearningPatternMinAggregateOutputType | null
    _max: LearningPatternMaxAggregateOutputType | null
  }

  export type LearningPatternAvgAggregateOutputType = {
    successCount: number | null
    failureCount: number | null
    avgFixTimeSeconds: number | null
  }

  export type LearningPatternSumAggregateOutputType = {
    successCount: number | null
    failureCount: number | null
    avgFixTimeSeconds: number | null
  }

  export type LearningPatternMinAggregateOutputType = {
    id: string | null
    patternHash: string | null
    rootCause: string | null
    solution: string | null
    successCount: number | null
    failureCount: number | null
    avgFixTimeSeconds: number | null
    autoFixEnabled: boolean | null
    lastAppliedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LearningPatternMaxAggregateOutputType = {
    id: string | null
    patternHash: string | null
    rootCause: string | null
    solution: string | null
    successCount: number | null
    failureCount: number | null
    avgFixTimeSeconds: number | null
    autoFixEnabled: boolean | null
    lastAppliedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LearningPatternCountAggregateOutputType = {
    id: number
    patternHash: number
    symptoms: number
    rootCause: number
    solution: number
    successCount: number
    failureCount: number
    avgFixTimeSeconds: number
    autoFixEnabled: number
    lastAppliedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LearningPatternAvgAggregateInputType = {
    successCount?: true
    failureCount?: true
    avgFixTimeSeconds?: true
  }

  export type LearningPatternSumAggregateInputType = {
    successCount?: true
    failureCount?: true
    avgFixTimeSeconds?: true
  }

  export type LearningPatternMinAggregateInputType = {
    id?: true
    patternHash?: true
    rootCause?: true
    solution?: true
    successCount?: true
    failureCount?: true
    avgFixTimeSeconds?: true
    autoFixEnabled?: true
    lastAppliedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LearningPatternMaxAggregateInputType = {
    id?: true
    patternHash?: true
    rootCause?: true
    solution?: true
    successCount?: true
    failureCount?: true
    avgFixTimeSeconds?: true
    autoFixEnabled?: true
    lastAppliedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LearningPatternCountAggregateInputType = {
    id?: true
    patternHash?: true
    symptoms?: true
    rootCause?: true
    solution?: true
    successCount?: true
    failureCount?: true
    avgFixTimeSeconds?: true
    autoFixEnabled?: true
    lastAppliedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LearningPatternAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningPattern to aggregate.
     */
    where?: LearningPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPatterns to fetch.
     */
    orderBy?: LearningPatternOrderByWithRelationInput | LearningPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningPatterns
    **/
    _count?: true | LearningPatternCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LearningPatternAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LearningPatternSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningPatternMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningPatternMaxAggregateInputType
  }

  export type GetLearningPatternAggregateType<T extends LearningPatternAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningPattern]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningPattern[P]>
      : GetScalarType<T[P], AggregateLearningPattern[P]>
  }




  export type LearningPatternGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPatternWhereInput
    orderBy?: LearningPatternOrderByWithAggregationInput | LearningPatternOrderByWithAggregationInput[]
    by: LearningPatternScalarFieldEnum[] | LearningPatternScalarFieldEnum
    having?: LearningPatternScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningPatternCountAggregateInputType | true
    _avg?: LearningPatternAvgAggregateInputType
    _sum?: LearningPatternSumAggregateInputType
    _min?: LearningPatternMinAggregateInputType
    _max?: LearningPatternMaxAggregateInputType
  }

  export type LearningPatternGroupByOutputType = {
    id: string
    patternHash: string
    symptoms: JsonValue
    rootCause: string | null
    solution: string | null
    successCount: number
    failureCount: number
    avgFixTimeSeconds: number | null
    autoFixEnabled: boolean
    lastAppliedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: LearningPatternCountAggregateOutputType | null
    _avg: LearningPatternAvgAggregateOutputType | null
    _sum: LearningPatternSumAggregateOutputType | null
    _min: LearningPatternMinAggregateOutputType | null
    _max: LearningPatternMaxAggregateOutputType | null
  }

  type GetLearningPatternGroupByPayload<T extends LearningPatternGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningPatternGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningPatternGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningPatternGroupByOutputType[P]>
            : GetScalarType<T[P], LearningPatternGroupByOutputType[P]>
        }
      >
    >


  export type LearningPatternSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patternHash?: boolean
    symptoms?: boolean
    rootCause?: boolean
    solution?: boolean
    successCount?: boolean
    failureCount?: boolean
    avgFixTimeSeconds?: boolean
    autoFixEnabled?: boolean
    lastAppliedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["learningPattern"]>

  export type LearningPatternSelectScalar = {
    id?: boolean
    patternHash?: boolean
    symptoms?: boolean
    rootCause?: boolean
    solution?: boolean
    successCount?: boolean
    failureCount?: boolean
    avgFixTimeSeconds?: boolean
    autoFixEnabled?: boolean
    lastAppliedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $LearningPatternPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningPattern"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patternHash: string
      symptoms: Prisma.JsonValue
      rootCause: string | null
      solution: string | null
      successCount: number
      failureCount: number
      avgFixTimeSeconds: number | null
      autoFixEnabled: boolean
      lastAppliedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["learningPattern"]>
    composites: {}
  }


  type LearningPatternGetPayload<S extends boolean | null | undefined | LearningPatternDefaultArgs> = $Result.GetResult<Prisma.$LearningPatternPayload, S>

  type LearningPatternCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LearningPatternFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: LearningPatternCountAggregateInputType | true
    }

  export interface LearningPatternDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningPattern'], meta: { name: 'LearningPattern' } }
    /**
     * Find zero or one LearningPattern that matches the filter.
     * @param {LearningPatternFindUniqueArgs} args - Arguments to find a LearningPattern
     * @example
     * // Get one LearningPattern
     * const learningPattern = await prisma.learningPattern.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LearningPatternFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LearningPatternFindUniqueArgs<ExtArgs>>
    ): Prisma__LearningPatternClient<$Result.GetResult<Prisma.$LearningPatternPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LearningPattern that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LearningPatternFindUniqueOrThrowArgs} args - Arguments to find a LearningPattern
     * @example
     * // Get one LearningPattern
     * const learningPattern = await prisma.learningPattern.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LearningPatternFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LearningPatternFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LearningPatternClient<$Result.GetResult<Prisma.$LearningPatternPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LearningPattern that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPatternFindFirstArgs} args - Arguments to find a LearningPattern
     * @example
     * // Get one LearningPattern
     * const learningPattern = await prisma.learningPattern.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LearningPatternFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LearningPatternFindFirstArgs<ExtArgs>>
    ): Prisma__LearningPatternClient<$Result.GetResult<Prisma.$LearningPatternPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LearningPattern that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPatternFindFirstOrThrowArgs} args - Arguments to find a LearningPattern
     * @example
     * // Get one LearningPattern
     * const learningPattern = await prisma.learningPattern.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LearningPatternFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LearningPatternFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LearningPatternClient<$Result.GetResult<Prisma.$LearningPatternPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LearningPatterns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPatternFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningPatterns
     * const learningPatterns = await prisma.learningPattern.findMany()
     * 
     * // Get first 10 LearningPatterns
     * const learningPatterns = await prisma.learningPattern.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learningPatternWithIdOnly = await prisma.learningPattern.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LearningPatternFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LearningPatternFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPatternPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LearningPattern.
     * @param {LearningPatternCreateArgs} args - Arguments to create a LearningPattern.
     * @example
     * // Create one LearningPattern
     * const LearningPattern = await prisma.learningPattern.create({
     *   data: {
     *     // ... data to create a LearningPattern
     *   }
     * })
     * 
    **/
    create<T extends LearningPatternCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LearningPatternCreateArgs<ExtArgs>>
    ): Prisma__LearningPatternClient<$Result.GetResult<Prisma.$LearningPatternPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LearningPatterns.
     *     @param {LearningPatternCreateManyArgs} args - Arguments to create many LearningPatterns.
     *     @example
     *     // Create many LearningPatterns
     *     const learningPattern = await prisma.learningPattern.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LearningPatternCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LearningPatternCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LearningPattern.
     * @param {LearningPatternDeleteArgs} args - Arguments to delete one LearningPattern.
     * @example
     * // Delete one LearningPattern
     * const LearningPattern = await prisma.learningPattern.delete({
     *   where: {
     *     // ... filter to delete one LearningPattern
     *   }
     * })
     * 
    **/
    delete<T extends LearningPatternDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LearningPatternDeleteArgs<ExtArgs>>
    ): Prisma__LearningPatternClient<$Result.GetResult<Prisma.$LearningPatternPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LearningPattern.
     * @param {LearningPatternUpdateArgs} args - Arguments to update one LearningPattern.
     * @example
     * // Update one LearningPattern
     * const learningPattern = await prisma.learningPattern.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LearningPatternUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LearningPatternUpdateArgs<ExtArgs>>
    ): Prisma__LearningPatternClient<$Result.GetResult<Prisma.$LearningPatternPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LearningPatterns.
     * @param {LearningPatternDeleteManyArgs} args - Arguments to filter LearningPatterns to delete.
     * @example
     * // Delete a few LearningPatterns
     * const { count } = await prisma.learningPattern.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LearningPatternDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LearningPatternDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPatternUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningPatterns
     * const learningPattern = await prisma.learningPattern.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LearningPatternUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LearningPatternUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LearningPattern.
     * @param {LearningPatternUpsertArgs} args - Arguments to update or create a LearningPattern.
     * @example
     * // Update or create a LearningPattern
     * const learningPattern = await prisma.learningPattern.upsert({
     *   create: {
     *     // ... data to create a LearningPattern
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningPattern we want to update
     *   }
     * })
    **/
    upsert<T extends LearningPatternUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LearningPatternUpsertArgs<ExtArgs>>
    ): Prisma__LearningPatternClient<$Result.GetResult<Prisma.$LearningPatternPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LearningPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPatternCountArgs} args - Arguments to filter LearningPatterns to count.
     * @example
     * // Count the number of LearningPatterns
     * const count = await prisma.learningPattern.count({
     *   where: {
     *     // ... the filter for the LearningPatterns we want to count
     *   }
     * })
    **/
    count<T extends LearningPatternCountArgs>(
      args?: Subset<T, LearningPatternCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningPatternCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPatternAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningPatternAggregateArgs>(args: Subset<T, LearningPatternAggregateArgs>): Prisma.PrismaPromise<GetLearningPatternAggregateType<T>>

    /**
     * Group by LearningPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPatternGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningPatternGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningPatternGroupByArgs['orderBy'] }
        : { orderBy?: LearningPatternGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningPatternGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningPatternGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningPattern model
   */
  readonly fields: LearningPatternFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningPattern.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningPatternClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LearningPattern model
   */ 
  interface LearningPatternFieldRefs {
    readonly id: FieldRef<"LearningPattern", 'String'>
    readonly patternHash: FieldRef<"LearningPattern", 'String'>
    readonly symptoms: FieldRef<"LearningPattern", 'Json'>
    readonly rootCause: FieldRef<"LearningPattern", 'String'>
    readonly solution: FieldRef<"LearningPattern", 'String'>
    readonly successCount: FieldRef<"LearningPattern", 'Int'>
    readonly failureCount: FieldRef<"LearningPattern", 'Int'>
    readonly avgFixTimeSeconds: FieldRef<"LearningPattern", 'Int'>
    readonly autoFixEnabled: FieldRef<"LearningPattern", 'Boolean'>
    readonly lastAppliedAt: FieldRef<"LearningPattern", 'DateTime'>
    readonly createdAt: FieldRef<"LearningPattern", 'DateTime'>
    readonly updatedAt: FieldRef<"LearningPattern", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * LearningPattern findUnique
   */
  export type LearningPatternFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPattern
     */
    select?: LearningPatternSelect<ExtArgs> | null
    /**
     * Filter, which LearningPattern to fetch.
     */
    where: LearningPatternWhereUniqueInput
  }


  /**
   * LearningPattern findUniqueOrThrow
   */
  export type LearningPatternFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPattern
     */
    select?: LearningPatternSelect<ExtArgs> | null
    /**
     * Filter, which LearningPattern to fetch.
     */
    where: LearningPatternWhereUniqueInput
  }


  /**
   * LearningPattern findFirst
   */
  export type LearningPatternFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPattern
     */
    select?: LearningPatternSelect<ExtArgs> | null
    /**
     * Filter, which LearningPattern to fetch.
     */
    where?: LearningPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPatterns to fetch.
     */
    orderBy?: LearningPatternOrderByWithRelationInput | LearningPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningPatterns.
     */
    cursor?: LearningPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningPatterns.
     */
    distinct?: LearningPatternScalarFieldEnum | LearningPatternScalarFieldEnum[]
  }


  /**
   * LearningPattern findFirstOrThrow
   */
  export type LearningPatternFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPattern
     */
    select?: LearningPatternSelect<ExtArgs> | null
    /**
     * Filter, which LearningPattern to fetch.
     */
    where?: LearningPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPatterns to fetch.
     */
    orderBy?: LearningPatternOrderByWithRelationInput | LearningPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningPatterns.
     */
    cursor?: LearningPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningPatterns.
     */
    distinct?: LearningPatternScalarFieldEnum | LearningPatternScalarFieldEnum[]
  }


  /**
   * LearningPattern findMany
   */
  export type LearningPatternFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPattern
     */
    select?: LearningPatternSelect<ExtArgs> | null
    /**
     * Filter, which LearningPatterns to fetch.
     */
    where?: LearningPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPatterns to fetch.
     */
    orderBy?: LearningPatternOrderByWithRelationInput | LearningPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningPatterns.
     */
    cursor?: LearningPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPatterns.
     */
    skip?: number
    distinct?: LearningPatternScalarFieldEnum | LearningPatternScalarFieldEnum[]
  }


  /**
   * LearningPattern create
   */
  export type LearningPatternCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPattern
     */
    select?: LearningPatternSelect<ExtArgs> | null
    /**
     * The data needed to create a LearningPattern.
     */
    data: XOR<LearningPatternCreateInput, LearningPatternUncheckedCreateInput>
  }


  /**
   * LearningPattern createMany
   */
  export type LearningPatternCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningPatterns.
     */
    data: LearningPatternCreateManyInput | LearningPatternCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LearningPattern update
   */
  export type LearningPatternUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPattern
     */
    select?: LearningPatternSelect<ExtArgs> | null
    /**
     * The data needed to update a LearningPattern.
     */
    data: XOR<LearningPatternUpdateInput, LearningPatternUncheckedUpdateInput>
    /**
     * Choose, which LearningPattern to update.
     */
    where: LearningPatternWhereUniqueInput
  }


  /**
   * LearningPattern updateMany
   */
  export type LearningPatternUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningPatterns.
     */
    data: XOR<LearningPatternUpdateManyMutationInput, LearningPatternUncheckedUpdateManyInput>
    /**
     * Filter which LearningPatterns to update
     */
    where?: LearningPatternWhereInput
  }


  /**
   * LearningPattern upsert
   */
  export type LearningPatternUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPattern
     */
    select?: LearningPatternSelect<ExtArgs> | null
    /**
     * The filter to search for the LearningPattern to update in case it exists.
     */
    where: LearningPatternWhereUniqueInput
    /**
     * In case the LearningPattern found by the `where` argument doesn't exist, create a new LearningPattern with this data.
     */
    create: XOR<LearningPatternCreateInput, LearningPatternUncheckedCreateInput>
    /**
     * In case the LearningPattern was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningPatternUpdateInput, LearningPatternUncheckedUpdateInput>
  }


  /**
   * LearningPattern delete
   */
  export type LearningPatternDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPattern
     */
    select?: LearningPatternSelect<ExtArgs> | null
    /**
     * Filter which LearningPattern to delete.
     */
    where: LearningPatternWhereUniqueInput
  }


  /**
   * LearningPattern deleteMany
   */
  export type LearningPatternDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningPatterns to delete
     */
    where?: LearningPatternWhereInput
  }


  /**
   * LearningPattern without action
   */
  export type LearningPatternDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPattern
     */
    select?: LearningPatternSelect<ExtArgs> | null
  }



  /**
   * Model Prediction
   */

  export type AggregatePrediction = {
    _count: PredictionCountAggregateOutputType | null
    _avg: PredictionAvgAggregateOutputType | null
    _sum: PredictionSumAggregateOutputType | null
    _min: PredictionMinAggregateOutputType | null
    _max: PredictionMaxAggregateOutputType | null
  }

  export type PredictionAvgAggregateOutputType = {
    confidence: Decimal | null
  }

  export type PredictionSumAggregateOutputType = {
    confidence: Decimal | null
  }

  export type PredictionMinAggregateOutputType = {
    id: string | null
    predictionType: string | null
    predictedIssue: string | null
    predictedTime: Date | null
    confidence: Decimal | null
    proactiveAction: string | null
    actionTaken: boolean | null
    outcome: string | null
    createdAt: Date | null
  }

  export type PredictionMaxAggregateOutputType = {
    id: string | null
    predictionType: string | null
    predictedIssue: string | null
    predictedTime: Date | null
    confidence: Decimal | null
    proactiveAction: string | null
    actionTaken: boolean | null
    outcome: string | null
    createdAt: Date | null
  }

  export type PredictionCountAggregateOutputType = {
    id: number
    predictionType: number
    predictedIssue: number
    predictedTime: number
    confidence: number
    dataPoints: number
    proactiveAction: number
    actionTaken: number
    outcome: number
    createdAt: number
    _all: number
  }


  export type PredictionAvgAggregateInputType = {
    confidence?: true
  }

  export type PredictionSumAggregateInputType = {
    confidence?: true
  }

  export type PredictionMinAggregateInputType = {
    id?: true
    predictionType?: true
    predictedIssue?: true
    predictedTime?: true
    confidence?: true
    proactiveAction?: true
    actionTaken?: true
    outcome?: true
    createdAt?: true
  }

  export type PredictionMaxAggregateInputType = {
    id?: true
    predictionType?: true
    predictedIssue?: true
    predictedTime?: true
    confidence?: true
    proactiveAction?: true
    actionTaken?: true
    outcome?: true
    createdAt?: true
  }

  export type PredictionCountAggregateInputType = {
    id?: true
    predictionType?: true
    predictedIssue?: true
    predictedTime?: true
    confidence?: true
    dataPoints?: true
    proactiveAction?: true
    actionTaken?: true
    outcome?: true
    createdAt?: true
    _all?: true
  }

  export type PredictionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prediction to aggregate.
     */
    where?: PredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Predictions to fetch.
     */
    orderBy?: PredictionOrderByWithRelationInput | PredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Predictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Predictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Predictions
    **/
    _count?: true | PredictionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PredictionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PredictionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PredictionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PredictionMaxAggregateInputType
  }

  export type GetPredictionAggregateType<T extends PredictionAggregateArgs> = {
        [P in keyof T & keyof AggregatePrediction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrediction[P]>
      : GetScalarType<T[P], AggregatePrediction[P]>
  }




  export type PredictionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PredictionWhereInput
    orderBy?: PredictionOrderByWithAggregationInput | PredictionOrderByWithAggregationInput[]
    by: PredictionScalarFieldEnum[] | PredictionScalarFieldEnum
    having?: PredictionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PredictionCountAggregateInputType | true
    _avg?: PredictionAvgAggregateInputType
    _sum?: PredictionSumAggregateInputType
    _min?: PredictionMinAggregateInputType
    _max?: PredictionMaxAggregateInputType
  }

  export type PredictionGroupByOutputType = {
    id: string
    predictionType: string
    predictedIssue: string | null
    predictedTime: Date | null
    confidence: Decimal | null
    dataPoints: JsonValue | null
    proactiveAction: string | null
    actionTaken: boolean
    outcome: string | null
    createdAt: Date
    _count: PredictionCountAggregateOutputType | null
    _avg: PredictionAvgAggregateOutputType | null
    _sum: PredictionSumAggregateOutputType | null
    _min: PredictionMinAggregateOutputType | null
    _max: PredictionMaxAggregateOutputType | null
  }

  type GetPredictionGroupByPayload<T extends PredictionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PredictionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PredictionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PredictionGroupByOutputType[P]>
            : GetScalarType<T[P], PredictionGroupByOutputType[P]>
        }
      >
    >


  export type PredictionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    predictionType?: boolean
    predictedIssue?: boolean
    predictedTime?: boolean
    confidence?: boolean
    dataPoints?: boolean
    proactiveAction?: boolean
    actionTaken?: boolean
    outcome?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["prediction"]>

  export type PredictionSelectScalar = {
    id?: boolean
    predictionType?: boolean
    predictedIssue?: boolean
    predictedTime?: boolean
    confidence?: boolean
    dataPoints?: boolean
    proactiveAction?: boolean
    actionTaken?: boolean
    outcome?: boolean
    createdAt?: boolean
  }


  export type $PredictionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prediction"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      predictionType: string
      predictedIssue: string | null
      predictedTime: Date | null
      confidence: Prisma.Decimal | null
      dataPoints: Prisma.JsonValue | null
      proactiveAction: string | null
      actionTaken: boolean
      outcome: string | null
      createdAt: Date
    }, ExtArgs["result"]["prediction"]>
    composites: {}
  }


  type PredictionGetPayload<S extends boolean | null | undefined | PredictionDefaultArgs> = $Result.GetResult<Prisma.$PredictionPayload, S>

  type PredictionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PredictionFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PredictionCountAggregateInputType | true
    }

  export interface PredictionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prediction'], meta: { name: 'Prediction' } }
    /**
     * Find zero or one Prediction that matches the filter.
     * @param {PredictionFindUniqueArgs} args - Arguments to find a Prediction
     * @example
     * // Get one Prediction
     * const prediction = await prisma.prediction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PredictionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PredictionFindUniqueArgs<ExtArgs>>
    ): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Prediction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PredictionFindUniqueOrThrowArgs} args - Arguments to find a Prediction
     * @example
     * // Get one Prediction
     * const prediction = await prisma.prediction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PredictionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PredictionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Prediction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionFindFirstArgs} args - Arguments to find a Prediction
     * @example
     * // Get one Prediction
     * const prediction = await prisma.prediction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PredictionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PredictionFindFirstArgs<ExtArgs>>
    ): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Prediction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionFindFirstOrThrowArgs} args - Arguments to find a Prediction
     * @example
     * // Get one Prediction
     * const prediction = await prisma.prediction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PredictionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PredictionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Predictions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Predictions
     * const predictions = await prisma.prediction.findMany()
     * 
     * // Get first 10 Predictions
     * const predictions = await prisma.prediction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const predictionWithIdOnly = await prisma.prediction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PredictionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PredictionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Prediction.
     * @param {PredictionCreateArgs} args - Arguments to create a Prediction.
     * @example
     * // Create one Prediction
     * const Prediction = await prisma.prediction.create({
     *   data: {
     *     // ... data to create a Prediction
     *   }
     * })
     * 
    **/
    create<T extends PredictionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PredictionCreateArgs<ExtArgs>>
    ): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Predictions.
     *     @param {PredictionCreateManyArgs} args - Arguments to create many Predictions.
     *     @example
     *     // Create many Predictions
     *     const prediction = await prisma.prediction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PredictionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PredictionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Prediction.
     * @param {PredictionDeleteArgs} args - Arguments to delete one Prediction.
     * @example
     * // Delete one Prediction
     * const Prediction = await prisma.prediction.delete({
     *   where: {
     *     // ... filter to delete one Prediction
     *   }
     * })
     * 
    **/
    delete<T extends PredictionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PredictionDeleteArgs<ExtArgs>>
    ): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Prediction.
     * @param {PredictionUpdateArgs} args - Arguments to update one Prediction.
     * @example
     * // Update one Prediction
     * const prediction = await prisma.prediction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PredictionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PredictionUpdateArgs<ExtArgs>>
    ): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Predictions.
     * @param {PredictionDeleteManyArgs} args - Arguments to filter Predictions to delete.
     * @example
     * // Delete a few Predictions
     * const { count } = await prisma.prediction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PredictionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PredictionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Predictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Predictions
     * const prediction = await prisma.prediction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PredictionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PredictionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prediction.
     * @param {PredictionUpsertArgs} args - Arguments to update or create a Prediction.
     * @example
     * // Update or create a Prediction
     * const prediction = await prisma.prediction.upsert({
     *   create: {
     *     // ... data to create a Prediction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prediction we want to update
     *   }
     * })
    **/
    upsert<T extends PredictionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PredictionUpsertArgs<ExtArgs>>
    ): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Predictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionCountArgs} args - Arguments to filter Predictions to count.
     * @example
     * // Count the number of Predictions
     * const count = await prisma.prediction.count({
     *   where: {
     *     // ... the filter for the Predictions we want to count
     *   }
     * })
    **/
    count<T extends PredictionCountArgs>(
      args?: Subset<T, PredictionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PredictionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prediction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PredictionAggregateArgs>(args: Subset<T, PredictionAggregateArgs>): Prisma.PrismaPromise<GetPredictionAggregateType<T>>

    /**
     * Group by Prediction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PredictionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PredictionGroupByArgs['orderBy'] }
        : { orderBy?: PredictionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PredictionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPredictionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prediction model
   */
  readonly fields: PredictionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prediction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PredictionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Prediction model
   */ 
  interface PredictionFieldRefs {
    readonly id: FieldRef<"Prediction", 'String'>
    readonly predictionType: FieldRef<"Prediction", 'String'>
    readonly predictedIssue: FieldRef<"Prediction", 'String'>
    readonly predictedTime: FieldRef<"Prediction", 'DateTime'>
    readonly confidence: FieldRef<"Prediction", 'Decimal'>
    readonly dataPoints: FieldRef<"Prediction", 'Json'>
    readonly proactiveAction: FieldRef<"Prediction", 'String'>
    readonly actionTaken: FieldRef<"Prediction", 'Boolean'>
    readonly outcome: FieldRef<"Prediction", 'String'>
    readonly createdAt: FieldRef<"Prediction", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Prediction findUnique
   */
  export type PredictionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Filter, which Prediction to fetch.
     */
    where: PredictionWhereUniqueInput
  }


  /**
   * Prediction findUniqueOrThrow
   */
  export type PredictionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Filter, which Prediction to fetch.
     */
    where: PredictionWhereUniqueInput
  }


  /**
   * Prediction findFirst
   */
  export type PredictionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Filter, which Prediction to fetch.
     */
    where?: PredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Predictions to fetch.
     */
    orderBy?: PredictionOrderByWithRelationInput | PredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Predictions.
     */
    cursor?: PredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Predictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Predictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Predictions.
     */
    distinct?: PredictionScalarFieldEnum | PredictionScalarFieldEnum[]
  }


  /**
   * Prediction findFirstOrThrow
   */
  export type PredictionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Filter, which Prediction to fetch.
     */
    where?: PredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Predictions to fetch.
     */
    orderBy?: PredictionOrderByWithRelationInput | PredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Predictions.
     */
    cursor?: PredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Predictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Predictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Predictions.
     */
    distinct?: PredictionScalarFieldEnum | PredictionScalarFieldEnum[]
  }


  /**
   * Prediction findMany
   */
  export type PredictionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Filter, which Predictions to fetch.
     */
    where?: PredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Predictions to fetch.
     */
    orderBy?: PredictionOrderByWithRelationInput | PredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Predictions.
     */
    cursor?: PredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Predictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Predictions.
     */
    skip?: number
    distinct?: PredictionScalarFieldEnum | PredictionScalarFieldEnum[]
  }


  /**
   * Prediction create
   */
  export type PredictionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * The data needed to create a Prediction.
     */
    data: XOR<PredictionCreateInput, PredictionUncheckedCreateInput>
  }


  /**
   * Prediction createMany
   */
  export type PredictionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Predictions.
     */
    data: PredictionCreateManyInput | PredictionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Prediction update
   */
  export type PredictionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * The data needed to update a Prediction.
     */
    data: XOR<PredictionUpdateInput, PredictionUncheckedUpdateInput>
    /**
     * Choose, which Prediction to update.
     */
    where: PredictionWhereUniqueInput
  }


  /**
   * Prediction updateMany
   */
  export type PredictionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Predictions.
     */
    data: XOR<PredictionUpdateManyMutationInput, PredictionUncheckedUpdateManyInput>
    /**
     * Filter which Predictions to update
     */
    where?: PredictionWhereInput
  }


  /**
   * Prediction upsert
   */
  export type PredictionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * The filter to search for the Prediction to update in case it exists.
     */
    where: PredictionWhereUniqueInput
    /**
     * In case the Prediction found by the `where` argument doesn't exist, create a new Prediction with this data.
     */
    create: XOR<PredictionCreateInput, PredictionUncheckedCreateInput>
    /**
     * In case the Prediction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PredictionUpdateInput, PredictionUncheckedUpdateInput>
  }


  /**
   * Prediction delete
   */
  export type PredictionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Filter which Prediction to delete.
     */
    where: PredictionWhereUniqueInput
  }


  /**
   * Prediction deleteMany
   */
  export type PredictionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Predictions to delete
     */
    where?: PredictionWhereInput
  }


  /**
   * Prediction without action
   */
  export type PredictionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
  }



  /**
   * Model SecurityIncident
   */

  export type AggregateSecurityIncident = {
    _count: SecurityIncidentCountAggregateOutputType | null
    _min: SecurityIncidentMinAggregateOutputType | null
    _max: SecurityIncidentMaxAggregateOutputType | null
  }

  export type SecurityIncidentMinAggregateOutputType = {
    id: string | null
    threatType: string | null
    severity: string | null
    sourceIp: string | null
    targetEndpoint: string | null
    payload: string | null
    userId: string | null
    mitigationAction: string | null
    blocked: boolean | null
    createdAt: Date | null
  }

  export type SecurityIncidentMaxAggregateOutputType = {
    id: string | null
    threatType: string | null
    severity: string | null
    sourceIp: string | null
    targetEndpoint: string | null
    payload: string | null
    userId: string | null
    mitigationAction: string | null
    blocked: boolean | null
    createdAt: Date | null
  }

  export type SecurityIncidentCountAggregateOutputType = {
    id: number
    threatType: number
    severity: number
    sourceIp: number
    targetEndpoint: number
    payload: number
    userId: number
    mitigationAction: number
    blocked: number
    createdAt: number
    _all: number
  }


  export type SecurityIncidentMinAggregateInputType = {
    id?: true
    threatType?: true
    severity?: true
    sourceIp?: true
    targetEndpoint?: true
    payload?: true
    userId?: true
    mitigationAction?: true
    blocked?: true
    createdAt?: true
  }

  export type SecurityIncidentMaxAggregateInputType = {
    id?: true
    threatType?: true
    severity?: true
    sourceIp?: true
    targetEndpoint?: true
    payload?: true
    userId?: true
    mitigationAction?: true
    blocked?: true
    createdAt?: true
  }

  export type SecurityIncidentCountAggregateInputType = {
    id?: true
    threatType?: true
    severity?: true
    sourceIp?: true
    targetEndpoint?: true
    payload?: true
    userId?: true
    mitigationAction?: true
    blocked?: true
    createdAt?: true
    _all?: true
  }

  export type SecurityIncidentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityIncident to aggregate.
     */
    where?: SecurityIncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityIncidents to fetch.
     */
    orderBy?: SecurityIncidentOrderByWithRelationInput | SecurityIncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecurityIncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityIncidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityIncidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityIncidents
    **/
    _count?: true | SecurityIncidentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityIncidentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityIncidentMaxAggregateInputType
  }

  export type GetSecurityIncidentAggregateType<T extends SecurityIncidentAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityIncident]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityIncident[P]>
      : GetScalarType<T[P], AggregateSecurityIncident[P]>
  }




  export type SecurityIncidentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityIncidentWhereInput
    orderBy?: SecurityIncidentOrderByWithAggregationInput | SecurityIncidentOrderByWithAggregationInput[]
    by: SecurityIncidentScalarFieldEnum[] | SecurityIncidentScalarFieldEnum
    having?: SecurityIncidentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityIncidentCountAggregateInputType | true
    _min?: SecurityIncidentMinAggregateInputType
    _max?: SecurityIncidentMaxAggregateInputType
  }

  export type SecurityIncidentGroupByOutputType = {
    id: string
    threatType: string
    severity: string | null
    sourceIp: string | null
    targetEndpoint: string | null
    payload: string | null
    userId: string | null
    mitigationAction: string | null
    blocked: boolean
    createdAt: Date
    _count: SecurityIncidentCountAggregateOutputType | null
    _min: SecurityIncidentMinAggregateOutputType | null
    _max: SecurityIncidentMaxAggregateOutputType | null
  }

  type GetSecurityIncidentGroupByPayload<T extends SecurityIncidentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecurityIncidentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityIncidentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityIncidentGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityIncidentGroupByOutputType[P]>
        }
      >
    >


  export type SecurityIncidentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threatType?: boolean
    severity?: boolean
    sourceIp?: boolean
    targetEndpoint?: boolean
    payload?: boolean
    userId?: boolean
    mitigationAction?: boolean
    blocked?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["securityIncident"]>

  export type SecurityIncidentSelectScalar = {
    id?: boolean
    threatType?: boolean
    severity?: boolean
    sourceIp?: boolean
    targetEndpoint?: boolean
    payload?: boolean
    userId?: boolean
    mitigationAction?: boolean
    blocked?: boolean
    createdAt?: boolean
  }


  export type $SecurityIncidentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecurityIncident"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      threatType: string
      severity: string | null
      sourceIp: string | null
      targetEndpoint: string | null
      payload: string | null
      userId: string | null
      mitigationAction: string | null
      blocked: boolean
      createdAt: Date
    }, ExtArgs["result"]["securityIncident"]>
    composites: {}
  }


  type SecurityIncidentGetPayload<S extends boolean | null | undefined | SecurityIncidentDefaultArgs> = $Result.GetResult<Prisma.$SecurityIncidentPayload, S>

  type SecurityIncidentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SecurityIncidentFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SecurityIncidentCountAggregateInputType | true
    }

  export interface SecurityIncidentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecurityIncident'], meta: { name: 'SecurityIncident' } }
    /**
     * Find zero or one SecurityIncident that matches the filter.
     * @param {SecurityIncidentFindUniqueArgs} args - Arguments to find a SecurityIncident
     * @example
     * // Get one SecurityIncident
     * const securityIncident = await prisma.securityIncident.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SecurityIncidentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SecurityIncidentFindUniqueArgs<ExtArgs>>
    ): Prisma__SecurityIncidentClient<$Result.GetResult<Prisma.$SecurityIncidentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SecurityIncident that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SecurityIncidentFindUniqueOrThrowArgs} args - Arguments to find a SecurityIncident
     * @example
     * // Get one SecurityIncident
     * const securityIncident = await prisma.securityIncident.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SecurityIncidentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SecurityIncidentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SecurityIncidentClient<$Result.GetResult<Prisma.$SecurityIncidentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SecurityIncident that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityIncidentFindFirstArgs} args - Arguments to find a SecurityIncident
     * @example
     * // Get one SecurityIncident
     * const securityIncident = await prisma.securityIncident.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SecurityIncidentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SecurityIncidentFindFirstArgs<ExtArgs>>
    ): Prisma__SecurityIncidentClient<$Result.GetResult<Prisma.$SecurityIncidentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SecurityIncident that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityIncidentFindFirstOrThrowArgs} args - Arguments to find a SecurityIncident
     * @example
     * // Get one SecurityIncident
     * const securityIncident = await prisma.securityIncident.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SecurityIncidentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SecurityIncidentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SecurityIncidentClient<$Result.GetResult<Prisma.$SecurityIncidentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SecurityIncidents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityIncidentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityIncidents
     * const securityIncidents = await prisma.securityIncident.findMany()
     * 
     * // Get first 10 SecurityIncidents
     * const securityIncidents = await prisma.securityIncident.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityIncidentWithIdOnly = await prisma.securityIncident.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SecurityIncidentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SecurityIncidentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityIncidentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SecurityIncident.
     * @param {SecurityIncidentCreateArgs} args - Arguments to create a SecurityIncident.
     * @example
     * // Create one SecurityIncident
     * const SecurityIncident = await prisma.securityIncident.create({
     *   data: {
     *     // ... data to create a SecurityIncident
     *   }
     * })
     * 
    **/
    create<T extends SecurityIncidentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SecurityIncidentCreateArgs<ExtArgs>>
    ): Prisma__SecurityIncidentClient<$Result.GetResult<Prisma.$SecurityIncidentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SecurityIncidents.
     *     @param {SecurityIncidentCreateManyArgs} args - Arguments to create many SecurityIncidents.
     *     @example
     *     // Create many SecurityIncidents
     *     const securityIncident = await prisma.securityIncident.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SecurityIncidentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SecurityIncidentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SecurityIncident.
     * @param {SecurityIncidentDeleteArgs} args - Arguments to delete one SecurityIncident.
     * @example
     * // Delete one SecurityIncident
     * const SecurityIncident = await prisma.securityIncident.delete({
     *   where: {
     *     // ... filter to delete one SecurityIncident
     *   }
     * })
     * 
    **/
    delete<T extends SecurityIncidentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SecurityIncidentDeleteArgs<ExtArgs>>
    ): Prisma__SecurityIncidentClient<$Result.GetResult<Prisma.$SecurityIncidentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SecurityIncident.
     * @param {SecurityIncidentUpdateArgs} args - Arguments to update one SecurityIncident.
     * @example
     * // Update one SecurityIncident
     * const securityIncident = await prisma.securityIncident.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SecurityIncidentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SecurityIncidentUpdateArgs<ExtArgs>>
    ): Prisma__SecurityIncidentClient<$Result.GetResult<Prisma.$SecurityIncidentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SecurityIncidents.
     * @param {SecurityIncidentDeleteManyArgs} args - Arguments to filter SecurityIncidents to delete.
     * @example
     * // Delete a few SecurityIncidents
     * const { count } = await prisma.securityIncident.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SecurityIncidentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SecurityIncidentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityIncidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityIncidentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityIncidents
     * const securityIncident = await prisma.securityIncident.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SecurityIncidentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SecurityIncidentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SecurityIncident.
     * @param {SecurityIncidentUpsertArgs} args - Arguments to update or create a SecurityIncident.
     * @example
     * // Update or create a SecurityIncident
     * const securityIncident = await prisma.securityIncident.upsert({
     *   create: {
     *     // ... data to create a SecurityIncident
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityIncident we want to update
     *   }
     * })
    **/
    upsert<T extends SecurityIncidentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SecurityIncidentUpsertArgs<ExtArgs>>
    ): Prisma__SecurityIncidentClient<$Result.GetResult<Prisma.$SecurityIncidentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SecurityIncidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityIncidentCountArgs} args - Arguments to filter SecurityIncidents to count.
     * @example
     * // Count the number of SecurityIncidents
     * const count = await prisma.securityIncident.count({
     *   where: {
     *     // ... the filter for the SecurityIncidents we want to count
     *   }
     * })
    **/
    count<T extends SecurityIncidentCountArgs>(
      args?: Subset<T, SecurityIncidentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityIncidentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityIncident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityIncidentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityIncidentAggregateArgs>(args: Subset<T, SecurityIncidentAggregateArgs>): Prisma.PrismaPromise<GetSecurityIncidentAggregateType<T>>

    /**
     * Group by SecurityIncident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityIncidentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityIncidentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityIncidentGroupByArgs['orderBy'] }
        : { orderBy?: SecurityIncidentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityIncidentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityIncidentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecurityIncident model
   */
  readonly fields: SecurityIncidentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityIncident.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecurityIncidentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SecurityIncident model
   */ 
  interface SecurityIncidentFieldRefs {
    readonly id: FieldRef<"SecurityIncident", 'String'>
    readonly threatType: FieldRef<"SecurityIncident", 'String'>
    readonly severity: FieldRef<"SecurityIncident", 'String'>
    readonly sourceIp: FieldRef<"SecurityIncident", 'String'>
    readonly targetEndpoint: FieldRef<"SecurityIncident", 'String'>
    readonly payload: FieldRef<"SecurityIncident", 'String'>
    readonly userId: FieldRef<"SecurityIncident", 'String'>
    readonly mitigationAction: FieldRef<"SecurityIncident", 'String'>
    readonly blocked: FieldRef<"SecurityIncident", 'Boolean'>
    readonly createdAt: FieldRef<"SecurityIncident", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * SecurityIncident findUnique
   */
  export type SecurityIncidentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityIncident
     */
    select?: SecurityIncidentSelect<ExtArgs> | null
    /**
     * Filter, which SecurityIncident to fetch.
     */
    where: SecurityIncidentWhereUniqueInput
  }


  /**
   * SecurityIncident findUniqueOrThrow
   */
  export type SecurityIncidentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityIncident
     */
    select?: SecurityIncidentSelect<ExtArgs> | null
    /**
     * Filter, which SecurityIncident to fetch.
     */
    where: SecurityIncidentWhereUniqueInput
  }


  /**
   * SecurityIncident findFirst
   */
  export type SecurityIncidentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityIncident
     */
    select?: SecurityIncidentSelect<ExtArgs> | null
    /**
     * Filter, which SecurityIncident to fetch.
     */
    where?: SecurityIncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityIncidents to fetch.
     */
    orderBy?: SecurityIncidentOrderByWithRelationInput | SecurityIncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityIncidents.
     */
    cursor?: SecurityIncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityIncidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityIncidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityIncidents.
     */
    distinct?: SecurityIncidentScalarFieldEnum | SecurityIncidentScalarFieldEnum[]
  }


  /**
   * SecurityIncident findFirstOrThrow
   */
  export type SecurityIncidentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityIncident
     */
    select?: SecurityIncidentSelect<ExtArgs> | null
    /**
     * Filter, which SecurityIncident to fetch.
     */
    where?: SecurityIncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityIncidents to fetch.
     */
    orderBy?: SecurityIncidentOrderByWithRelationInput | SecurityIncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityIncidents.
     */
    cursor?: SecurityIncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityIncidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityIncidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityIncidents.
     */
    distinct?: SecurityIncidentScalarFieldEnum | SecurityIncidentScalarFieldEnum[]
  }


  /**
   * SecurityIncident findMany
   */
  export type SecurityIncidentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityIncident
     */
    select?: SecurityIncidentSelect<ExtArgs> | null
    /**
     * Filter, which SecurityIncidents to fetch.
     */
    where?: SecurityIncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityIncidents to fetch.
     */
    orderBy?: SecurityIncidentOrderByWithRelationInput | SecurityIncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityIncidents.
     */
    cursor?: SecurityIncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityIncidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityIncidents.
     */
    skip?: number
    distinct?: SecurityIncidentScalarFieldEnum | SecurityIncidentScalarFieldEnum[]
  }


  /**
   * SecurityIncident create
   */
  export type SecurityIncidentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityIncident
     */
    select?: SecurityIncidentSelect<ExtArgs> | null
    /**
     * The data needed to create a SecurityIncident.
     */
    data: XOR<SecurityIncidentCreateInput, SecurityIncidentUncheckedCreateInput>
  }


  /**
   * SecurityIncident createMany
   */
  export type SecurityIncidentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecurityIncidents.
     */
    data: SecurityIncidentCreateManyInput | SecurityIncidentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SecurityIncident update
   */
  export type SecurityIncidentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityIncident
     */
    select?: SecurityIncidentSelect<ExtArgs> | null
    /**
     * The data needed to update a SecurityIncident.
     */
    data: XOR<SecurityIncidentUpdateInput, SecurityIncidentUncheckedUpdateInput>
    /**
     * Choose, which SecurityIncident to update.
     */
    where: SecurityIncidentWhereUniqueInput
  }


  /**
   * SecurityIncident updateMany
   */
  export type SecurityIncidentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecurityIncidents.
     */
    data: XOR<SecurityIncidentUpdateManyMutationInput, SecurityIncidentUncheckedUpdateManyInput>
    /**
     * Filter which SecurityIncidents to update
     */
    where?: SecurityIncidentWhereInput
  }


  /**
   * SecurityIncident upsert
   */
  export type SecurityIncidentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityIncident
     */
    select?: SecurityIncidentSelect<ExtArgs> | null
    /**
     * The filter to search for the SecurityIncident to update in case it exists.
     */
    where: SecurityIncidentWhereUniqueInput
    /**
     * In case the SecurityIncident found by the `where` argument doesn't exist, create a new SecurityIncident with this data.
     */
    create: XOR<SecurityIncidentCreateInput, SecurityIncidentUncheckedCreateInput>
    /**
     * In case the SecurityIncident was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecurityIncidentUpdateInput, SecurityIncidentUncheckedUpdateInput>
  }


  /**
   * SecurityIncident delete
   */
  export type SecurityIncidentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityIncident
     */
    select?: SecurityIncidentSelect<ExtArgs> | null
    /**
     * Filter which SecurityIncident to delete.
     */
    where: SecurityIncidentWhereUniqueInput
  }


  /**
   * SecurityIncident deleteMany
   */
  export type SecurityIncidentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityIncidents to delete
     */
    where?: SecurityIncidentWhereInput
  }


  /**
   * SecurityIncident without action
   */
  export type SecurityIncidentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityIncident
     */
    select?: SecurityIncidentSelect<ExtArgs> | null
  }



  /**
   * Model PerformanceMetric
   */

  export type AggregatePerformanceMetric = {
    _count: PerformanceMetricCountAggregateOutputType | null
    _avg: PerformanceMetricAvgAggregateOutputType | null
    _sum: PerformanceMetricSumAggregateOutputType | null
    _min: PerformanceMetricMinAggregateOutputType | null
    _max: PerformanceMetricMaxAggregateOutputType | null
  }

  export type PerformanceMetricAvgAggregateOutputType = {
    valueMs: Decimal | null
    percentile95: Decimal | null
    percentile99: Decimal | null
    sampleCount: number | null
    improvementPercent: Decimal | null
  }

  export type PerformanceMetricSumAggregateOutputType = {
    valueMs: Decimal | null
    percentile95: Decimal | null
    percentile99: Decimal | null
    sampleCount: number | null
    improvementPercent: Decimal | null
  }

  export type PerformanceMetricMinAggregateOutputType = {
    id: string | null
    metricType: string | null
    endpoint: string | null
    queryHash: string | null
    valueMs: Decimal | null
    percentile95: Decimal | null
    percentile99: Decimal | null
    sampleCount: number | null
    optimizationApplied: string | null
    improvementPercent: Decimal | null
    createdAt: Date | null
  }

  export type PerformanceMetricMaxAggregateOutputType = {
    id: string | null
    metricType: string | null
    endpoint: string | null
    queryHash: string | null
    valueMs: Decimal | null
    percentile95: Decimal | null
    percentile99: Decimal | null
    sampleCount: number | null
    optimizationApplied: string | null
    improvementPercent: Decimal | null
    createdAt: Date | null
  }

  export type PerformanceMetricCountAggregateOutputType = {
    id: number
    metricType: number
    endpoint: number
    queryHash: number
    valueMs: number
    percentile95: number
    percentile99: number
    sampleCount: number
    optimizationApplied: number
    improvementPercent: number
    createdAt: number
    _all: number
  }


  export type PerformanceMetricAvgAggregateInputType = {
    valueMs?: true
    percentile95?: true
    percentile99?: true
    sampleCount?: true
    improvementPercent?: true
  }

  export type PerformanceMetricSumAggregateInputType = {
    valueMs?: true
    percentile95?: true
    percentile99?: true
    sampleCount?: true
    improvementPercent?: true
  }

  export type PerformanceMetricMinAggregateInputType = {
    id?: true
    metricType?: true
    endpoint?: true
    queryHash?: true
    valueMs?: true
    percentile95?: true
    percentile99?: true
    sampleCount?: true
    optimizationApplied?: true
    improvementPercent?: true
    createdAt?: true
  }

  export type PerformanceMetricMaxAggregateInputType = {
    id?: true
    metricType?: true
    endpoint?: true
    queryHash?: true
    valueMs?: true
    percentile95?: true
    percentile99?: true
    sampleCount?: true
    optimizationApplied?: true
    improvementPercent?: true
    createdAt?: true
  }

  export type PerformanceMetricCountAggregateInputType = {
    id?: true
    metricType?: true
    endpoint?: true
    queryHash?: true
    valueMs?: true
    percentile95?: true
    percentile99?: true
    sampleCount?: true
    optimizationApplied?: true
    improvementPercent?: true
    createdAt?: true
    _all?: true
  }

  export type PerformanceMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceMetric to aggregate.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformanceMetrics
    **/
    _count?: true | PerformanceMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceMetricMaxAggregateInputType
  }

  export type GetPerformanceMetricAggregateType<T extends PerformanceMetricAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformanceMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformanceMetric[P]>
      : GetScalarType<T[P], AggregatePerformanceMetric[P]>
  }




  export type PerformanceMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceMetricWhereInput
    orderBy?: PerformanceMetricOrderByWithAggregationInput | PerformanceMetricOrderByWithAggregationInput[]
    by: PerformanceMetricScalarFieldEnum[] | PerformanceMetricScalarFieldEnum
    having?: PerformanceMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceMetricCountAggregateInputType | true
    _avg?: PerformanceMetricAvgAggregateInputType
    _sum?: PerformanceMetricSumAggregateInputType
    _min?: PerformanceMetricMinAggregateInputType
    _max?: PerformanceMetricMaxAggregateInputType
  }

  export type PerformanceMetricGroupByOutputType = {
    id: string
    metricType: string
    endpoint: string | null
    queryHash: string | null
    valueMs: Decimal | null
    percentile95: Decimal | null
    percentile99: Decimal | null
    sampleCount: number | null
    optimizationApplied: string | null
    improvementPercent: Decimal | null
    createdAt: Date
    _count: PerformanceMetricCountAggregateOutputType | null
    _avg: PerformanceMetricAvgAggregateOutputType | null
    _sum: PerformanceMetricSumAggregateOutputType | null
    _min: PerformanceMetricMinAggregateOutputType | null
    _max: PerformanceMetricMaxAggregateOutputType | null
  }

  type GetPerformanceMetricGroupByPayload<T extends PerformanceMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceMetricGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceMetricGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metricType?: boolean
    endpoint?: boolean
    queryHash?: boolean
    valueMs?: boolean
    percentile95?: boolean
    percentile99?: boolean
    sampleCount?: boolean
    optimizationApplied?: boolean
    improvementPercent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["performanceMetric"]>

  export type PerformanceMetricSelectScalar = {
    id?: boolean
    metricType?: boolean
    endpoint?: boolean
    queryHash?: boolean
    valueMs?: boolean
    percentile95?: boolean
    percentile99?: boolean
    sampleCount?: boolean
    optimizationApplied?: boolean
    improvementPercent?: boolean
    createdAt?: boolean
  }


  export type $PerformanceMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerformanceMetric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      metricType: string
      endpoint: string | null
      queryHash: string | null
      valueMs: Prisma.Decimal | null
      percentile95: Prisma.Decimal | null
      percentile99: Prisma.Decimal | null
      sampleCount: number | null
      optimizationApplied: string | null
      improvementPercent: Prisma.Decimal | null
      createdAt: Date
    }, ExtArgs["result"]["performanceMetric"]>
    composites: {}
  }


  type PerformanceMetricGetPayload<S extends boolean | null | undefined | PerformanceMetricDefaultArgs> = $Result.GetResult<Prisma.$PerformanceMetricPayload, S>

  type PerformanceMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PerformanceMetricFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PerformanceMetricCountAggregateInputType | true
    }

  export interface PerformanceMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerformanceMetric'], meta: { name: 'PerformanceMetric' } }
    /**
     * Find zero or one PerformanceMetric that matches the filter.
     * @param {PerformanceMetricFindUniqueArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PerformanceMetricFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PerformanceMetricFindUniqueArgs<ExtArgs>>
    ): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PerformanceMetric that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PerformanceMetricFindUniqueOrThrowArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PerformanceMetricFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PerformanceMetricFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PerformanceMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricFindFirstArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PerformanceMetricFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PerformanceMetricFindFirstArgs<ExtArgs>>
    ): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PerformanceMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricFindFirstOrThrowArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PerformanceMetricFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PerformanceMetricFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PerformanceMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformanceMetrics
     * const performanceMetrics = await prisma.performanceMetric.findMany()
     * 
     * // Get first 10 PerformanceMetrics
     * const performanceMetrics = await prisma.performanceMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceMetricWithIdOnly = await prisma.performanceMetric.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PerformanceMetricFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PerformanceMetricFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PerformanceMetric.
     * @param {PerformanceMetricCreateArgs} args - Arguments to create a PerformanceMetric.
     * @example
     * // Create one PerformanceMetric
     * const PerformanceMetric = await prisma.performanceMetric.create({
     *   data: {
     *     // ... data to create a PerformanceMetric
     *   }
     * })
     * 
    **/
    create<T extends PerformanceMetricCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PerformanceMetricCreateArgs<ExtArgs>>
    ): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PerformanceMetrics.
     *     @param {PerformanceMetricCreateManyArgs} args - Arguments to create many PerformanceMetrics.
     *     @example
     *     // Create many PerformanceMetrics
     *     const performanceMetric = await prisma.performanceMetric.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PerformanceMetricCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PerformanceMetricCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PerformanceMetric.
     * @param {PerformanceMetricDeleteArgs} args - Arguments to delete one PerformanceMetric.
     * @example
     * // Delete one PerformanceMetric
     * const PerformanceMetric = await prisma.performanceMetric.delete({
     *   where: {
     *     // ... filter to delete one PerformanceMetric
     *   }
     * })
     * 
    **/
    delete<T extends PerformanceMetricDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PerformanceMetricDeleteArgs<ExtArgs>>
    ): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PerformanceMetric.
     * @param {PerformanceMetricUpdateArgs} args - Arguments to update one PerformanceMetric.
     * @example
     * // Update one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PerformanceMetricUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PerformanceMetricUpdateArgs<ExtArgs>>
    ): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PerformanceMetrics.
     * @param {PerformanceMetricDeleteManyArgs} args - Arguments to filter PerformanceMetrics to delete.
     * @example
     * // Delete a few PerformanceMetrics
     * const { count } = await prisma.performanceMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PerformanceMetricDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PerformanceMetricDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformanceMetrics
     * const performanceMetric = await prisma.performanceMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PerformanceMetricUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PerformanceMetricUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PerformanceMetric.
     * @param {PerformanceMetricUpsertArgs} args - Arguments to update or create a PerformanceMetric.
     * @example
     * // Update or create a PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.upsert({
     *   create: {
     *     // ... data to create a PerformanceMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformanceMetric we want to update
     *   }
     * })
    **/
    upsert<T extends PerformanceMetricUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PerformanceMetricUpsertArgs<ExtArgs>>
    ): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PerformanceMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricCountArgs} args - Arguments to filter PerformanceMetrics to count.
     * @example
     * // Count the number of PerformanceMetrics
     * const count = await prisma.performanceMetric.count({
     *   where: {
     *     // ... the filter for the PerformanceMetrics we want to count
     *   }
     * })
    **/
    count<T extends PerformanceMetricCountArgs>(
      args?: Subset<T, PerformanceMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformanceMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceMetricAggregateArgs>(args: Subset<T, PerformanceMetricAggregateArgs>): Prisma.PrismaPromise<GetPerformanceMetricAggregateType<T>>

    /**
     * Group by PerformanceMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceMetricGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerformanceMetric model
   */
  readonly fields: PerformanceMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformanceMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformanceMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PerformanceMetric model
   */ 
  interface PerformanceMetricFieldRefs {
    readonly id: FieldRef<"PerformanceMetric", 'String'>
    readonly metricType: FieldRef<"PerformanceMetric", 'String'>
    readonly endpoint: FieldRef<"PerformanceMetric", 'String'>
    readonly queryHash: FieldRef<"PerformanceMetric", 'String'>
    readonly valueMs: FieldRef<"PerformanceMetric", 'Decimal'>
    readonly percentile95: FieldRef<"PerformanceMetric", 'Decimal'>
    readonly percentile99: FieldRef<"PerformanceMetric", 'Decimal'>
    readonly sampleCount: FieldRef<"PerformanceMetric", 'Int'>
    readonly optimizationApplied: FieldRef<"PerformanceMetric", 'String'>
    readonly improvementPercent: FieldRef<"PerformanceMetric", 'Decimal'>
    readonly createdAt: FieldRef<"PerformanceMetric", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * PerformanceMetric findUnique
   */
  export type PerformanceMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where: PerformanceMetricWhereUniqueInput
  }


  /**
   * PerformanceMetric findUniqueOrThrow
   */
  export type PerformanceMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where: PerformanceMetricWhereUniqueInput
  }


  /**
   * PerformanceMetric findFirst
   */
  export type PerformanceMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceMetrics.
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceMetrics.
     */
    distinct?: PerformanceMetricScalarFieldEnum | PerformanceMetricScalarFieldEnum[]
  }


  /**
   * PerformanceMetric findFirstOrThrow
   */
  export type PerformanceMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceMetrics.
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceMetrics.
     */
    distinct?: PerformanceMetricScalarFieldEnum | PerformanceMetricScalarFieldEnum[]
  }


  /**
   * PerformanceMetric findMany
   */
  export type PerformanceMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Filter, which PerformanceMetrics to fetch.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformanceMetrics.
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    distinct?: PerformanceMetricScalarFieldEnum | PerformanceMetricScalarFieldEnum[]
  }


  /**
   * PerformanceMetric create
   */
  export type PerformanceMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * The data needed to create a PerformanceMetric.
     */
    data: XOR<PerformanceMetricCreateInput, PerformanceMetricUncheckedCreateInput>
  }


  /**
   * PerformanceMetric createMany
   */
  export type PerformanceMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerformanceMetrics.
     */
    data: PerformanceMetricCreateManyInput | PerformanceMetricCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PerformanceMetric update
   */
  export type PerformanceMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * The data needed to update a PerformanceMetric.
     */
    data: XOR<PerformanceMetricUpdateInput, PerformanceMetricUncheckedUpdateInput>
    /**
     * Choose, which PerformanceMetric to update.
     */
    where: PerformanceMetricWhereUniqueInput
  }


  /**
   * PerformanceMetric updateMany
   */
  export type PerformanceMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerformanceMetrics.
     */
    data: XOR<PerformanceMetricUpdateManyMutationInput, PerformanceMetricUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceMetrics to update
     */
    where?: PerformanceMetricWhereInput
  }


  /**
   * PerformanceMetric upsert
   */
  export type PerformanceMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * The filter to search for the PerformanceMetric to update in case it exists.
     */
    where: PerformanceMetricWhereUniqueInput
    /**
     * In case the PerformanceMetric found by the `where` argument doesn't exist, create a new PerformanceMetric with this data.
     */
    create: XOR<PerformanceMetricCreateInput, PerformanceMetricUncheckedCreateInput>
    /**
     * In case the PerformanceMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformanceMetricUpdateInput, PerformanceMetricUncheckedUpdateInput>
  }


  /**
   * PerformanceMetric delete
   */
  export type PerformanceMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Filter which PerformanceMetric to delete.
     */
    where: PerformanceMetricWhereUniqueInput
  }


  /**
   * PerformanceMetric deleteMany
   */
  export type PerformanceMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceMetrics to delete
     */
    where?: PerformanceMetricWhereInput
  }


  /**
   * PerformanceMetric without action
   */
  export type PerformanceMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
  }



  /**
   * Model SystemAlert
   */

  export type AggregateSystemAlert = {
    _count: SystemAlertCountAggregateOutputType | null
    _avg: SystemAlertAvgAggregateOutputType | null
    _sum: SystemAlertSumAggregateOutputType | null
    _min: SystemAlertMinAggregateOutputType | null
    _max: SystemAlertMaxAggregateOutputType | null
  }

  export type SystemAlertAvgAggregateOutputType = {
    thresholdValue: Decimal | null
    actualValue: Decimal | null
  }

  export type SystemAlertSumAggregateOutputType = {
    thresholdValue: Decimal | null
    actualValue: Decimal | null
  }

  export type SystemAlertMinAggregateOutputType = {
    id: string | null
    alertType: string | null
    component: string | null
    message: string | null
    severity: string | null
    thresholdValue: Decimal | null
    actualValue: Decimal | null
    acknowledged: boolean | null
    acknowledgedBy: string | null
    resolved: boolean | null
    resolvedAt: Date | null
    autoResolved: boolean | null
    createdAt: Date | null
  }

  export type SystemAlertMaxAggregateOutputType = {
    id: string | null
    alertType: string | null
    component: string | null
    message: string | null
    severity: string | null
    thresholdValue: Decimal | null
    actualValue: Decimal | null
    acknowledged: boolean | null
    acknowledgedBy: string | null
    resolved: boolean | null
    resolvedAt: Date | null
    autoResolved: boolean | null
    createdAt: Date | null
  }

  export type SystemAlertCountAggregateOutputType = {
    id: number
    alertType: number
    component: number
    message: number
    severity: number
    thresholdValue: number
    actualValue: number
    acknowledged: number
    acknowledgedBy: number
    resolved: number
    resolvedAt: number
    autoResolved: number
    createdAt: number
    _all: number
  }


  export type SystemAlertAvgAggregateInputType = {
    thresholdValue?: true
    actualValue?: true
  }

  export type SystemAlertSumAggregateInputType = {
    thresholdValue?: true
    actualValue?: true
  }

  export type SystemAlertMinAggregateInputType = {
    id?: true
    alertType?: true
    component?: true
    message?: true
    severity?: true
    thresholdValue?: true
    actualValue?: true
    acknowledged?: true
    acknowledgedBy?: true
    resolved?: true
    resolvedAt?: true
    autoResolved?: true
    createdAt?: true
  }

  export type SystemAlertMaxAggregateInputType = {
    id?: true
    alertType?: true
    component?: true
    message?: true
    severity?: true
    thresholdValue?: true
    actualValue?: true
    acknowledged?: true
    acknowledgedBy?: true
    resolved?: true
    resolvedAt?: true
    autoResolved?: true
    createdAt?: true
  }

  export type SystemAlertCountAggregateInputType = {
    id?: true
    alertType?: true
    component?: true
    message?: true
    severity?: true
    thresholdValue?: true
    actualValue?: true
    acknowledged?: true
    acknowledgedBy?: true
    resolved?: true
    resolvedAt?: true
    autoResolved?: true
    createdAt?: true
    _all?: true
  }

  export type SystemAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemAlert to aggregate.
     */
    where?: SystemAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemAlerts to fetch.
     */
    orderBy?: SystemAlertOrderByWithRelationInput | SystemAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemAlerts
    **/
    _count?: true | SystemAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemAlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemAlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemAlertMaxAggregateInputType
  }

  export type GetSystemAlertAggregateType<T extends SystemAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemAlert[P]>
      : GetScalarType<T[P], AggregateSystemAlert[P]>
  }




  export type SystemAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemAlertWhereInput
    orderBy?: SystemAlertOrderByWithAggregationInput | SystemAlertOrderByWithAggregationInput[]
    by: SystemAlertScalarFieldEnum[] | SystemAlertScalarFieldEnum
    having?: SystemAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemAlertCountAggregateInputType | true
    _avg?: SystemAlertAvgAggregateInputType
    _sum?: SystemAlertSumAggregateInputType
    _min?: SystemAlertMinAggregateInputType
    _max?: SystemAlertMaxAggregateInputType
  }

  export type SystemAlertGroupByOutputType = {
    id: string
    alertType: string
    component: string | null
    message: string | null
    severity: string | null
    thresholdValue: Decimal | null
    actualValue: Decimal | null
    acknowledged: boolean
    acknowledgedBy: string | null
    resolved: boolean
    resolvedAt: Date | null
    autoResolved: boolean
    createdAt: Date
    _count: SystemAlertCountAggregateOutputType | null
    _avg: SystemAlertAvgAggregateOutputType | null
    _sum: SystemAlertSumAggregateOutputType | null
    _min: SystemAlertMinAggregateOutputType | null
    _max: SystemAlertMaxAggregateOutputType | null
  }

  type GetSystemAlertGroupByPayload<T extends SystemAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemAlertGroupByOutputType[P]>
            : GetScalarType<T[P], SystemAlertGroupByOutputType[P]>
        }
      >
    >


  export type SystemAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertType?: boolean
    component?: boolean
    message?: boolean
    severity?: boolean
    thresholdValue?: boolean
    actualValue?: boolean
    acknowledged?: boolean
    acknowledgedBy?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    autoResolved?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["systemAlert"]>

  export type SystemAlertSelectScalar = {
    id?: boolean
    alertType?: boolean
    component?: boolean
    message?: boolean
    severity?: boolean
    thresholdValue?: boolean
    actualValue?: boolean
    acknowledged?: boolean
    acknowledgedBy?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    autoResolved?: boolean
    createdAt?: boolean
  }


  export type $SystemAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemAlert"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      alertType: string
      component: string | null
      message: string | null
      severity: string | null
      thresholdValue: Prisma.Decimal | null
      actualValue: Prisma.Decimal | null
      acknowledged: boolean
      acknowledgedBy: string | null
      resolved: boolean
      resolvedAt: Date | null
      autoResolved: boolean
      createdAt: Date
    }, ExtArgs["result"]["systemAlert"]>
    composites: {}
  }


  type SystemAlertGetPayload<S extends boolean | null | undefined | SystemAlertDefaultArgs> = $Result.GetResult<Prisma.$SystemAlertPayload, S>

  type SystemAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemAlertFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SystemAlertCountAggregateInputType | true
    }

  export interface SystemAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemAlert'], meta: { name: 'SystemAlert' } }
    /**
     * Find zero or one SystemAlert that matches the filter.
     * @param {SystemAlertFindUniqueArgs} args - Arguments to find a SystemAlert
     * @example
     * // Get one SystemAlert
     * const systemAlert = await prisma.systemAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SystemAlertFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SystemAlertFindUniqueArgs<ExtArgs>>
    ): Prisma__SystemAlertClient<$Result.GetResult<Prisma.$SystemAlertPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SystemAlert that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SystemAlertFindUniqueOrThrowArgs} args - Arguments to find a SystemAlert
     * @example
     * // Get one SystemAlert
     * const systemAlert = await prisma.systemAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SystemAlertFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemAlertFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SystemAlertClient<$Result.GetResult<Prisma.$SystemAlertPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SystemAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAlertFindFirstArgs} args - Arguments to find a SystemAlert
     * @example
     * // Get one SystemAlert
     * const systemAlert = await prisma.systemAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SystemAlertFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemAlertFindFirstArgs<ExtArgs>>
    ): Prisma__SystemAlertClient<$Result.GetResult<Prisma.$SystemAlertPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SystemAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAlertFindFirstOrThrowArgs} args - Arguments to find a SystemAlert
     * @example
     * // Get one SystemAlert
     * const systemAlert = await prisma.systemAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SystemAlertFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemAlertFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SystemAlertClient<$Result.GetResult<Prisma.$SystemAlertPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SystemAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAlertFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemAlerts
     * const systemAlerts = await prisma.systemAlert.findMany()
     * 
     * // Get first 10 SystemAlerts
     * const systemAlerts = await prisma.systemAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemAlertWithIdOnly = await prisma.systemAlert.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SystemAlertFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemAlertFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemAlertPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SystemAlert.
     * @param {SystemAlertCreateArgs} args - Arguments to create a SystemAlert.
     * @example
     * // Create one SystemAlert
     * const SystemAlert = await prisma.systemAlert.create({
     *   data: {
     *     // ... data to create a SystemAlert
     *   }
     * })
     * 
    **/
    create<T extends SystemAlertCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SystemAlertCreateArgs<ExtArgs>>
    ): Prisma__SystemAlertClient<$Result.GetResult<Prisma.$SystemAlertPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SystemAlerts.
     *     @param {SystemAlertCreateManyArgs} args - Arguments to create many SystemAlerts.
     *     @example
     *     // Create many SystemAlerts
     *     const systemAlert = await prisma.systemAlert.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SystemAlertCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemAlertCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemAlert.
     * @param {SystemAlertDeleteArgs} args - Arguments to delete one SystemAlert.
     * @example
     * // Delete one SystemAlert
     * const SystemAlert = await prisma.systemAlert.delete({
     *   where: {
     *     // ... filter to delete one SystemAlert
     *   }
     * })
     * 
    **/
    delete<T extends SystemAlertDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SystemAlertDeleteArgs<ExtArgs>>
    ): Prisma__SystemAlertClient<$Result.GetResult<Prisma.$SystemAlertPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SystemAlert.
     * @param {SystemAlertUpdateArgs} args - Arguments to update one SystemAlert.
     * @example
     * // Update one SystemAlert
     * const systemAlert = await prisma.systemAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SystemAlertUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SystemAlertUpdateArgs<ExtArgs>>
    ): Prisma__SystemAlertClient<$Result.GetResult<Prisma.$SystemAlertPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SystemAlerts.
     * @param {SystemAlertDeleteManyArgs} args - Arguments to filter SystemAlerts to delete.
     * @example
     * // Delete a few SystemAlerts
     * const { count } = await prisma.systemAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SystemAlertDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemAlertDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemAlerts
     * const systemAlert = await prisma.systemAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SystemAlertUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SystemAlertUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemAlert.
     * @param {SystemAlertUpsertArgs} args - Arguments to update or create a SystemAlert.
     * @example
     * // Update or create a SystemAlert
     * const systemAlert = await prisma.systemAlert.upsert({
     *   create: {
     *     // ... data to create a SystemAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemAlert we want to update
     *   }
     * })
    **/
    upsert<T extends SystemAlertUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SystemAlertUpsertArgs<ExtArgs>>
    ): Prisma__SystemAlertClient<$Result.GetResult<Prisma.$SystemAlertPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SystemAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAlertCountArgs} args - Arguments to filter SystemAlerts to count.
     * @example
     * // Count the number of SystemAlerts
     * const count = await prisma.systemAlert.count({
     *   where: {
     *     // ... the filter for the SystemAlerts we want to count
     *   }
     * })
    **/
    count<T extends SystemAlertCountArgs>(
      args?: Subset<T, SystemAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemAlertAggregateArgs>(args: Subset<T, SystemAlertAggregateArgs>): Prisma.PrismaPromise<GetSystemAlertAggregateType<T>>

    /**
     * Group by SystemAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemAlertGroupByArgs['orderBy'] }
        : { orderBy?: SystemAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemAlert model
   */
  readonly fields: SystemAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SystemAlert model
   */ 
  interface SystemAlertFieldRefs {
    readonly id: FieldRef<"SystemAlert", 'String'>
    readonly alertType: FieldRef<"SystemAlert", 'String'>
    readonly component: FieldRef<"SystemAlert", 'String'>
    readonly message: FieldRef<"SystemAlert", 'String'>
    readonly severity: FieldRef<"SystemAlert", 'String'>
    readonly thresholdValue: FieldRef<"SystemAlert", 'Decimal'>
    readonly actualValue: FieldRef<"SystemAlert", 'Decimal'>
    readonly acknowledged: FieldRef<"SystemAlert", 'Boolean'>
    readonly acknowledgedBy: FieldRef<"SystemAlert", 'String'>
    readonly resolved: FieldRef<"SystemAlert", 'Boolean'>
    readonly resolvedAt: FieldRef<"SystemAlert", 'DateTime'>
    readonly autoResolved: FieldRef<"SystemAlert", 'Boolean'>
    readonly createdAt: FieldRef<"SystemAlert", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * SystemAlert findUnique
   */
  export type SystemAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAlert
     */
    select?: SystemAlertSelect<ExtArgs> | null
    /**
     * Filter, which SystemAlert to fetch.
     */
    where: SystemAlertWhereUniqueInput
  }


  /**
   * SystemAlert findUniqueOrThrow
   */
  export type SystemAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAlert
     */
    select?: SystemAlertSelect<ExtArgs> | null
    /**
     * Filter, which SystemAlert to fetch.
     */
    where: SystemAlertWhereUniqueInput
  }


  /**
   * SystemAlert findFirst
   */
  export type SystemAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAlert
     */
    select?: SystemAlertSelect<ExtArgs> | null
    /**
     * Filter, which SystemAlert to fetch.
     */
    where?: SystemAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemAlerts to fetch.
     */
    orderBy?: SystemAlertOrderByWithRelationInput | SystemAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemAlerts.
     */
    cursor?: SystemAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemAlerts.
     */
    distinct?: SystemAlertScalarFieldEnum | SystemAlertScalarFieldEnum[]
  }


  /**
   * SystemAlert findFirstOrThrow
   */
  export type SystemAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAlert
     */
    select?: SystemAlertSelect<ExtArgs> | null
    /**
     * Filter, which SystemAlert to fetch.
     */
    where?: SystemAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemAlerts to fetch.
     */
    orderBy?: SystemAlertOrderByWithRelationInput | SystemAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemAlerts.
     */
    cursor?: SystemAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemAlerts.
     */
    distinct?: SystemAlertScalarFieldEnum | SystemAlertScalarFieldEnum[]
  }


  /**
   * SystemAlert findMany
   */
  export type SystemAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAlert
     */
    select?: SystemAlertSelect<ExtArgs> | null
    /**
     * Filter, which SystemAlerts to fetch.
     */
    where?: SystemAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemAlerts to fetch.
     */
    orderBy?: SystemAlertOrderByWithRelationInput | SystemAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemAlerts.
     */
    cursor?: SystemAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemAlerts.
     */
    skip?: number
    distinct?: SystemAlertScalarFieldEnum | SystemAlertScalarFieldEnum[]
  }


  /**
   * SystemAlert create
   */
  export type SystemAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAlert
     */
    select?: SystemAlertSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemAlert.
     */
    data: XOR<SystemAlertCreateInput, SystemAlertUncheckedCreateInput>
  }


  /**
   * SystemAlert createMany
   */
  export type SystemAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemAlerts.
     */
    data: SystemAlertCreateManyInput | SystemAlertCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SystemAlert update
   */
  export type SystemAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAlert
     */
    select?: SystemAlertSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemAlert.
     */
    data: XOR<SystemAlertUpdateInput, SystemAlertUncheckedUpdateInput>
    /**
     * Choose, which SystemAlert to update.
     */
    where: SystemAlertWhereUniqueInput
  }


  /**
   * SystemAlert updateMany
   */
  export type SystemAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemAlerts.
     */
    data: XOR<SystemAlertUpdateManyMutationInput, SystemAlertUncheckedUpdateManyInput>
    /**
     * Filter which SystemAlerts to update
     */
    where?: SystemAlertWhereInput
  }


  /**
   * SystemAlert upsert
   */
  export type SystemAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAlert
     */
    select?: SystemAlertSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemAlert to update in case it exists.
     */
    where: SystemAlertWhereUniqueInput
    /**
     * In case the SystemAlert found by the `where` argument doesn't exist, create a new SystemAlert with this data.
     */
    create: XOR<SystemAlertCreateInput, SystemAlertUncheckedCreateInput>
    /**
     * In case the SystemAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemAlertUpdateInput, SystemAlertUncheckedUpdateInput>
  }


  /**
   * SystemAlert delete
   */
  export type SystemAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAlert
     */
    select?: SystemAlertSelect<ExtArgs> | null
    /**
     * Filter which SystemAlert to delete.
     */
    where: SystemAlertWhereUniqueInput
  }


  /**
   * SystemAlert deleteMany
   */
  export type SystemAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemAlerts to delete
     */
    where?: SystemAlertWhereInput
  }


  /**
   * SystemAlert without action
   */
  export type SystemAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAlert
     */
    select?: SystemAlertSelect<ExtArgs> | null
  }



  /**
   * Model AdminUser
   */

  export type AggregateAdminUser = {
    _count: AdminUserCountAggregateOutputType | null
    _avg: AdminUserAvgAggregateOutputType | null
    _sum: AdminUserSumAggregateOutputType | null
    _min: AdminUserMinAggregateOutputType | null
    _max: AdminUserMaxAggregateOutputType | null
  }

  export type AdminUserAvgAggregateOutputType = {
    failedLogins: number | null
  }

  export type AdminUserSumAggregateOutputType = {
    failedLogins: number | null
  }

  export type AdminUserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    role: string | null
    mfaEnabled: boolean | null
    mfaSecret: string | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    failedLogins: number | null
    lockedUntil: Date | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminUserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    role: string | null
    mfaEnabled: boolean | null
    mfaSecret: string | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    failedLogins: number | null
    lockedUntil: Date | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminUserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    name: number
    role: number
    permissions: number
    mfaEnabled: number
    mfaSecret: number
    lastLoginAt: number
    lastLoginIp: number
    failedLogins: number
    lockedUntil: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminUserAvgAggregateInputType = {
    failedLogins?: true
  }

  export type AdminUserSumAggregateInputType = {
    failedLogins?: true
  }

  export type AdminUserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    role?: true
    mfaEnabled?: true
    mfaSecret?: true
    lastLoginAt?: true
    lastLoginIp?: true
    failedLogins?: true
    lockedUntil?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminUserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    role?: true
    mfaEnabled?: true
    mfaSecret?: true
    lastLoginAt?: true
    lastLoginIp?: true
    failedLogins?: true
    lockedUntil?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminUserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    role?: true
    permissions?: true
    mfaEnabled?: true
    mfaSecret?: true
    lastLoginAt?: true
    lastLoginIp?: true
    failedLogins?: true
    lockedUntil?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUser to aggregate.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminUsers
    **/
    _count?: true | AdminUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminUserMaxAggregateInputType
  }

  export type GetAdminUserAggregateType<T extends AdminUserAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminUser[P]>
      : GetScalarType<T[P], AggregateAdminUser[P]>
  }




  export type AdminUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminUserWhereInput
    orderBy?: AdminUserOrderByWithAggregationInput | AdminUserOrderByWithAggregationInput[]
    by: AdminUserScalarFieldEnum[] | AdminUserScalarFieldEnum
    having?: AdminUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminUserCountAggregateInputType | true
    _avg?: AdminUserAvgAggregateInputType
    _sum?: AdminUserSumAggregateInputType
    _min?: AdminUserMinAggregateInputType
    _max?: AdminUserMaxAggregateInputType
  }

  export type AdminUserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    name: string
    role: string
    permissions: string[]
    mfaEnabled: boolean
    mfaSecret: string | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    failedLogins: number
    lockedUntil: Date | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: AdminUserCountAggregateOutputType | null
    _avg: AdminUserAvgAggregateOutputType | null
    _sum: AdminUserSumAggregateOutputType | null
    _min: AdminUserMinAggregateOutputType | null
    _max: AdminUserMaxAggregateOutputType | null
  }

  type GetAdminUserGroupByPayload<T extends AdminUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminUserGroupByOutputType[P]>
            : GetScalarType<T[P], AdminUserGroupByOutputType[P]>
        }
      >
    >


  export type AdminUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    role?: boolean
    permissions?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedLogins?: boolean
    lockedUntil?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    auditLogs?: boolean | AdminUser$auditLogsArgs<ExtArgs>
    _count?: boolean | AdminUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminUser"]>

  export type AdminUserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    role?: boolean
    permissions?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedLogins?: boolean
    lockedUntil?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | AdminUser$auditLogsArgs<ExtArgs>
    _count?: boolean | AdminUserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AdminUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminUser"
    objects: {
      auditLogs: Prisma.$AdminAuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      name: string
      role: string
      permissions: string[]
      mfaEnabled: boolean
      mfaSecret: string | null
      lastLoginAt: Date | null
      lastLoginIp: string | null
      failedLogins: number
      lockedUntil: Date | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminUser"]>
    composites: {}
  }


  type AdminUserGetPayload<S extends boolean | null | undefined | AdminUserDefaultArgs> = $Result.GetResult<Prisma.$AdminUserPayload, S>

  type AdminUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminUserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AdminUserCountAggregateInputType | true
    }

  export interface AdminUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminUser'], meta: { name: 'AdminUser' } }
    /**
     * Find zero or one AdminUser that matches the filter.
     * @param {AdminUserFindUniqueArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUserFindUniqueArgs<ExtArgs>>
    ): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AdminUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdminUserFindUniqueOrThrowArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdminUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AdminUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindFirstArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminUserFindFirstArgs<ExtArgs>>
    ): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AdminUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindFirstOrThrowArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdminUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AdminUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminUsers
     * const adminUsers = await prisma.adminUser.findMany()
     * 
     * // Get first 10 AdminUsers
     * const adminUsers = await prisma.adminUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminUserWithIdOnly = await prisma.adminUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdminUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AdminUser.
     * @param {AdminUserCreateArgs} args - Arguments to create a AdminUser.
     * @example
     * // Create one AdminUser
     * const AdminUser = await prisma.adminUser.create({
     *   data: {
     *     // ... data to create a AdminUser
     *   }
     * })
     * 
    **/
    create<T extends AdminUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUserCreateArgs<ExtArgs>>
    ): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AdminUsers.
     *     @param {AdminUserCreateManyArgs} args - Arguments to create many AdminUsers.
     *     @example
     *     // Create many AdminUsers
     *     const adminUser = await prisma.adminUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdminUser.
     * @param {AdminUserDeleteArgs} args - Arguments to delete one AdminUser.
     * @example
     * // Delete one AdminUser
     * const AdminUser = await prisma.adminUser.delete({
     *   where: {
     *     // ... filter to delete one AdminUser
     *   }
     * })
     * 
    **/
    delete<T extends AdminUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUserDeleteArgs<ExtArgs>>
    ): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AdminUser.
     * @param {AdminUserUpdateArgs} args - Arguments to update one AdminUser.
     * @example
     * // Update one AdminUser
     * const adminUser = await prisma.adminUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUserUpdateArgs<ExtArgs>>
    ): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AdminUsers.
     * @param {AdminUserDeleteManyArgs} args - Arguments to filter AdminUsers to delete.
     * @example
     * // Delete a few AdminUsers
     * const { count } = await prisma.adminUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminUsers
     * const adminUser = await prisma.adminUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminUser.
     * @param {AdminUserUpsertArgs} args - Arguments to update or create a AdminUser.
     * @example
     * // Update or create a AdminUser
     * const adminUser = await prisma.adminUser.upsert({
     *   create: {
     *     // ... data to create a AdminUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminUser we want to update
     *   }
     * })
    **/
    upsert<T extends AdminUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUserUpsertArgs<ExtArgs>>
    ): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AdminUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserCountArgs} args - Arguments to filter AdminUsers to count.
     * @example
     * // Count the number of AdminUsers
     * const count = await prisma.adminUser.count({
     *   where: {
     *     // ... the filter for the AdminUsers we want to count
     *   }
     * })
    **/
    count<T extends AdminUserCountArgs>(
      args?: Subset<T, AdminUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminUserAggregateArgs>(args: Subset<T, AdminUserAggregateArgs>): Prisma.PrismaPromise<GetAdminUserAggregateType<T>>

    /**
     * Group by AdminUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminUserGroupByArgs['orderBy'] }
        : { orderBy?: AdminUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminUser model
   */
  readonly fields: AdminUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    auditLogs<T extends AdminUser$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AdminUser model
   */ 
  interface AdminUserFieldRefs {
    readonly id: FieldRef<"AdminUser", 'String'>
    readonly email: FieldRef<"AdminUser", 'String'>
    readonly passwordHash: FieldRef<"AdminUser", 'String'>
    readonly name: FieldRef<"AdminUser", 'String'>
    readonly role: FieldRef<"AdminUser", 'String'>
    readonly permissions: FieldRef<"AdminUser", 'String[]'>
    readonly mfaEnabled: FieldRef<"AdminUser", 'Boolean'>
    readonly mfaSecret: FieldRef<"AdminUser", 'String'>
    readonly lastLoginAt: FieldRef<"AdminUser", 'DateTime'>
    readonly lastLoginIp: FieldRef<"AdminUser", 'String'>
    readonly failedLogins: FieldRef<"AdminUser", 'Int'>
    readonly lockedUntil: FieldRef<"AdminUser", 'DateTime'>
    readonly createdBy: FieldRef<"AdminUser", 'String'>
    readonly createdAt: FieldRef<"AdminUser", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminUser", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * AdminUser findUnique
   */
  export type AdminUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where: AdminUserWhereUniqueInput
  }


  /**
   * AdminUser findUniqueOrThrow
   */
  export type AdminUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where: AdminUserWhereUniqueInput
  }


  /**
   * AdminUser findFirst
   */
  export type AdminUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUsers.
     */
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }


  /**
   * AdminUser findFirstOrThrow
   */
  export type AdminUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUsers.
     */
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }


  /**
   * AdminUser findMany
   */
  export type AdminUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUsers to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }


  /**
   * AdminUser create
   */
  export type AdminUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminUser.
     */
    data: XOR<AdminUserCreateInput, AdminUserUncheckedCreateInput>
  }


  /**
   * AdminUser createMany
   */
  export type AdminUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminUsers.
     */
    data: AdminUserCreateManyInput | AdminUserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AdminUser update
   */
  export type AdminUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminUser.
     */
    data: XOR<AdminUserUpdateInput, AdminUserUncheckedUpdateInput>
    /**
     * Choose, which AdminUser to update.
     */
    where: AdminUserWhereUniqueInput
  }


  /**
   * AdminUser updateMany
   */
  export type AdminUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminUsers.
     */
    data: XOR<AdminUserUpdateManyMutationInput, AdminUserUncheckedUpdateManyInput>
    /**
     * Filter which AdminUsers to update
     */
    where?: AdminUserWhereInput
  }


  /**
   * AdminUser upsert
   */
  export type AdminUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminUser to update in case it exists.
     */
    where: AdminUserWhereUniqueInput
    /**
     * In case the AdminUser found by the `where` argument doesn't exist, create a new AdminUser with this data.
     */
    create: XOR<AdminUserCreateInput, AdminUserUncheckedCreateInput>
    /**
     * In case the AdminUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUserUpdateInput, AdminUserUncheckedUpdateInput>
  }


  /**
   * AdminUser delete
   */
  export type AdminUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter which AdminUser to delete.
     */
    where: AdminUserWhereUniqueInput
  }


  /**
   * AdminUser deleteMany
   */
  export type AdminUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUsers to delete
     */
    where?: AdminUserWhereInput
  }


  /**
   * AdminUser.auditLogs
   */
  export type AdminUser$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    where?: AdminAuditLogWhereInput
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    cursor?: AdminAuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }


  /**
   * AdminUser without action
   */
  export type AdminUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminUserInclude<ExtArgs> | null
  }



  /**
   * Model AdminAuditLog
   */

  export type AggregateAdminAuditLog = {
    _count: AdminAuditLogCountAggregateOutputType | null
    _min: AdminAuditLogMinAggregateOutputType | null
    _max: AdminAuditLogMaxAggregateOutputType | null
  }

  export type AdminAuditLogMinAggregateOutputType = {
    id: string | null
    adminUserId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AdminAuditLogMaxAggregateOutputType = {
    id: string | null
    adminUserId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AdminAuditLogCountAggregateOutputType = {
    id: number
    adminUserId: number
    action: number
    resource: number
    resourceId: number
    details: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AdminAuditLogMinAggregateInputType = {
    id?: true
    adminUserId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AdminAuditLogMaxAggregateInputType = {
    id?: true
    adminUserId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AdminAuditLogCountAggregateInputType = {
    id?: true
    adminUserId?: true
    action?: true
    resource?: true
    resourceId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AdminAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuditLog to aggregate.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminAuditLogs
    **/
    _count?: true | AdminAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminAuditLogMaxAggregateInputType
  }

  export type GetAdminAuditLogAggregateType<T extends AdminAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminAuditLog[P]>
      : GetScalarType<T[P], AggregateAdminAuditLog[P]>
  }




  export type AdminAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuditLogWhereInput
    orderBy?: AdminAuditLogOrderByWithAggregationInput | AdminAuditLogOrderByWithAggregationInput[]
    by: AdminAuditLogScalarFieldEnum[] | AdminAuditLogScalarFieldEnum
    having?: AdminAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminAuditLogCountAggregateInputType | true
    _min?: AdminAuditLogMinAggregateInputType
    _max?: AdminAuditLogMaxAggregateInputType
  }

  export type AdminAuditLogGroupByOutputType = {
    id: string
    adminUserId: string
    action: string
    resource: string | null
    resourceId: string | null
    details: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AdminAuditLogCountAggregateOutputType | null
    _min: AdminAuditLogMinAggregateOutputType | null
    _max: AdminAuditLogMaxAggregateOutputType | null
  }

  type GetAdminAuditLogGroupByPayload<T extends AdminAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AdminAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AdminAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminUserId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    adminUser?: boolean | AdminUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuditLog"]>

  export type AdminAuditLogSelectScalar = {
    id?: boolean
    adminUserId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AdminAuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminUser?: boolean | AdminUserDefaultArgs<ExtArgs>
  }


  export type $AdminAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminAuditLog"
    objects: {
      adminUser: Prisma.$AdminUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminUserId: string
      action: string
      resource: string | null
      resourceId: string | null
      details: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["adminAuditLog"]>
    composites: {}
  }


  type AdminAuditLogGetPayload<S extends boolean | null | undefined | AdminAuditLogDefaultArgs> = $Result.GetResult<Prisma.$AdminAuditLogPayload, S>

  type AdminAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminAuditLogFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AdminAuditLogCountAggregateInputType | true
    }

  export interface AdminAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminAuditLog'], meta: { name: 'AdminAuditLog' } }
    /**
     * Find zero or one AdminAuditLog that matches the filter.
     * @param {AdminAuditLogFindUniqueArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminAuditLogFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdminAuditLogFindUniqueArgs<ExtArgs>>
    ): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AdminAuditLog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdminAuditLogFindUniqueOrThrowArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdminAuditLogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminAuditLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AdminAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindFirstArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminAuditLogFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminAuditLogFindFirstArgs<ExtArgs>>
    ): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AdminAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindFirstOrThrowArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdminAuditLogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminAuditLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AdminAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminAuditLogs
     * const adminAuditLogs = await prisma.adminAuditLog.findMany()
     * 
     * // Get first 10 AdminAuditLogs
     * const adminAuditLogs = await prisma.adminAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminAuditLogWithIdOnly = await prisma.adminAuditLog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdminAuditLogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminAuditLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AdminAuditLog.
     * @param {AdminAuditLogCreateArgs} args - Arguments to create a AdminAuditLog.
     * @example
     * // Create one AdminAuditLog
     * const AdminAuditLog = await prisma.adminAuditLog.create({
     *   data: {
     *     // ... data to create a AdminAuditLog
     *   }
     * })
     * 
    **/
    create<T extends AdminAuditLogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminAuditLogCreateArgs<ExtArgs>>
    ): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AdminAuditLogs.
     *     @param {AdminAuditLogCreateManyArgs} args - Arguments to create many AdminAuditLogs.
     *     @example
     *     // Create many AdminAuditLogs
     *     const adminAuditLog = await prisma.adminAuditLog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminAuditLogCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminAuditLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdminAuditLog.
     * @param {AdminAuditLogDeleteArgs} args - Arguments to delete one AdminAuditLog.
     * @example
     * // Delete one AdminAuditLog
     * const AdminAuditLog = await prisma.adminAuditLog.delete({
     *   where: {
     *     // ... filter to delete one AdminAuditLog
     *   }
     * })
     * 
    **/
    delete<T extends AdminAuditLogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdminAuditLogDeleteArgs<ExtArgs>>
    ): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AdminAuditLog.
     * @param {AdminAuditLogUpdateArgs} args - Arguments to update one AdminAuditLog.
     * @example
     * // Update one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminAuditLogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminAuditLogUpdateArgs<ExtArgs>>
    ): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AdminAuditLogs.
     * @param {AdminAuditLogDeleteManyArgs} args - Arguments to filter AdminAuditLogs to delete.
     * @example
     * // Delete a few AdminAuditLogs
     * const { count } = await prisma.adminAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminAuditLogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminAuditLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminAuditLogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdminAuditLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminAuditLog.
     * @param {AdminAuditLogUpsertArgs} args - Arguments to update or create a AdminAuditLog.
     * @example
     * // Update or create a AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.upsert({
     *   create: {
     *     // ... data to create a AdminAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminAuditLog we want to update
     *   }
     * })
    **/
    upsert<T extends AdminAuditLogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdminAuditLogUpsertArgs<ExtArgs>>
    ): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AdminAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogCountArgs} args - Arguments to filter AdminAuditLogs to count.
     * @example
     * // Count the number of AdminAuditLogs
     * const count = await prisma.adminAuditLog.count({
     *   where: {
     *     // ... the filter for the AdminAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AdminAuditLogCountArgs>(
      args?: Subset<T, AdminAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAuditLogAggregateArgs>(args: Subset<T, AdminAuditLogAggregateArgs>): Prisma.PrismaPromise<GetAdminAuditLogAggregateType<T>>

    /**
     * Group by AdminAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AdminAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminAuditLog model
   */
  readonly fields: AdminAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    adminUser<T extends AdminUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminUserDefaultArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AdminAuditLog model
   */ 
  interface AdminAuditLogFieldRefs {
    readonly id: FieldRef<"AdminAuditLog", 'String'>
    readonly adminUserId: FieldRef<"AdminAuditLog", 'String'>
    readonly action: FieldRef<"AdminAuditLog", 'String'>
    readonly resource: FieldRef<"AdminAuditLog", 'String'>
    readonly resourceId: FieldRef<"AdminAuditLog", 'String'>
    readonly details: FieldRef<"AdminAuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AdminAuditLog", 'String'>
    readonly userAgent: FieldRef<"AdminAuditLog", 'String'>
    readonly createdAt: FieldRef<"AdminAuditLog", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * AdminAuditLog findUnique
   */
  export type AdminAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where: AdminAuditLogWhereUniqueInput
  }


  /**
   * AdminAuditLog findUniqueOrThrow
   */
  export type AdminAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where: AdminAuditLogWhereUniqueInput
  }


  /**
   * AdminAuditLog findFirst
   */
  export type AdminAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuditLogs.
     */
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }


  /**
   * AdminAuditLog findFirstOrThrow
   */
  export type AdminAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuditLogs.
     */
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }


  /**
   * AdminAuditLog findMany
   */
  export type AdminAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLogs to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }


  /**
   * AdminAuditLog create
   */
  export type AdminAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminAuditLog.
     */
    data: XOR<AdminAuditLogCreateInput, AdminAuditLogUncheckedCreateInput>
  }


  /**
   * AdminAuditLog createMany
   */
  export type AdminAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminAuditLogs.
     */
    data: AdminAuditLogCreateManyInput | AdminAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AdminAuditLog update
   */
  export type AdminAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminAuditLog.
     */
    data: XOR<AdminAuditLogUpdateInput, AdminAuditLogUncheckedUpdateInput>
    /**
     * Choose, which AdminAuditLog to update.
     */
    where: AdminAuditLogWhereUniqueInput
  }


  /**
   * AdminAuditLog updateMany
   */
  export type AdminAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminAuditLogs.
     */
    data: XOR<AdminAuditLogUpdateManyMutationInput, AdminAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AdminAuditLogs to update
     */
    where?: AdminAuditLogWhereInput
  }


  /**
   * AdminAuditLog upsert
   */
  export type AdminAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminAuditLog to update in case it exists.
     */
    where: AdminAuditLogWhereUniqueInput
    /**
     * In case the AdminAuditLog found by the `where` argument doesn't exist, create a new AdminAuditLog with this data.
     */
    create: XOR<AdminAuditLogCreateInput, AdminAuditLogUncheckedCreateInput>
    /**
     * In case the AdminAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminAuditLogUpdateInput, AdminAuditLogUncheckedUpdateInput>
  }


  /**
   * AdminAuditLog delete
   */
  export type AdminAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter which AdminAuditLog to delete.
     */
    where: AdminAuditLogWhereUniqueInput
  }


  /**
   * AdminAuditLog deleteMany
   */
  export type AdminAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuditLogs to delete
     */
    where?: AdminAuditLogWhereInput
  }


  /**
   * AdminAuditLog without action
   */
  export type AdminAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
  }



  /**
   * Model AdminSession
   */

  export type AggregateAdminSession = {
    _count: AdminSessionCountAggregateOutputType | null
    _min: AdminSessionMinAggregateOutputType | null
    _max: AdminSessionMaxAggregateOutputType | null
  }

  export type AdminSessionMinAggregateOutputType = {
    id: string | null
    adminUserId: string | null
    token: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
    lastActiveAt: Date | null
  }

  export type AdminSessionMaxAggregateOutputType = {
    id: string | null
    adminUserId: string | null
    token: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
    lastActiveAt: Date | null
  }

  export type AdminSessionCountAggregateOutputType = {
    id: number
    adminUserId: number
    token: number
    ipAddress: number
    userAgent: number
    expiresAt: number
    createdAt: number
    lastActiveAt: number
    _all: number
  }


  export type AdminSessionMinAggregateInputType = {
    id?: true
    adminUserId?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    lastActiveAt?: true
  }

  export type AdminSessionMaxAggregateInputType = {
    id?: true
    adminUserId?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    lastActiveAt?: true
  }

  export type AdminSessionCountAggregateInputType = {
    id?: true
    adminUserId?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    lastActiveAt?: true
    _all?: true
  }

  export type AdminSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminSession to aggregate.
     */
    where?: AdminSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSessions to fetch.
     */
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminSessions
    **/
    _count?: true | AdminSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminSessionMaxAggregateInputType
  }

  export type GetAdminSessionAggregateType<T extends AdminSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminSession[P]>
      : GetScalarType<T[P], AggregateAdminSession[P]>
  }




  export type AdminSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminSessionWhereInput
    orderBy?: AdminSessionOrderByWithAggregationInput | AdminSessionOrderByWithAggregationInput[]
    by: AdminSessionScalarFieldEnum[] | AdminSessionScalarFieldEnum
    having?: AdminSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminSessionCountAggregateInputType | true
    _min?: AdminSessionMinAggregateInputType
    _max?: AdminSessionMaxAggregateInputType
  }

  export type AdminSessionGroupByOutputType = {
    id: string
    adminUserId: string
    token: string
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date
    createdAt: Date
    lastActiveAt: Date
    _count: AdminSessionCountAggregateOutputType | null
    _min: AdminSessionMinAggregateOutputType | null
    _max: AdminSessionMaxAggregateOutputType | null
  }

  type GetAdminSessionGroupByPayload<T extends AdminSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminSessionGroupByOutputType[P]>
            : GetScalarType<T[P], AdminSessionGroupByOutputType[P]>
        }
      >
    >


  export type AdminSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminUserId?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    lastActiveAt?: boolean
  }, ExtArgs["result"]["adminSession"]>

  export type AdminSessionSelectScalar = {
    id?: boolean
    adminUserId?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    lastActiveAt?: boolean
  }


  export type $AdminSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminSession"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminUserId: string
      token: string
      ipAddress: string | null
      userAgent: string | null
      expiresAt: Date
      createdAt: Date
      lastActiveAt: Date
    }, ExtArgs["result"]["adminSession"]>
    composites: {}
  }


  type AdminSessionGetPayload<S extends boolean | null | undefined | AdminSessionDefaultArgs> = $Result.GetResult<Prisma.$AdminSessionPayload, S>

  type AdminSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminSessionFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AdminSessionCountAggregateInputType | true
    }

  export interface AdminSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminSession'], meta: { name: 'AdminSession' } }
    /**
     * Find zero or one AdminSession that matches the filter.
     * @param {AdminSessionFindUniqueArgs} args - Arguments to find a AdminSession
     * @example
     * // Get one AdminSession
     * const adminSession = await prisma.adminSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminSessionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdminSessionFindUniqueArgs<ExtArgs>>
    ): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AdminSession that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdminSessionFindUniqueOrThrowArgs} args - Arguments to find a AdminSession
     * @example
     * // Get one AdminSession
     * const adminSession = await prisma.adminSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdminSessionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminSessionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AdminSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionFindFirstArgs} args - Arguments to find a AdminSession
     * @example
     * // Get one AdminSession
     * const adminSession = await prisma.adminSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminSessionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminSessionFindFirstArgs<ExtArgs>>
    ): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AdminSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionFindFirstOrThrowArgs} args - Arguments to find a AdminSession
     * @example
     * // Get one AdminSession
     * const adminSession = await prisma.adminSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdminSessionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminSessionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AdminSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminSessions
     * const adminSessions = await prisma.adminSession.findMany()
     * 
     * // Get first 10 AdminSessions
     * const adminSessions = await prisma.adminSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminSessionWithIdOnly = await prisma.adminSession.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdminSessionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminSessionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AdminSession.
     * @param {AdminSessionCreateArgs} args - Arguments to create a AdminSession.
     * @example
     * // Create one AdminSession
     * const AdminSession = await prisma.adminSession.create({
     *   data: {
     *     // ... data to create a AdminSession
     *   }
     * })
     * 
    **/
    create<T extends AdminSessionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminSessionCreateArgs<ExtArgs>>
    ): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AdminSessions.
     *     @param {AdminSessionCreateManyArgs} args - Arguments to create many AdminSessions.
     *     @example
     *     // Create many AdminSessions
     *     const adminSession = await prisma.adminSession.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminSessionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminSessionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdminSession.
     * @param {AdminSessionDeleteArgs} args - Arguments to delete one AdminSession.
     * @example
     * // Delete one AdminSession
     * const AdminSession = await prisma.adminSession.delete({
     *   where: {
     *     // ... filter to delete one AdminSession
     *   }
     * })
     * 
    **/
    delete<T extends AdminSessionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdminSessionDeleteArgs<ExtArgs>>
    ): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AdminSession.
     * @param {AdminSessionUpdateArgs} args - Arguments to update one AdminSession.
     * @example
     * // Update one AdminSession
     * const adminSession = await prisma.adminSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminSessionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminSessionUpdateArgs<ExtArgs>>
    ): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AdminSessions.
     * @param {AdminSessionDeleteManyArgs} args - Arguments to filter AdminSessions to delete.
     * @example
     * // Delete a few AdminSessions
     * const { count } = await prisma.adminSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminSessionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminSessionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminSessions
     * const adminSession = await prisma.adminSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminSessionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdminSessionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminSession.
     * @param {AdminSessionUpsertArgs} args - Arguments to update or create a AdminSession.
     * @example
     * // Update or create a AdminSession
     * const adminSession = await prisma.adminSession.upsert({
     *   create: {
     *     // ... data to create a AdminSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminSession we want to update
     *   }
     * })
    **/
    upsert<T extends AdminSessionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdminSessionUpsertArgs<ExtArgs>>
    ): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AdminSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionCountArgs} args - Arguments to filter AdminSessions to count.
     * @example
     * // Count the number of AdminSessions
     * const count = await prisma.adminSession.count({
     *   where: {
     *     // ... the filter for the AdminSessions we want to count
     *   }
     * })
    **/
    count<T extends AdminSessionCountArgs>(
      args?: Subset<T, AdminSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminSessionAggregateArgs>(args: Subset<T, AdminSessionAggregateArgs>): Prisma.PrismaPromise<GetAdminSessionAggregateType<T>>

    /**
     * Group by AdminSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminSessionGroupByArgs['orderBy'] }
        : { orderBy?: AdminSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminSession model
   */
  readonly fields: AdminSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AdminSession model
   */ 
  interface AdminSessionFieldRefs {
    readonly id: FieldRef<"AdminSession", 'String'>
    readonly adminUserId: FieldRef<"AdminSession", 'String'>
    readonly token: FieldRef<"AdminSession", 'String'>
    readonly ipAddress: FieldRef<"AdminSession", 'String'>
    readonly userAgent: FieldRef<"AdminSession", 'String'>
    readonly expiresAt: FieldRef<"AdminSession", 'DateTime'>
    readonly createdAt: FieldRef<"AdminSession", 'DateTime'>
    readonly lastActiveAt: FieldRef<"AdminSession", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * AdminSession findUnique
   */
  export type AdminSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Filter, which AdminSession to fetch.
     */
    where: AdminSessionWhereUniqueInput
  }


  /**
   * AdminSession findUniqueOrThrow
   */
  export type AdminSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Filter, which AdminSession to fetch.
     */
    where: AdminSessionWhereUniqueInput
  }


  /**
   * AdminSession findFirst
   */
  export type AdminSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Filter, which AdminSession to fetch.
     */
    where?: AdminSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSessions to fetch.
     */
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminSessions.
     */
    cursor?: AdminSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminSessions.
     */
    distinct?: AdminSessionScalarFieldEnum | AdminSessionScalarFieldEnum[]
  }


  /**
   * AdminSession findFirstOrThrow
   */
  export type AdminSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Filter, which AdminSession to fetch.
     */
    where?: AdminSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSessions to fetch.
     */
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminSessions.
     */
    cursor?: AdminSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminSessions.
     */
    distinct?: AdminSessionScalarFieldEnum | AdminSessionScalarFieldEnum[]
  }


  /**
   * AdminSession findMany
   */
  export type AdminSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Filter, which AdminSessions to fetch.
     */
    where?: AdminSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSessions to fetch.
     */
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminSessions.
     */
    cursor?: AdminSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSessions.
     */
    skip?: number
    distinct?: AdminSessionScalarFieldEnum | AdminSessionScalarFieldEnum[]
  }


  /**
   * AdminSession create
   */
  export type AdminSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * The data needed to create a AdminSession.
     */
    data: XOR<AdminSessionCreateInput, AdminSessionUncheckedCreateInput>
  }


  /**
   * AdminSession createMany
   */
  export type AdminSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminSessions.
     */
    data: AdminSessionCreateManyInput | AdminSessionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AdminSession update
   */
  export type AdminSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * The data needed to update a AdminSession.
     */
    data: XOR<AdminSessionUpdateInput, AdminSessionUncheckedUpdateInput>
    /**
     * Choose, which AdminSession to update.
     */
    where: AdminSessionWhereUniqueInput
  }


  /**
   * AdminSession updateMany
   */
  export type AdminSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminSessions.
     */
    data: XOR<AdminSessionUpdateManyMutationInput, AdminSessionUncheckedUpdateManyInput>
    /**
     * Filter which AdminSessions to update
     */
    where?: AdminSessionWhereInput
  }


  /**
   * AdminSession upsert
   */
  export type AdminSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * The filter to search for the AdminSession to update in case it exists.
     */
    where: AdminSessionWhereUniqueInput
    /**
     * In case the AdminSession found by the `where` argument doesn't exist, create a new AdminSession with this data.
     */
    create: XOR<AdminSessionCreateInput, AdminSessionUncheckedCreateInput>
    /**
     * In case the AdminSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminSessionUpdateInput, AdminSessionUncheckedUpdateInput>
  }


  /**
   * AdminSession delete
   */
  export type AdminSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Filter which AdminSession to delete.
     */
    where: AdminSessionWhereUniqueInput
  }


  /**
   * AdminSession deleteMany
   */
  export type AdminSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminSessions to delete
     */
    where?: AdminSessionWhereInput
  }


  /**
   * AdminSession without action
   */
  export type AdminSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    name: 'name',
    company: 'company',
    tier: 'tier',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    subscriptionStatus: 'subscriptionStatus',
    trialEndsAt: 'trialEndsAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLoginAt: 'lastLoginAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    email: 'email',
    name: 'name',
    company: 'company',
    phone: 'phone',
    title: 'title',
    website: 'website',
    linkedinUrl: 'linkedinUrl',
    source: 'source',
    status: 'status',
    score: 'score',
    notes: 'notes',
    tags: 'tags',
    customFields: 'customFields',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastContactedAt: 'lastContactedAt'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    type: 'type',
    status: 'status',
    subject: 'subject',
    fromName: 'fromName',
    fromEmail: 'fromEmail',
    replyTo: 'replyTo',
    templateId: 'templateId',
    htmlContent: 'htmlContent',
    textContent: 'textContent',
    scheduledAt: 'scheduledAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    totalLeads: 'totalLeads',
    sentCount: 'sentCount',
    openCount: 'openCount',
    clickCount: 'clickCount',
    replyCount: 'replyCount',
    bounceCount: 'bounceCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const CampaignLeadScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    leadId: 'leadId',
    status: 'status',
    sentAt: 'sentAt',
    openedAt: 'openedAt',
    clickedAt: 'clickedAt',
    repliedAt: 'repliedAt'
  };

  export type CampaignLeadScalarFieldEnum = (typeof CampaignLeadScalarFieldEnum)[keyof typeof CampaignLeadScalarFieldEnum]


  export const EmailTemplateScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    subject: 'subject',
    htmlContent: 'htmlContent',
    textContent: 'textContent',
    variables: 'variables',
    isDefault: 'isDefault',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailTemplateScalarFieldEnum = (typeof EmailTemplateScalarFieldEnum)[keyof typeof EmailTemplateScalarFieldEnum]


  export const EmailEventScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    leadId: 'leadId',
    eventType: 'eventType',
    eventData: 'eventData',
    createdAt: 'createdAt'
  };

  export type EmailEventScalarFieldEnum = (typeof EmailEventScalarFieldEnum)[keyof typeof EmailEventScalarFieldEnum]


  export const WebsiteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    domain: 'domain',
    subdomain: 'subdomain',
    pages: 'pages',
    settings: 'settings',
    theme: 'theme',
    isPublished: 'isPublished',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebsiteScalarFieldEnum = (typeof WebsiteScalarFieldEnum)[keyof typeof WebsiteScalarFieldEnum]


  export const VideoScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    filename: 'filename',
    fileUrl: 'fileUrl',
    thumbnailUrl: 'thumbnailUrl',
    duration: 'duration',
    fileSize: 'fileSize',
    isMonetized: 'isMonetized',
    viewCount: 'viewCount',
    earnings: 'earnings',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VideoScalarFieldEnum = (typeof VideoScalarFieldEnum)[keyof typeof VideoScalarFieldEnum]


  export const ApiKeyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    key: 'key',
    permissions: 'permissions',
    lastUsedAt: 'lastUsedAt',
    expiresAt: 'expiresAt',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    contactName: 'contactName',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    contactId: 'contactId',
    channel: 'channel',
    channelId: 'channelId',
    subject: 'subject',
    status: 'status',
    priority: 'priority',
    assignedTo: 'assignedTo',
    tags: 'tags',
    labels: 'labels',
    messageCount: 'messageCount',
    unreadCount: 'unreadCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastMessageAt: 'lastMessageAt',
    closedAt: 'closedAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    userId: 'userId',
    content: 'content',
    htmlContent: 'htmlContent',
    subject: 'subject',
    channel: 'channel',
    channelMessageId: 'channelMessageId',
    direction: 'direction',
    status: 'status',
    isRead: 'isRead',
    attachments: 'attachments',
    metadata: 'metadata',
    createdAt: 'createdAt',
    readAt: 'readAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const CannedResponseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    content: 'content',
    htmlContent: 'htmlContent',
    subject: 'subject',
    category: 'category',
    tags: 'tags',
    channels: 'channels',
    variables: 'variables',
    useCount: 'useCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CannedResponseScalarFieldEnum = (typeof CannedResponseScalarFieldEnum)[keyof typeof CannedResponseScalarFieldEnum]


  export const AutoResponseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    enabled: 'enabled',
    triggerType: 'triggerType',
    conditions: 'conditions',
    cannedResponseId: 'cannedResponseId',
    responseContent: 'responseContent',
    responseSubject: 'responseSubject',
    channels: 'channels',
    priority: 'priority',
    delaySeconds: 'delaySeconds',
    maxPerDay: 'maxPerDay',
    maxPerContact: 'maxPerContact',
    triggerCount: 'triggerCount',
    lastTriggeredAt: 'lastTriggeredAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AutoResponseScalarFieldEnum = (typeof AutoResponseScalarFieldEnum)[keyof typeof AutoResponseScalarFieldEnum]


  export const ConversationNoteScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    userId: 'userId',
    content: 'content',
    isInternal: 'isInternal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationNoteScalarFieldEnum = (typeof ConversationNoteScalarFieldEnum)[keyof typeof ConversationNoteScalarFieldEnum]


  export const SystemHealthMetricScalarFieldEnum: {
    id: 'id',
    metricName: 'metricName',
    metricValue: 'metricValue',
    metricUnit: 'metricUnit',
    component: 'component',
    severity: 'severity',
    createdAt: 'createdAt'
  };

  export type SystemHealthMetricScalarFieldEnum = (typeof SystemHealthMetricScalarFieldEnum)[keyof typeof SystemHealthMetricScalarFieldEnum]


  export const DiagnosticReportScalarFieldEnum: {
    id: 'id',
    alertId: 'alertId',
    issueType: 'issueType',
    rootCause: 'rootCause',
    evidence: 'evidence',
    aiAnalysis: 'aiAnalysis',
    aiModel: 'aiModel',
    confidenceScore: 'confidenceScore',
    suggestedFix: 'suggestedFix',
    severity: 'severity',
    affectedUsers: 'affectedUsers',
    createdAt: 'createdAt'
  };

  export type DiagnosticReportScalarFieldEnum = (typeof DiagnosticReportScalarFieldEnum)[keyof typeof DiagnosticReportScalarFieldEnum]


  export const RepairHistoryScalarFieldEnum: {
    id: 'id',
    diagnosticId: 'diagnosticId',
    repairType: 'repairType',
    fixApplied: 'fixApplied',
    fixCode: 'fixCode',
    success: 'success',
    timeToFixSeconds: 'timeToFixSeconds',
    verificationResult: 'verificationResult',
    rollbackPlan: 'rollbackPlan',
    createdAt: 'createdAt'
  };

  export type RepairHistoryScalarFieldEnum = (typeof RepairHistoryScalarFieldEnum)[keyof typeof RepairHistoryScalarFieldEnum]


  export const LearningPatternScalarFieldEnum: {
    id: 'id',
    patternHash: 'patternHash',
    symptoms: 'symptoms',
    rootCause: 'rootCause',
    solution: 'solution',
    successCount: 'successCount',
    failureCount: 'failureCount',
    avgFixTimeSeconds: 'avgFixTimeSeconds',
    autoFixEnabled: 'autoFixEnabled',
    lastAppliedAt: 'lastAppliedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LearningPatternScalarFieldEnum = (typeof LearningPatternScalarFieldEnum)[keyof typeof LearningPatternScalarFieldEnum]


  export const PredictionScalarFieldEnum: {
    id: 'id',
    predictionType: 'predictionType',
    predictedIssue: 'predictedIssue',
    predictedTime: 'predictedTime',
    confidence: 'confidence',
    dataPoints: 'dataPoints',
    proactiveAction: 'proactiveAction',
    actionTaken: 'actionTaken',
    outcome: 'outcome',
    createdAt: 'createdAt'
  };

  export type PredictionScalarFieldEnum = (typeof PredictionScalarFieldEnum)[keyof typeof PredictionScalarFieldEnum]


  export const SecurityIncidentScalarFieldEnum: {
    id: 'id',
    threatType: 'threatType',
    severity: 'severity',
    sourceIp: 'sourceIp',
    targetEndpoint: 'targetEndpoint',
    payload: 'payload',
    userId: 'userId',
    mitigationAction: 'mitigationAction',
    blocked: 'blocked',
    createdAt: 'createdAt'
  };

  export type SecurityIncidentScalarFieldEnum = (typeof SecurityIncidentScalarFieldEnum)[keyof typeof SecurityIncidentScalarFieldEnum]


  export const PerformanceMetricScalarFieldEnum: {
    id: 'id',
    metricType: 'metricType',
    endpoint: 'endpoint',
    queryHash: 'queryHash',
    valueMs: 'valueMs',
    percentile95: 'percentile95',
    percentile99: 'percentile99',
    sampleCount: 'sampleCount',
    optimizationApplied: 'optimizationApplied',
    improvementPercent: 'improvementPercent',
    createdAt: 'createdAt'
  };

  export type PerformanceMetricScalarFieldEnum = (typeof PerformanceMetricScalarFieldEnum)[keyof typeof PerformanceMetricScalarFieldEnum]


  export const SystemAlertScalarFieldEnum: {
    id: 'id',
    alertType: 'alertType',
    component: 'component',
    message: 'message',
    severity: 'severity',
    thresholdValue: 'thresholdValue',
    actualValue: 'actualValue',
    acknowledged: 'acknowledged',
    acknowledgedBy: 'acknowledgedBy',
    resolved: 'resolved',
    resolvedAt: 'resolvedAt',
    autoResolved: 'autoResolved',
    createdAt: 'createdAt'
  };

  export type SystemAlertScalarFieldEnum = (typeof SystemAlertScalarFieldEnum)[keyof typeof SystemAlertScalarFieldEnum]


  export const AdminUserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    name: 'name',
    role: 'role',
    permissions: 'permissions',
    mfaEnabled: 'mfaEnabled',
    mfaSecret: 'mfaSecret',
    lastLoginAt: 'lastLoginAt',
    lastLoginIp: 'lastLoginIp',
    failedLogins: 'failedLogins',
    lockedUntil: 'lockedUntil',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminUserScalarFieldEnum = (typeof AdminUserScalarFieldEnum)[keyof typeof AdminUserScalarFieldEnum]


  export const AdminAuditLogScalarFieldEnum: {
    id: 'id',
    adminUserId: 'adminUserId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AdminAuditLogScalarFieldEnum = (typeof AdminAuditLogScalarFieldEnum)[keyof typeof AdminAuditLogScalarFieldEnum]


  export const AdminSessionScalarFieldEnum: {
    id: 'id',
    adminUserId: 'adminUserId',
    token: 'token',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    lastActiveAt: 'lastActiveAt'
  };

  export type AdminSessionScalarFieldEnum = (typeof AdminSessionScalarFieldEnum)[keyof typeof AdminSessionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    company?: StringNullableFilter<"User"> | string | null
    tier?: IntFilter<"User"> | number
    stripeCustomerId?: StringNullableFilter<"User"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"User"> | string | null
    subscriptionStatus?: StringNullableFilter<"User"> | string | null
    trialEndsAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    leads?: LeadListRelationFilter
    campaigns?: CampaignListRelationFilter
    emailTemplates?: EmailTemplateListRelationFilter
    websites?: WebsiteListRelationFilter
    videos?: VideoListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    conversations?: ConversationListRelationFilter
    messages?: MessageListRelationFilter
    cannedResponses?: CannedResponseListRelationFilter
    autoResponses?: AutoResponseListRelationFilter
    conversationNotes?: ConversationNoteListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    tier?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    subscriptionStatus?: SortOrderInput | SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    leads?: LeadOrderByRelationAggregateInput
    campaigns?: CampaignOrderByRelationAggregateInput
    emailTemplates?: EmailTemplateOrderByRelationAggregateInput
    websites?: WebsiteOrderByRelationAggregateInput
    videos?: VideoOrderByRelationAggregateInput
    apiKeys?: ApiKeyOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    cannedResponses?: CannedResponseOrderByRelationAggregateInput
    autoResponses?: AutoResponseOrderByRelationAggregateInput
    conversationNotes?: ConversationNoteOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    company?: StringNullableFilter<"User"> | string | null
    tier?: IntFilter<"User"> | number
    stripeCustomerId?: StringNullableFilter<"User"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"User"> | string | null
    subscriptionStatus?: StringNullableFilter<"User"> | string | null
    trialEndsAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    leads?: LeadListRelationFilter
    campaigns?: CampaignListRelationFilter
    emailTemplates?: EmailTemplateListRelationFilter
    websites?: WebsiteListRelationFilter
    videos?: VideoListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    conversations?: ConversationListRelationFilter
    messages?: MessageListRelationFilter
    cannedResponses?: CannedResponseListRelationFilter
    autoResponses?: AutoResponseListRelationFilter
    conversationNotes?: ConversationNoteListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    tier?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    subscriptionStatus?: SortOrderInput | SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    company?: StringNullableWithAggregatesFilter<"User"> | string | null
    tier?: IntWithAggregatesFilter<"User"> | number
    stripeCustomerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"User"> | string | null
    subscriptionStatus?: StringNullableWithAggregatesFilter<"User"> | string | null
    trialEndsAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type LeadWhereInput = {
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    id?: StringFilter<"Lead"> | string
    userId?: StringFilter<"Lead"> | string
    email?: StringFilter<"Lead"> | string
    name?: StringNullableFilter<"Lead"> | string | null
    company?: StringNullableFilter<"Lead"> | string | null
    phone?: StringNullableFilter<"Lead"> | string | null
    title?: StringNullableFilter<"Lead"> | string | null
    website?: StringNullableFilter<"Lead"> | string | null
    linkedinUrl?: StringNullableFilter<"Lead"> | string | null
    source?: StringNullableFilter<"Lead"> | string | null
    status?: StringFilter<"Lead"> | string
    score?: IntNullableFilter<"Lead"> | number | null
    notes?: StringNullableFilter<"Lead"> | string | null
    tags?: StringNullableListFilter<"Lead">
    customFields?: JsonNullableFilter<"Lead">
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    lastContactedAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    campaignLeads?: CampaignLeadListRelationFilter
    emailEvents?: EmailEventListRelationFilter
  }

  export type LeadOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    status?: SortOrder
    score?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrder
    customFields?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastContactedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    campaignLeads?: CampaignLeadOrderByRelationAggregateInput
    emailEvents?: EmailEventOrderByRelationAggregateInput
  }

  export type LeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_email?: LeadUserIdEmailCompoundUniqueInput
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    userId?: StringFilter<"Lead"> | string
    email?: StringFilter<"Lead"> | string
    name?: StringNullableFilter<"Lead"> | string | null
    company?: StringNullableFilter<"Lead"> | string | null
    phone?: StringNullableFilter<"Lead"> | string | null
    title?: StringNullableFilter<"Lead"> | string | null
    website?: StringNullableFilter<"Lead"> | string | null
    linkedinUrl?: StringNullableFilter<"Lead"> | string | null
    source?: StringNullableFilter<"Lead"> | string | null
    status?: StringFilter<"Lead"> | string
    score?: IntNullableFilter<"Lead"> | number | null
    notes?: StringNullableFilter<"Lead"> | string | null
    tags?: StringNullableListFilter<"Lead">
    customFields?: JsonNullableFilter<"Lead">
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    lastContactedAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    campaignLeads?: CampaignLeadListRelationFilter
    emailEvents?: EmailEventListRelationFilter
  }, "id" | "userId_email">

  export type LeadOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    status?: SortOrder
    score?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrder
    customFields?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastContactedAt?: SortOrderInput | SortOrder
    _count?: LeadCountOrderByAggregateInput
    _avg?: LeadAvgOrderByAggregateInput
    _max?: LeadMaxOrderByAggregateInput
    _min?: LeadMinOrderByAggregateInput
    _sum?: LeadSumOrderByAggregateInput
  }

  export type LeadScalarWhereWithAggregatesInput = {
    AND?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    OR?: LeadScalarWhereWithAggregatesInput[]
    NOT?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lead"> | string
    userId?: StringWithAggregatesFilter<"Lead"> | string
    email?: StringWithAggregatesFilter<"Lead"> | string
    name?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    company?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    title?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    website?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    linkedinUrl?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    source?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    status?: StringWithAggregatesFilter<"Lead"> | string
    score?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    notes?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    tags?: StringNullableListFilter<"Lead">
    customFields?: JsonNullableWithAggregatesFilter<"Lead">
    createdAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    lastContactedAt?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    userId?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    type?: StringFilter<"Campaign"> | string
    status?: StringFilter<"Campaign"> | string
    subject?: StringNullableFilter<"Campaign"> | string | null
    fromName?: StringNullableFilter<"Campaign"> | string | null
    fromEmail?: StringNullableFilter<"Campaign"> | string | null
    replyTo?: StringNullableFilter<"Campaign"> | string | null
    templateId?: StringNullableFilter<"Campaign"> | string | null
    htmlContent?: StringNullableFilter<"Campaign"> | string | null
    textContent?: StringNullableFilter<"Campaign"> | string | null
    scheduledAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    totalLeads?: IntFilter<"Campaign"> | number
    sentCount?: IntFilter<"Campaign"> | number
    openCount?: IntFilter<"Campaign"> | number
    clickCount?: IntFilter<"Campaign"> | number
    replyCount?: IntFilter<"Campaign"> | number
    bounceCount?: IntFilter<"Campaign"> | number
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    template?: XOR<EmailTemplateNullableRelationFilter, EmailTemplateWhereInput> | null
    campaignLeads?: CampaignLeadListRelationFilter
    emailEvents?: EmailEventListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrderInput | SortOrder
    fromName?: SortOrderInput | SortOrder
    fromEmail?: SortOrderInput | SortOrder
    replyTo?: SortOrderInput | SortOrder
    templateId?: SortOrderInput | SortOrder
    htmlContent?: SortOrderInput | SortOrder
    textContent?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    totalLeads?: SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    replyCount?: SortOrder
    bounceCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    template?: EmailTemplateOrderByWithRelationInput
    campaignLeads?: CampaignLeadOrderByRelationAggregateInput
    emailEvents?: EmailEventOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    userId?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    type?: StringFilter<"Campaign"> | string
    status?: StringFilter<"Campaign"> | string
    subject?: StringNullableFilter<"Campaign"> | string | null
    fromName?: StringNullableFilter<"Campaign"> | string | null
    fromEmail?: StringNullableFilter<"Campaign"> | string | null
    replyTo?: StringNullableFilter<"Campaign"> | string | null
    templateId?: StringNullableFilter<"Campaign"> | string | null
    htmlContent?: StringNullableFilter<"Campaign"> | string | null
    textContent?: StringNullableFilter<"Campaign"> | string | null
    scheduledAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    totalLeads?: IntFilter<"Campaign"> | number
    sentCount?: IntFilter<"Campaign"> | number
    openCount?: IntFilter<"Campaign"> | number
    clickCount?: IntFilter<"Campaign"> | number
    replyCount?: IntFilter<"Campaign"> | number
    bounceCount?: IntFilter<"Campaign"> | number
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    template?: XOR<EmailTemplateNullableRelationFilter, EmailTemplateWhereInput> | null
    campaignLeads?: CampaignLeadListRelationFilter
    emailEvents?: EmailEventListRelationFilter
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrderInput | SortOrder
    fromName?: SortOrderInput | SortOrder
    fromEmail?: SortOrderInput | SortOrder
    replyTo?: SortOrderInput | SortOrder
    templateId?: SortOrderInput | SortOrder
    htmlContent?: SortOrderInput | SortOrder
    textContent?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    totalLeads?: SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    replyCount?: SortOrder
    bounceCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    userId?: StringWithAggregatesFilter<"Campaign"> | string
    name?: StringWithAggregatesFilter<"Campaign"> | string
    description?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    type?: StringWithAggregatesFilter<"Campaign"> | string
    status?: StringWithAggregatesFilter<"Campaign"> | string
    subject?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    fromName?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    fromEmail?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    replyTo?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    templateId?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    htmlContent?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    textContent?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    totalLeads?: IntWithAggregatesFilter<"Campaign"> | number
    sentCount?: IntWithAggregatesFilter<"Campaign"> | number
    openCount?: IntWithAggregatesFilter<"Campaign"> | number
    clickCount?: IntWithAggregatesFilter<"Campaign"> | number
    replyCount?: IntWithAggregatesFilter<"Campaign"> | number
    bounceCount?: IntWithAggregatesFilter<"Campaign"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
  }

  export type CampaignLeadWhereInput = {
    AND?: CampaignLeadWhereInput | CampaignLeadWhereInput[]
    OR?: CampaignLeadWhereInput[]
    NOT?: CampaignLeadWhereInput | CampaignLeadWhereInput[]
    id?: StringFilter<"CampaignLead"> | string
    campaignId?: StringFilter<"CampaignLead"> | string
    leadId?: StringFilter<"CampaignLead"> | string
    status?: StringFilter<"CampaignLead"> | string
    sentAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    openedAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    clickedAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    repliedAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    lead?: XOR<LeadRelationFilter, LeadWhereInput>
  }

  export type CampaignLeadOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    leadId?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    openedAt?: SortOrderInput | SortOrder
    clickedAt?: SortOrderInput | SortOrder
    repliedAt?: SortOrderInput | SortOrder
    campaign?: CampaignOrderByWithRelationInput
    lead?: LeadOrderByWithRelationInput
  }

  export type CampaignLeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignId_leadId?: CampaignLeadCampaignIdLeadIdCompoundUniqueInput
    AND?: CampaignLeadWhereInput | CampaignLeadWhereInput[]
    OR?: CampaignLeadWhereInput[]
    NOT?: CampaignLeadWhereInput | CampaignLeadWhereInput[]
    campaignId?: StringFilter<"CampaignLead"> | string
    leadId?: StringFilter<"CampaignLead"> | string
    status?: StringFilter<"CampaignLead"> | string
    sentAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    openedAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    clickedAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    repliedAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    lead?: XOR<LeadRelationFilter, LeadWhereInput>
  }, "id" | "campaignId_leadId">

  export type CampaignLeadOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    leadId?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    openedAt?: SortOrderInput | SortOrder
    clickedAt?: SortOrderInput | SortOrder
    repliedAt?: SortOrderInput | SortOrder
    _count?: CampaignLeadCountOrderByAggregateInput
    _max?: CampaignLeadMaxOrderByAggregateInput
    _min?: CampaignLeadMinOrderByAggregateInput
  }

  export type CampaignLeadScalarWhereWithAggregatesInput = {
    AND?: CampaignLeadScalarWhereWithAggregatesInput | CampaignLeadScalarWhereWithAggregatesInput[]
    OR?: CampaignLeadScalarWhereWithAggregatesInput[]
    NOT?: CampaignLeadScalarWhereWithAggregatesInput | CampaignLeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignLead"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignLead"> | string
    leadId?: StringWithAggregatesFilter<"CampaignLead"> | string
    status?: StringWithAggregatesFilter<"CampaignLead"> | string
    sentAt?: DateTimeNullableWithAggregatesFilter<"CampaignLead"> | Date | string | null
    openedAt?: DateTimeNullableWithAggregatesFilter<"CampaignLead"> | Date | string | null
    clickedAt?: DateTimeNullableWithAggregatesFilter<"CampaignLead"> | Date | string | null
    repliedAt?: DateTimeNullableWithAggregatesFilter<"CampaignLead"> | Date | string | null
  }

  export type EmailTemplateWhereInput = {
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    id?: StringFilter<"EmailTemplate"> | string
    userId?: StringFilter<"EmailTemplate"> | string
    name?: StringFilter<"EmailTemplate"> | string
    subject?: StringNullableFilter<"EmailTemplate"> | string | null
    htmlContent?: StringNullableFilter<"EmailTemplate"> | string | null
    textContent?: StringNullableFilter<"EmailTemplate"> | string | null
    variables?: StringNullableListFilter<"EmailTemplate">
    isDefault?: BoolFilter<"EmailTemplate"> | boolean
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    campaigns?: CampaignListRelationFilter
  }

  export type EmailTemplateOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    subject?: SortOrderInput | SortOrder
    htmlContent?: SortOrderInput | SortOrder
    textContent?: SortOrderInput | SortOrder
    variables?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    campaigns?: CampaignOrderByRelationAggregateInput
  }

  export type EmailTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    userId?: StringFilter<"EmailTemplate"> | string
    name?: StringFilter<"EmailTemplate"> | string
    subject?: StringNullableFilter<"EmailTemplate"> | string | null
    htmlContent?: StringNullableFilter<"EmailTemplate"> | string | null
    textContent?: StringNullableFilter<"EmailTemplate"> | string | null
    variables?: StringNullableListFilter<"EmailTemplate">
    isDefault?: BoolFilter<"EmailTemplate"> | boolean
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    campaigns?: CampaignListRelationFilter
  }, "id">

  export type EmailTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    subject?: SortOrderInput | SortOrder
    htmlContent?: SortOrderInput | SortOrder
    textContent?: SortOrderInput | SortOrder
    variables?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailTemplateCountOrderByAggregateInput
    _max?: EmailTemplateMaxOrderByAggregateInput
    _min?: EmailTemplateMinOrderByAggregateInput
  }

  export type EmailTemplateScalarWhereWithAggregatesInput = {
    AND?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    OR?: EmailTemplateScalarWhereWithAggregatesInput[]
    NOT?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailTemplate"> | string
    userId?: StringWithAggregatesFilter<"EmailTemplate"> | string
    name?: StringWithAggregatesFilter<"EmailTemplate"> | string
    subject?: StringNullableWithAggregatesFilter<"EmailTemplate"> | string | null
    htmlContent?: StringNullableWithAggregatesFilter<"EmailTemplate"> | string | null
    textContent?: StringNullableWithAggregatesFilter<"EmailTemplate"> | string | null
    variables?: StringNullableListFilter<"EmailTemplate">
    isDefault?: BoolWithAggregatesFilter<"EmailTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
  }

  export type EmailEventWhereInput = {
    AND?: EmailEventWhereInput | EmailEventWhereInput[]
    OR?: EmailEventWhereInput[]
    NOT?: EmailEventWhereInput | EmailEventWhereInput[]
    id?: StringFilter<"EmailEvent"> | string
    campaignId?: StringFilter<"EmailEvent"> | string
    leadId?: StringFilter<"EmailEvent"> | string
    eventType?: StringFilter<"EmailEvent"> | string
    eventData?: JsonNullableFilter<"EmailEvent">
    createdAt?: DateTimeFilter<"EmailEvent"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    lead?: XOR<LeadRelationFilter, LeadWhereInput>
  }

  export type EmailEventOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    leadId?: SortOrder
    eventType?: SortOrder
    eventData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    lead?: LeadOrderByWithRelationInput
  }

  export type EmailEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailEventWhereInput | EmailEventWhereInput[]
    OR?: EmailEventWhereInput[]
    NOT?: EmailEventWhereInput | EmailEventWhereInput[]
    campaignId?: StringFilter<"EmailEvent"> | string
    leadId?: StringFilter<"EmailEvent"> | string
    eventType?: StringFilter<"EmailEvent"> | string
    eventData?: JsonNullableFilter<"EmailEvent">
    createdAt?: DateTimeFilter<"EmailEvent"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    lead?: XOR<LeadRelationFilter, LeadWhereInput>
  }, "id">

  export type EmailEventOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    leadId?: SortOrder
    eventType?: SortOrder
    eventData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EmailEventCountOrderByAggregateInput
    _max?: EmailEventMaxOrderByAggregateInput
    _min?: EmailEventMinOrderByAggregateInput
  }

  export type EmailEventScalarWhereWithAggregatesInput = {
    AND?: EmailEventScalarWhereWithAggregatesInput | EmailEventScalarWhereWithAggregatesInput[]
    OR?: EmailEventScalarWhereWithAggregatesInput[]
    NOT?: EmailEventScalarWhereWithAggregatesInput | EmailEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailEvent"> | string
    campaignId?: StringWithAggregatesFilter<"EmailEvent"> | string
    leadId?: StringWithAggregatesFilter<"EmailEvent"> | string
    eventType?: StringWithAggregatesFilter<"EmailEvent"> | string
    eventData?: JsonNullableWithAggregatesFilter<"EmailEvent">
    createdAt?: DateTimeWithAggregatesFilter<"EmailEvent"> | Date | string
  }

  export type WebsiteWhereInput = {
    AND?: WebsiteWhereInput | WebsiteWhereInput[]
    OR?: WebsiteWhereInput[]
    NOT?: WebsiteWhereInput | WebsiteWhereInput[]
    id?: StringFilter<"Website"> | string
    userId?: StringFilter<"Website"> | string
    name?: StringFilter<"Website"> | string
    domain?: StringNullableFilter<"Website"> | string | null
    subdomain?: StringNullableFilter<"Website"> | string | null
    pages?: JsonNullableFilter<"Website">
    settings?: JsonNullableFilter<"Website">
    theme?: StringNullableFilter<"Website"> | string | null
    isPublished?: BoolFilter<"Website"> | boolean
    createdAt?: DateTimeFilter<"Website"> | Date | string
    updatedAt?: DateTimeFilter<"Website"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WebsiteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    domain?: SortOrderInput | SortOrder
    subdomain?: SortOrderInput | SortOrder
    pages?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    theme?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type WebsiteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subdomain?: string
    AND?: WebsiteWhereInput | WebsiteWhereInput[]
    OR?: WebsiteWhereInput[]
    NOT?: WebsiteWhereInput | WebsiteWhereInput[]
    userId?: StringFilter<"Website"> | string
    name?: StringFilter<"Website"> | string
    domain?: StringNullableFilter<"Website"> | string | null
    pages?: JsonNullableFilter<"Website">
    settings?: JsonNullableFilter<"Website">
    theme?: StringNullableFilter<"Website"> | string | null
    isPublished?: BoolFilter<"Website"> | boolean
    createdAt?: DateTimeFilter<"Website"> | Date | string
    updatedAt?: DateTimeFilter<"Website"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "subdomain">

  export type WebsiteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    domain?: SortOrderInput | SortOrder
    subdomain?: SortOrderInput | SortOrder
    pages?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    theme?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WebsiteCountOrderByAggregateInput
    _max?: WebsiteMaxOrderByAggregateInput
    _min?: WebsiteMinOrderByAggregateInput
  }

  export type WebsiteScalarWhereWithAggregatesInput = {
    AND?: WebsiteScalarWhereWithAggregatesInput | WebsiteScalarWhereWithAggregatesInput[]
    OR?: WebsiteScalarWhereWithAggregatesInput[]
    NOT?: WebsiteScalarWhereWithAggregatesInput | WebsiteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Website"> | string
    userId?: StringWithAggregatesFilter<"Website"> | string
    name?: StringWithAggregatesFilter<"Website"> | string
    domain?: StringNullableWithAggregatesFilter<"Website"> | string | null
    subdomain?: StringNullableWithAggregatesFilter<"Website"> | string | null
    pages?: JsonNullableWithAggregatesFilter<"Website">
    settings?: JsonNullableWithAggregatesFilter<"Website">
    theme?: StringNullableWithAggregatesFilter<"Website"> | string | null
    isPublished?: BoolWithAggregatesFilter<"Website"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Website"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Website"> | Date | string
  }

  export type VideoWhereInput = {
    AND?: VideoWhereInput | VideoWhereInput[]
    OR?: VideoWhereInput[]
    NOT?: VideoWhereInput | VideoWhereInput[]
    id?: StringFilter<"Video"> | string
    userId?: StringFilter<"Video"> | string
    title?: StringFilter<"Video"> | string
    description?: StringNullableFilter<"Video"> | string | null
    filename?: StringNullableFilter<"Video"> | string | null
    fileUrl?: StringNullableFilter<"Video"> | string | null
    thumbnailUrl?: StringNullableFilter<"Video"> | string | null
    duration?: IntNullableFilter<"Video"> | number | null
    fileSize?: IntNullableFilter<"Video"> | number | null
    isMonetized?: BoolFilter<"Video"> | boolean
    viewCount?: IntFilter<"Video"> | number
    earnings?: DecimalFilter<"Video"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Video"> | string
    createdAt?: DateTimeFilter<"Video"> | Date | string
    updatedAt?: DateTimeFilter<"Video"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type VideoOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    filename?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    isMonetized?: SortOrder
    viewCount?: SortOrder
    earnings?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type VideoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VideoWhereInput | VideoWhereInput[]
    OR?: VideoWhereInput[]
    NOT?: VideoWhereInput | VideoWhereInput[]
    userId?: StringFilter<"Video"> | string
    title?: StringFilter<"Video"> | string
    description?: StringNullableFilter<"Video"> | string | null
    filename?: StringNullableFilter<"Video"> | string | null
    fileUrl?: StringNullableFilter<"Video"> | string | null
    thumbnailUrl?: StringNullableFilter<"Video"> | string | null
    duration?: IntNullableFilter<"Video"> | number | null
    fileSize?: IntNullableFilter<"Video"> | number | null
    isMonetized?: BoolFilter<"Video"> | boolean
    viewCount?: IntFilter<"Video"> | number
    earnings?: DecimalFilter<"Video"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Video"> | string
    createdAt?: DateTimeFilter<"Video"> | Date | string
    updatedAt?: DateTimeFilter<"Video"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type VideoOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    filename?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    isMonetized?: SortOrder
    viewCount?: SortOrder
    earnings?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VideoCountOrderByAggregateInput
    _avg?: VideoAvgOrderByAggregateInput
    _max?: VideoMaxOrderByAggregateInput
    _min?: VideoMinOrderByAggregateInput
    _sum?: VideoSumOrderByAggregateInput
  }

  export type VideoScalarWhereWithAggregatesInput = {
    AND?: VideoScalarWhereWithAggregatesInput | VideoScalarWhereWithAggregatesInput[]
    OR?: VideoScalarWhereWithAggregatesInput[]
    NOT?: VideoScalarWhereWithAggregatesInput | VideoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Video"> | string
    userId?: StringWithAggregatesFilter<"Video"> | string
    title?: StringWithAggregatesFilter<"Video"> | string
    description?: StringNullableWithAggregatesFilter<"Video"> | string | null
    filename?: StringNullableWithAggregatesFilter<"Video"> | string | null
    fileUrl?: StringNullableWithAggregatesFilter<"Video"> | string | null
    thumbnailUrl?: StringNullableWithAggregatesFilter<"Video"> | string | null
    duration?: IntNullableWithAggregatesFilter<"Video"> | number | null
    fileSize?: IntNullableWithAggregatesFilter<"Video"> | number | null
    isMonetized?: BoolWithAggregatesFilter<"Video"> | boolean
    viewCount?: IntWithAggregatesFilter<"Video"> | number
    earnings?: DecimalWithAggregatesFilter<"Video"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"Video"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Video"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Video"> | Date | string
  }

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    userId?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    key?: StringFilter<"ApiKey"> | string
    permissions?: StringNullableListFilter<"ApiKey">
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    isActive?: BoolFilter<"ApiKey"> | boolean
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    key?: SortOrder
    permissions?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    userId?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    permissions?: StringNullableListFilter<"ApiKey">
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    isActive?: BoolFilter<"ApiKey"> | boolean
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "key">

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    key?: SortOrder
    permissions?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: ApiKeyCountOrderByAggregateInput
    _max?: ApiKeyMaxOrderByAggregateInput
    _min?: ApiKeyMinOrderByAggregateInput
  }

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    OR?: ApiKeyScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKey"> | string
    userId?: StringWithAggregatesFilter<"ApiKey"> | string
    name?: StringWithAggregatesFilter<"ApiKey"> | string
    key?: StringWithAggregatesFilter<"ApiKey"> | string
    permissions?: StringNullableListFilter<"ApiKey">
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"ApiKey"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    userId?: StringFilter<"Conversation"> | string
    contactName?: StringNullableFilter<"Conversation"> | string | null
    contactEmail?: StringNullableFilter<"Conversation"> | string | null
    contactPhone?: StringNullableFilter<"Conversation"> | string | null
    contactId?: StringNullableFilter<"Conversation"> | string | null
    channel?: StringFilter<"Conversation"> | string
    channelId?: StringNullableFilter<"Conversation"> | string | null
    subject?: StringNullableFilter<"Conversation"> | string | null
    status?: StringFilter<"Conversation"> | string
    priority?: StringFilter<"Conversation"> | string
    assignedTo?: StringNullableFilter<"Conversation"> | string | null
    tags?: StringNullableListFilter<"Conversation">
    labels?: StringNullableListFilter<"Conversation">
    messageCount?: IntFilter<"Conversation"> | number
    unreadCount?: IntFilter<"Conversation"> | number
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
    notes?: ConversationNoteListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    contactName?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    channel?: SortOrder
    channelId?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    tags?: SortOrder
    labels?: SortOrder
    messageCount?: SortOrder
    unreadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
    notes?: ConversationNoteOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    userId?: StringFilter<"Conversation"> | string
    contactName?: StringNullableFilter<"Conversation"> | string | null
    contactEmail?: StringNullableFilter<"Conversation"> | string | null
    contactPhone?: StringNullableFilter<"Conversation"> | string | null
    contactId?: StringNullableFilter<"Conversation"> | string | null
    channel?: StringFilter<"Conversation"> | string
    channelId?: StringNullableFilter<"Conversation"> | string | null
    subject?: StringNullableFilter<"Conversation"> | string | null
    status?: StringFilter<"Conversation"> | string
    priority?: StringFilter<"Conversation"> | string
    assignedTo?: StringNullableFilter<"Conversation"> | string | null
    tags?: StringNullableListFilter<"Conversation">
    labels?: StringNullableListFilter<"Conversation">
    messageCount?: IntFilter<"Conversation"> | number
    unreadCount?: IntFilter<"Conversation"> | number
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
    notes?: ConversationNoteListRelationFilter
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    contactName?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    channel?: SortOrder
    channelId?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    tags?: SortOrder
    labels?: SortOrder
    messageCount?: SortOrder
    unreadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _avg?: ConversationAvgOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
    _sum?: ConversationSumOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    userId?: StringWithAggregatesFilter<"Conversation"> | string
    contactName?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    contactId?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    channel?: StringWithAggregatesFilter<"Conversation"> | string
    channelId?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    subject?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    status?: StringWithAggregatesFilter<"Conversation"> | string
    priority?: StringWithAggregatesFilter<"Conversation"> | string
    assignedTo?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    tags?: StringNullableListFilter<"Conversation">
    labels?: StringNullableListFilter<"Conversation">
    messageCount?: IntWithAggregatesFilter<"Conversation"> | number
    unreadCount?: IntWithAggregatesFilter<"Conversation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    lastMessageAt?: DateTimeNullableWithAggregatesFilter<"Conversation"> | Date | string | null
    closedAt?: DateTimeNullableWithAggregatesFilter<"Conversation"> | Date | string | null
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    userId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    htmlContent?: StringNullableFilter<"Message"> | string | null
    subject?: StringNullableFilter<"Message"> | string | null
    channel?: StringFilter<"Message"> | string
    channelMessageId?: StringNullableFilter<"Message"> | string | null
    direction?: StringFilter<"Message"> | string
    status?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    attachments?: JsonNullableFilter<"Message">
    metadata?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    htmlContent?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    channel?: SortOrder
    channelMessageId?: SortOrderInput | SortOrder
    direction?: SortOrder
    status?: SortOrder
    isRead?: SortOrder
    attachments?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    conversation?: ConversationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversationId?: StringFilter<"Message"> | string
    userId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    htmlContent?: StringNullableFilter<"Message"> | string | null
    subject?: StringNullableFilter<"Message"> | string | null
    channel?: StringFilter<"Message"> | string
    channelMessageId?: StringNullableFilter<"Message"> | string | null
    direction?: StringFilter<"Message"> | string
    status?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    attachments?: JsonNullableFilter<"Message">
    metadata?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    htmlContent?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    channel?: SortOrder
    channelMessageId?: SortOrderInput | SortOrder
    direction?: SortOrder
    status?: SortOrder
    isRead?: SortOrder
    attachments?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    conversationId?: StringWithAggregatesFilter<"Message"> | string
    userId?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    htmlContent?: StringNullableWithAggregatesFilter<"Message"> | string | null
    subject?: StringNullableWithAggregatesFilter<"Message"> | string | null
    channel?: StringWithAggregatesFilter<"Message"> | string
    channelMessageId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    direction?: StringWithAggregatesFilter<"Message"> | string
    status?: StringWithAggregatesFilter<"Message"> | string
    isRead?: BoolWithAggregatesFilter<"Message"> | boolean
    attachments?: JsonNullableWithAggregatesFilter<"Message">
    metadata?: JsonNullableWithAggregatesFilter<"Message">
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
  }

  export type CannedResponseWhereInput = {
    AND?: CannedResponseWhereInput | CannedResponseWhereInput[]
    OR?: CannedResponseWhereInput[]
    NOT?: CannedResponseWhereInput | CannedResponseWhereInput[]
    id?: StringFilter<"CannedResponse"> | string
    userId?: StringFilter<"CannedResponse"> | string
    name?: StringFilter<"CannedResponse"> | string
    content?: StringFilter<"CannedResponse"> | string
    htmlContent?: StringNullableFilter<"CannedResponse"> | string | null
    subject?: StringNullableFilter<"CannedResponse"> | string | null
    category?: StringNullableFilter<"CannedResponse"> | string | null
    tags?: StringNullableListFilter<"CannedResponse">
    channels?: StringNullableListFilter<"CannedResponse">
    variables?: StringNullableListFilter<"CannedResponse">
    useCount?: IntFilter<"CannedResponse"> | number
    createdAt?: DateTimeFilter<"CannedResponse"> | Date | string
    updatedAt?: DateTimeFilter<"CannedResponse"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    AutoResponse?: AutoResponseListRelationFilter
  }

  export type CannedResponseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    content?: SortOrder
    htmlContent?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrder
    channels?: SortOrder
    variables?: SortOrder
    useCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    AutoResponse?: AutoResponseOrderByRelationAggregateInput
  }

  export type CannedResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CannedResponseWhereInput | CannedResponseWhereInput[]
    OR?: CannedResponseWhereInput[]
    NOT?: CannedResponseWhereInput | CannedResponseWhereInput[]
    userId?: StringFilter<"CannedResponse"> | string
    name?: StringFilter<"CannedResponse"> | string
    content?: StringFilter<"CannedResponse"> | string
    htmlContent?: StringNullableFilter<"CannedResponse"> | string | null
    subject?: StringNullableFilter<"CannedResponse"> | string | null
    category?: StringNullableFilter<"CannedResponse"> | string | null
    tags?: StringNullableListFilter<"CannedResponse">
    channels?: StringNullableListFilter<"CannedResponse">
    variables?: StringNullableListFilter<"CannedResponse">
    useCount?: IntFilter<"CannedResponse"> | number
    createdAt?: DateTimeFilter<"CannedResponse"> | Date | string
    updatedAt?: DateTimeFilter<"CannedResponse"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    AutoResponse?: AutoResponseListRelationFilter
  }, "id">

  export type CannedResponseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    content?: SortOrder
    htmlContent?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrder
    channels?: SortOrder
    variables?: SortOrder
    useCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CannedResponseCountOrderByAggregateInput
    _avg?: CannedResponseAvgOrderByAggregateInput
    _max?: CannedResponseMaxOrderByAggregateInput
    _min?: CannedResponseMinOrderByAggregateInput
    _sum?: CannedResponseSumOrderByAggregateInput
  }

  export type CannedResponseScalarWhereWithAggregatesInput = {
    AND?: CannedResponseScalarWhereWithAggregatesInput | CannedResponseScalarWhereWithAggregatesInput[]
    OR?: CannedResponseScalarWhereWithAggregatesInput[]
    NOT?: CannedResponseScalarWhereWithAggregatesInput | CannedResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CannedResponse"> | string
    userId?: StringWithAggregatesFilter<"CannedResponse"> | string
    name?: StringWithAggregatesFilter<"CannedResponse"> | string
    content?: StringWithAggregatesFilter<"CannedResponse"> | string
    htmlContent?: StringNullableWithAggregatesFilter<"CannedResponse"> | string | null
    subject?: StringNullableWithAggregatesFilter<"CannedResponse"> | string | null
    category?: StringNullableWithAggregatesFilter<"CannedResponse"> | string | null
    tags?: StringNullableListFilter<"CannedResponse">
    channels?: StringNullableListFilter<"CannedResponse">
    variables?: StringNullableListFilter<"CannedResponse">
    useCount?: IntWithAggregatesFilter<"CannedResponse"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CannedResponse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CannedResponse"> | Date | string
  }

  export type AutoResponseWhereInput = {
    AND?: AutoResponseWhereInput | AutoResponseWhereInput[]
    OR?: AutoResponseWhereInput[]
    NOT?: AutoResponseWhereInput | AutoResponseWhereInput[]
    id?: StringFilter<"AutoResponse"> | string
    userId?: StringFilter<"AutoResponse"> | string
    name?: StringFilter<"AutoResponse"> | string
    description?: StringNullableFilter<"AutoResponse"> | string | null
    enabled?: BoolFilter<"AutoResponse"> | boolean
    triggerType?: StringFilter<"AutoResponse"> | string
    conditions?: JsonFilter<"AutoResponse">
    cannedResponseId?: StringNullableFilter<"AutoResponse"> | string | null
    responseContent?: StringNullableFilter<"AutoResponse"> | string | null
    responseSubject?: StringNullableFilter<"AutoResponse"> | string | null
    channels?: StringNullableListFilter<"AutoResponse">
    priority?: IntFilter<"AutoResponse"> | number
    delaySeconds?: IntFilter<"AutoResponse"> | number
    maxPerDay?: IntNullableFilter<"AutoResponse"> | number | null
    maxPerContact?: IntNullableFilter<"AutoResponse"> | number | null
    triggerCount?: IntFilter<"AutoResponse"> | number
    lastTriggeredAt?: DateTimeNullableFilter<"AutoResponse"> | Date | string | null
    createdAt?: DateTimeFilter<"AutoResponse"> | Date | string
    updatedAt?: DateTimeFilter<"AutoResponse"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    cannedResponse?: XOR<CannedResponseNullableRelationFilter, CannedResponseWhereInput> | null
  }

  export type AutoResponseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    enabled?: SortOrder
    triggerType?: SortOrder
    conditions?: SortOrder
    cannedResponseId?: SortOrderInput | SortOrder
    responseContent?: SortOrderInput | SortOrder
    responseSubject?: SortOrderInput | SortOrder
    channels?: SortOrder
    priority?: SortOrder
    delaySeconds?: SortOrder
    maxPerDay?: SortOrderInput | SortOrder
    maxPerContact?: SortOrderInput | SortOrder
    triggerCount?: SortOrder
    lastTriggeredAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    cannedResponse?: CannedResponseOrderByWithRelationInput
  }

  export type AutoResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutoResponseWhereInput | AutoResponseWhereInput[]
    OR?: AutoResponseWhereInput[]
    NOT?: AutoResponseWhereInput | AutoResponseWhereInput[]
    userId?: StringFilter<"AutoResponse"> | string
    name?: StringFilter<"AutoResponse"> | string
    description?: StringNullableFilter<"AutoResponse"> | string | null
    enabled?: BoolFilter<"AutoResponse"> | boolean
    triggerType?: StringFilter<"AutoResponse"> | string
    conditions?: JsonFilter<"AutoResponse">
    cannedResponseId?: StringNullableFilter<"AutoResponse"> | string | null
    responseContent?: StringNullableFilter<"AutoResponse"> | string | null
    responseSubject?: StringNullableFilter<"AutoResponse"> | string | null
    channels?: StringNullableListFilter<"AutoResponse">
    priority?: IntFilter<"AutoResponse"> | number
    delaySeconds?: IntFilter<"AutoResponse"> | number
    maxPerDay?: IntNullableFilter<"AutoResponse"> | number | null
    maxPerContact?: IntNullableFilter<"AutoResponse"> | number | null
    triggerCount?: IntFilter<"AutoResponse"> | number
    lastTriggeredAt?: DateTimeNullableFilter<"AutoResponse"> | Date | string | null
    createdAt?: DateTimeFilter<"AutoResponse"> | Date | string
    updatedAt?: DateTimeFilter<"AutoResponse"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    cannedResponse?: XOR<CannedResponseNullableRelationFilter, CannedResponseWhereInput> | null
  }, "id">

  export type AutoResponseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    enabled?: SortOrder
    triggerType?: SortOrder
    conditions?: SortOrder
    cannedResponseId?: SortOrderInput | SortOrder
    responseContent?: SortOrderInput | SortOrder
    responseSubject?: SortOrderInput | SortOrder
    channels?: SortOrder
    priority?: SortOrder
    delaySeconds?: SortOrder
    maxPerDay?: SortOrderInput | SortOrder
    maxPerContact?: SortOrderInput | SortOrder
    triggerCount?: SortOrder
    lastTriggeredAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AutoResponseCountOrderByAggregateInput
    _avg?: AutoResponseAvgOrderByAggregateInput
    _max?: AutoResponseMaxOrderByAggregateInput
    _min?: AutoResponseMinOrderByAggregateInput
    _sum?: AutoResponseSumOrderByAggregateInput
  }

  export type AutoResponseScalarWhereWithAggregatesInput = {
    AND?: AutoResponseScalarWhereWithAggregatesInput | AutoResponseScalarWhereWithAggregatesInput[]
    OR?: AutoResponseScalarWhereWithAggregatesInput[]
    NOT?: AutoResponseScalarWhereWithAggregatesInput | AutoResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutoResponse"> | string
    userId?: StringWithAggregatesFilter<"AutoResponse"> | string
    name?: StringWithAggregatesFilter<"AutoResponse"> | string
    description?: StringNullableWithAggregatesFilter<"AutoResponse"> | string | null
    enabled?: BoolWithAggregatesFilter<"AutoResponse"> | boolean
    triggerType?: StringWithAggregatesFilter<"AutoResponse"> | string
    conditions?: JsonWithAggregatesFilter<"AutoResponse">
    cannedResponseId?: StringNullableWithAggregatesFilter<"AutoResponse"> | string | null
    responseContent?: StringNullableWithAggregatesFilter<"AutoResponse"> | string | null
    responseSubject?: StringNullableWithAggregatesFilter<"AutoResponse"> | string | null
    channels?: StringNullableListFilter<"AutoResponse">
    priority?: IntWithAggregatesFilter<"AutoResponse"> | number
    delaySeconds?: IntWithAggregatesFilter<"AutoResponse"> | number
    maxPerDay?: IntNullableWithAggregatesFilter<"AutoResponse"> | number | null
    maxPerContact?: IntNullableWithAggregatesFilter<"AutoResponse"> | number | null
    triggerCount?: IntWithAggregatesFilter<"AutoResponse"> | number
    lastTriggeredAt?: DateTimeNullableWithAggregatesFilter<"AutoResponse"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AutoResponse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AutoResponse"> | Date | string
  }

  export type ConversationNoteWhereInput = {
    AND?: ConversationNoteWhereInput | ConversationNoteWhereInput[]
    OR?: ConversationNoteWhereInput[]
    NOT?: ConversationNoteWhereInput | ConversationNoteWhereInput[]
    id?: StringFilter<"ConversationNote"> | string
    conversationId?: StringFilter<"ConversationNote"> | string
    userId?: StringFilter<"ConversationNote"> | string
    content?: StringFilter<"ConversationNote"> | string
    isInternal?: BoolFilter<"ConversationNote"> | boolean
    createdAt?: DateTimeFilter<"ConversationNote"> | Date | string
    updatedAt?: DateTimeFilter<"ConversationNote"> | Date | string
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ConversationNoteOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ConversationNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationNoteWhereInput | ConversationNoteWhereInput[]
    OR?: ConversationNoteWhereInput[]
    NOT?: ConversationNoteWhereInput | ConversationNoteWhereInput[]
    conversationId?: StringFilter<"ConversationNote"> | string
    userId?: StringFilter<"ConversationNote"> | string
    content?: StringFilter<"ConversationNote"> | string
    isInternal?: BoolFilter<"ConversationNote"> | boolean
    createdAt?: DateTimeFilter<"ConversationNote"> | Date | string
    updatedAt?: DateTimeFilter<"ConversationNote"> | Date | string
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ConversationNoteOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversationNoteCountOrderByAggregateInput
    _max?: ConversationNoteMaxOrderByAggregateInput
    _min?: ConversationNoteMinOrderByAggregateInput
  }

  export type ConversationNoteScalarWhereWithAggregatesInput = {
    AND?: ConversationNoteScalarWhereWithAggregatesInput | ConversationNoteScalarWhereWithAggregatesInput[]
    OR?: ConversationNoteScalarWhereWithAggregatesInput[]
    NOT?: ConversationNoteScalarWhereWithAggregatesInput | ConversationNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConversationNote"> | string
    conversationId?: StringWithAggregatesFilter<"ConversationNote"> | string
    userId?: StringWithAggregatesFilter<"ConversationNote"> | string
    content?: StringWithAggregatesFilter<"ConversationNote"> | string
    isInternal?: BoolWithAggregatesFilter<"ConversationNote"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ConversationNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConversationNote"> | Date | string
  }

  export type SystemHealthMetricWhereInput = {
    AND?: SystemHealthMetricWhereInput | SystemHealthMetricWhereInput[]
    OR?: SystemHealthMetricWhereInput[]
    NOT?: SystemHealthMetricWhereInput | SystemHealthMetricWhereInput[]
    id?: StringFilter<"SystemHealthMetric"> | string
    metricName?: StringFilter<"SystemHealthMetric"> | string
    metricValue?: DecimalFilter<"SystemHealthMetric"> | Decimal | DecimalJsLike | number | string
    metricUnit?: StringNullableFilter<"SystemHealthMetric"> | string | null
    component?: StringFilter<"SystemHealthMetric"> | string
    severity?: StringFilter<"SystemHealthMetric"> | string
    createdAt?: DateTimeFilter<"SystemHealthMetric"> | Date | string
  }

  export type SystemHealthMetricOrderByWithRelationInput = {
    id?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    metricUnit?: SortOrderInput | SortOrder
    component?: SortOrder
    severity?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemHealthMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemHealthMetricWhereInput | SystemHealthMetricWhereInput[]
    OR?: SystemHealthMetricWhereInput[]
    NOT?: SystemHealthMetricWhereInput | SystemHealthMetricWhereInput[]
    metricName?: StringFilter<"SystemHealthMetric"> | string
    metricValue?: DecimalFilter<"SystemHealthMetric"> | Decimal | DecimalJsLike | number | string
    metricUnit?: StringNullableFilter<"SystemHealthMetric"> | string | null
    component?: StringFilter<"SystemHealthMetric"> | string
    severity?: StringFilter<"SystemHealthMetric"> | string
    createdAt?: DateTimeFilter<"SystemHealthMetric"> | Date | string
  }, "id">

  export type SystemHealthMetricOrderByWithAggregationInput = {
    id?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    metricUnit?: SortOrderInput | SortOrder
    component?: SortOrder
    severity?: SortOrder
    createdAt?: SortOrder
    _count?: SystemHealthMetricCountOrderByAggregateInput
    _avg?: SystemHealthMetricAvgOrderByAggregateInput
    _max?: SystemHealthMetricMaxOrderByAggregateInput
    _min?: SystemHealthMetricMinOrderByAggregateInput
    _sum?: SystemHealthMetricSumOrderByAggregateInput
  }

  export type SystemHealthMetricScalarWhereWithAggregatesInput = {
    AND?: SystemHealthMetricScalarWhereWithAggregatesInput | SystemHealthMetricScalarWhereWithAggregatesInput[]
    OR?: SystemHealthMetricScalarWhereWithAggregatesInput[]
    NOT?: SystemHealthMetricScalarWhereWithAggregatesInput | SystemHealthMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemHealthMetric"> | string
    metricName?: StringWithAggregatesFilter<"SystemHealthMetric"> | string
    metricValue?: DecimalWithAggregatesFilter<"SystemHealthMetric"> | Decimal | DecimalJsLike | number | string
    metricUnit?: StringNullableWithAggregatesFilter<"SystemHealthMetric"> | string | null
    component?: StringWithAggregatesFilter<"SystemHealthMetric"> | string
    severity?: StringWithAggregatesFilter<"SystemHealthMetric"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SystemHealthMetric"> | Date | string
  }

  export type DiagnosticReportWhereInput = {
    AND?: DiagnosticReportWhereInput | DiagnosticReportWhereInput[]
    OR?: DiagnosticReportWhereInput[]
    NOT?: DiagnosticReportWhereInput | DiagnosticReportWhereInput[]
    id?: StringFilter<"DiagnosticReport"> | string
    alertId?: StringNullableFilter<"DiagnosticReport"> | string | null
    issueType?: StringFilter<"DiagnosticReport"> | string
    rootCause?: StringNullableFilter<"DiagnosticReport"> | string | null
    evidence?: JsonNullableFilter<"DiagnosticReport">
    aiAnalysis?: StringNullableFilter<"DiagnosticReport"> | string | null
    aiModel?: StringNullableFilter<"DiagnosticReport"> | string | null
    confidenceScore?: DecimalNullableFilter<"DiagnosticReport"> | Decimal | DecimalJsLike | number | string | null
    suggestedFix?: StringNullableFilter<"DiagnosticReport"> | string | null
    severity?: StringNullableFilter<"DiagnosticReport"> | string | null
    affectedUsers?: IntNullableFilter<"DiagnosticReport"> | number | null
    createdAt?: DateTimeFilter<"DiagnosticReport"> | Date | string
    repairs?: RepairHistoryListRelationFilter
  }

  export type DiagnosticReportOrderByWithRelationInput = {
    id?: SortOrder
    alertId?: SortOrderInput | SortOrder
    issueType?: SortOrder
    rootCause?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    aiAnalysis?: SortOrderInput | SortOrder
    aiModel?: SortOrderInput | SortOrder
    confidenceScore?: SortOrderInput | SortOrder
    suggestedFix?: SortOrderInput | SortOrder
    severity?: SortOrderInput | SortOrder
    affectedUsers?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    repairs?: RepairHistoryOrderByRelationAggregateInput
  }

  export type DiagnosticReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DiagnosticReportWhereInput | DiagnosticReportWhereInput[]
    OR?: DiagnosticReportWhereInput[]
    NOT?: DiagnosticReportWhereInput | DiagnosticReportWhereInput[]
    alertId?: StringNullableFilter<"DiagnosticReport"> | string | null
    issueType?: StringFilter<"DiagnosticReport"> | string
    rootCause?: StringNullableFilter<"DiagnosticReport"> | string | null
    evidence?: JsonNullableFilter<"DiagnosticReport">
    aiAnalysis?: StringNullableFilter<"DiagnosticReport"> | string | null
    aiModel?: StringNullableFilter<"DiagnosticReport"> | string | null
    confidenceScore?: DecimalNullableFilter<"DiagnosticReport"> | Decimal | DecimalJsLike | number | string | null
    suggestedFix?: StringNullableFilter<"DiagnosticReport"> | string | null
    severity?: StringNullableFilter<"DiagnosticReport"> | string | null
    affectedUsers?: IntNullableFilter<"DiagnosticReport"> | number | null
    createdAt?: DateTimeFilter<"DiagnosticReport"> | Date | string
    repairs?: RepairHistoryListRelationFilter
  }, "id">

  export type DiagnosticReportOrderByWithAggregationInput = {
    id?: SortOrder
    alertId?: SortOrderInput | SortOrder
    issueType?: SortOrder
    rootCause?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    aiAnalysis?: SortOrderInput | SortOrder
    aiModel?: SortOrderInput | SortOrder
    confidenceScore?: SortOrderInput | SortOrder
    suggestedFix?: SortOrderInput | SortOrder
    severity?: SortOrderInput | SortOrder
    affectedUsers?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DiagnosticReportCountOrderByAggregateInput
    _avg?: DiagnosticReportAvgOrderByAggregateInput
    _max?: DiagnosticReportMaxOrderByAggregateInput
    _min?: DiagnosticReportMinOrderByAggregateInput
    _sum?: DiagnosticReportSumOrderByAggregateInput
  }

  export type DiagnosticReportScalarWhereWithAggregatesInput = {
    AND?: DiagnosticReportScalarWhereWithAggregatesInput | DiagnosticReportScalarWhereWithAggregatesInput[]
    OR?: DiagnosticReportScalarWhereWithAggregatesInput[]
    NOT?: DiagnosticReportScalarWhereWithAggregatesInput | DiagnosticReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DiagnosticReport"> | string
    alertId?: StringNullableWithAggregatesFilter<"DiagnosticReport"> | string | null
    issueType?: StringWithAggregatesFilter<"DiagnosticReport"> | string
    rootCause?: StringNullableWithAggregatesFilter<"DiagnosticReport"> | string | null
    evidence?: JsonNullableWithAggregatesFilter<"DiagnosticReport">
    aiAnalysis?: StringNullableWithAggregatesFilter<"DiagnosticReport"> | string | null
    aiModel?: StringNullableWithAggregatesFilter<"DiagnosticReport"> | string | null
    confidenceScore?: DecimalNullableWithAggregatesFilter<"DiagnosticReport"> | Decimal | DecimalJsLike | number | string | null
    suggestedFix?: StringNullableWithAggregatesFilter<"DiagnosticReport"> | string | null
    severity?: StringNullableWithAggregatesFilter<"DiagnosticReport"> | string | null
    affectedUsers?: IntNullableWithAggregatesFilter<"DiagnosticReport"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"DiagnosticReport"> | Date | string
  }

  export type RepairHistoryWhereInput = {
    AND?: RepairHistoryWhereInput | RepairHistoryWhereInput[]
    OR?: RepairHistoryWhereInput[]
    NOT?: RepairHistoryWhereInput | RepairHistoryWhereInput[]
    id?: StringFilter<"RepairHistory"> | string
    diagnosticId?: StringNullableFilter<"RepairHistory"> | string | null
    repairType?: StringFilter<"RepairHistory"> | string
    fixApplied?: StringNullableFilter<"RepairHistory"> | string | null
    fixCode?: StringNullableFilter<"RepairHistory"> | string | null
    success?: BoolFilter<"RepairHistory"> | boolean
    timeToFixSeconds?: IntNullableFilter<"RepairHistory"> | number | null
    verificationResult?: JsonNullableFilter<"RepairHistory">
    rollbackPlan?: StringNullableFilter<"RepairHistory"> | string | null
    createdAt?: DateTimeFilter<"RepairHistory"> | Date | string
    diagnostic?: XOR<DiagnosticReportNullableRelationFilter, DiagnosticReportWhereInput> | null
  }

  export type RepairHistoryOrderByWithRelationInput = {
    id?: SortOrder
    diagnosticId?: SortOrderInput | SortOrder
    repairType?: SortOrder
    fixApplied?: SortOrderInput | SortOrder
    fixCode?: SortOrderInput | SortOrder
    success?: SortOrder
    timeToFixSeconds?: SortOrderInput | SortOrder
    verificationResult?: SortOrderInput | SortOrder
    rollbackPlan?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    diagnostic?: DiagnosticReportOrderByWithRelationInput
  }

  export type RepairHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RepairHistoryWhereInput | RepairHistoryWhereInput[]
    OR?: RepairHistoryWhereInput[]
    NOT?: RepairHistoryWhereInput | RepairHistoryWhereInput[]
    diagnosticId?: StringNullableFilter<"RepairHistory"> | string | null
    repairType?: StringFilter<"RepairHistory"> | string
    fixApplied?: StringNullableFilter<"RepairHistory"> | string | null
    fixCode?: StringNullableFilter<"RepairHistory"> | string | null
    success?: BoolFilter<"RepairHistory"> | boolean
    timeToFixSeconds?: IntNullableFilter<"RepairHistory"> | number | null
    verificationResult?: JsonNullableFilter<"RepairHistory">
    rollbackPlan?: StringNullableFilter<"RepairHistory"> | string | null
    createdAt?: DateTimeFilter<"RepairHistory"> | Date | string
    diagnostic?: XOR<DiagnosticReportNullableRelationFilter, DiagnosticReportWhereInput> | null
  }, "id">

  export type RepairHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    diagnosticId?: SortOrderInput | SortOrder
    repairType?: SortOrder
    fixApplied?: SortOrderInput | SortOrder
    fixCode?: SortOrderInput | SortOrder
    success?: SortOrder
    timeToFixSeconds?: SortOrderInput | SortOrder
    verificationResult?: SortOrderInput | SortOrder
    rollbackPlan?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RepairHistoryCountOrderByAggregateInput
    _avg?: RepairHistoryAvgOrderByAggregateInput
    _max?: RepairHistoryMaxOrderByAggregateInput
    _min?: RepairHistoryMinOrderByAggregateInput
    _sum?: RepairHistorySumOrderByAggregateInput
  }

  export type RepairHistoryScalarWhereWithAggregatesInput = {
    AND?: RepairHistoryScalarWhereWithAggregatesInput | RepairHistoryScalarWhereWithAggregatesInput[]
    OR?: RepairHistoryScalarWhereWithAggregatesInput[]
    NOT?: RepairHistoryScalarWhereWithAggregatesInput | RepairHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RepairHistory"> | string
    diagnosticId?: StringNullableWithAggregatesFilter<"RepairHistory"> | string | null
    repairType?: StringWithAggregatesFilter<"RepairHistory"> | string
    fixApplied?: StringNullableWithAggregatesFilter<"RepairHistory"> | string | null
    fixCode?: StringNullableWithAggregatesFilter<"RepairHistory"> | string | null
    success?: BoolWithAggregatesFilter<"RepairHistory"> | boolean
    timeToFixSeconds?: IntNullableWithAggregatesFilter<"RepairHistory"> | number | null
    verificationResult?: JsonNullableWithAggregatesFilter<"RepairHistory">
    rollbackPlan?: StringNullableWithAggregatesFilter<"RepairHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RepairHistory"> | Date | string
  }

  export type LearningPatternWhereInput = {
    AND?: LearningPatternWhereInput | LearningPatternWhereInput[]
    OR?: LearningPatternWhereInput[]
    NOT?: LearningPatternWhereInput | LearningPatternWhereInput[]
    id?: StringFilter<"LearningPattern"> | string
    patternHash?: StringFilter<"LearningPattern"> | string
    symptoms?: JsonFilter<"LearningPattern">
    rootCause?: StringNullableFilter<"LearningPattern"> | string | null
    solution?: StringNullableFilter<"LearningPattern"> | string | null
    successCount?: IntFilter<"LearningPattern"> | number
    failureCount?: IntFilter<"LearningPattern"> | number
    avgFixTimeSeconds?: IntNullableFilter<"LearningPattern"> | number | null
    autoFixEnabled?: BoolFilter<"LearningPattern"> | boolean
    lastAppliedAt?: DateTimeNullableFilter<"LearningPattern"> | Date | string | null
    createdAt?: DateTimeFilter<"LearningPattern"> | Date | string
    updatedAt?: DateTimeFilter<"LearningPattern"> | Date | string
  }

  export type LearningPatternOrderByWithRelationInput = {
    id?: SortOrder
    patternHash?: SortOrder
    symptoms?: SortOrder
    rootCause?: SortOrderInput | SortOrder
    solution?: SortOrderInput | SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    avgFixTimeSeconds?: SortOrderInput | SortOrder
    autoFixEnabled?: SortOrder
    lastAppliedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LearningPatternWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    patternHash?: string
    AND?: LearningPatternWhereInput | LearningPatternWhereInput[]
    OR?: LearningPatternWhereInput[]
    NOT?: LearningPatternWhereInput | LearningPatternWhereInput[]
    symptoms?: JsonFilter<"LearningPattern">
    rootCause?: StringNullableFilter<"LearningPattern"> | string | null
    solution?: StringNullableFilter<"LearningPattern"> | string | null
    successCount?: IntFilter<"LearningPattern"> | number
    failureCount?: IntFilter<"LearningPattern"> | number
    avgFixTimeSeconds?: IntNullableFilter<"LearningPattern"> | number | null
    autoFixEnabled?: BoolFilter<"LearningPattern"> | boolean
    lastAppliedAt?: DateTimeNullableFilter<"LearningPattern"> | Date | string | null
    createdAt?: DateTimeFilter<"LearningPattern"> | Date | string
    updatedAt?: DateTimeFilter<"LearningPattern"> | Date | string
  }, "id" | "patternHash">

  export type LearningPatternOrderByWithAggregationInput = {
    id?: SortOrder
    patternHash?: SortOrder
    symptoms?: SortOrder
    rootCause?: SortOrderInput | SortOrder
    solution?: SortOrderInput | SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    avgFixTimeSeconds?: SortOrderInput | SortOrder
    autoFixEnabled?: SortOrder
    lastAppliedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LearningPatternCountOrderByAggregateInput
    _avg?: LearningPatternAvgOrderByAggregateInput
    _max?: LearningPatternMaxOrderByAggregateInput
    _min?: LearningPatternMinOrderByAggregateInput
    _sum?: LearningPatternSumOrderByAggregateInput
  }

  export type LearningPatternScalarWhereWithAggregatesInput = {
    AND?: LearningPatternScalarWhereWithAggregatesInput | LearningPatternScalarWhereWithAggregatesInput[]
    OR?: LearningPatternScalarWhereWithAggregatesInput[]
    NOT?: LearningPatternScalarWhereWithAggregatesInput | LearningPatternScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LearningPattern"> | string
    patternHash?: StringWithAggregatesFilter<"LearningPattern"> | string
    symptoms?: JsonWithAggregatesFilter<"LearningPattern">
    rootCause?: StringNullableWithAggregatesFilter<"LearningPattern"> | string | null
    solution?: StringNullableWithAggregatesFilter<"LearningPattern"> | string | null
    successCount?: IntWithAggregatesFilter<"LearningPattern"> | number
    failureCount?: IntWithAggregatesFilter<"LearningPattern"> | number
    avgFixTimeSeconds?: IntNullableWithAggregatesFilter<"LearningPattern"> | number | null
    autoFixEnabled?: BoolWithAggregatesFilter<"LearningPattern"> | boolean
    lastAppliedAt?: DateTimeNullableWithAggregatesFilter<"LearningPattern"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LearningPattern"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LearningPattern"> | Date | string
  }

  export type PredictionWhereInput = {
    AND?: PredictionWhereInput | PredictionWhereInput[]
    OR?: PredictionWhereInput[]
    NOT?: PredictionWhereInput | PredictionWhereInput[]
    id?: StringFilter<"Prediction"> | string
    predictionType?: StringFilter<"Prediction"> | string
    predictedIssue?: StringNullableFilter<"Prediction"> | string | null
    predictedTime?: DateTimeNullableFilter<"Prediction"> | Date | string | null
    confidence?: DecimalNullableFilter<"Prediction"> | Decimal | DecimalJsLike | number | string | null
    dataPoints?: JsonNullableFilter<"Prediction">
    proactiveAction?: StringNullableFilter<"Prediction"> | string | null
    actionTaken?: BoolFilter<"Prediction"> | boolean
    outcome?: StringNullableFilter<"Prediction"> | string | null
    createdAt?: DateTimeFilter<"Prediction"> | Date | string
  }

  export type PredictionOrderByWithRelationInput = {
    id?: SortOrder
    predictionType?: SortOrder
    predictedIssue?: SortOrderInput | SortOrder
    predictedTime?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    dataPoints?: SortOrderInput | SortOrder
    proactiveAction?: SortOrderInput | SortOrder
    actionTaken?: SortOrder
    outcome?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type PredictionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PredictionWhereInput | PredictionWhereInput[]
    OR?: PredictionWhereInput[]
    NOT?: PredictionWhereInput | PredictionWhereInput[]
    predictionType?: StringFilter<"Prediction"> | string
    predictedIssue?: StringNullableFilter<"Prediction"> | string | null
    predictedTime?: DateTimeNullableFilter<"Prediction"> | Date | string | null
    confidence?: DecimalNullableFilter<"Prediction"> | Decimal | DecimalJsLike | number | string | null
    dataPoints?: JsonNullableFilter<"Prediction">
    proactiveAction?: StringNullableFilter<"Prediction"> | string | null
    actionTaken?: BoolFilter<"Prediction"> | boolean
    outcome?: StringNullableFilter<"Prediction"> | string | null
    createdAt?: DateTimeFilter<"Prediction"> | Date | string
  }, "id">

  export type PredictionOrderByWithAggregationInput = {
    id?: SortOrder
    predictionType?: SortOrder
    predictedIssue?: SortOrderInput | SortOrder
    predictedTime?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    dataPoints?: SortOrderInput | SortOrder
    proactiveAction?: SortOrderInput | SortOrder
    actionTaken?: SortOrder
    outcome?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PredictionCountOrderByAggregateInput
    _avg?: PredictionAvgOrderByAggregateInput
    _max?: PredictionMaxOrderByAggregateInput
    _min?: PredictionMinOrderByAggregateInput
    _sum?: PredictionSumOrderByAggregateInput
  }

  export type PredictionScalarWhereWithAggregatesInput = {
    AND?: PredictionScalarWhereWithAggregatesInput | PredictionScalarWhereWithAggregatesInput[]
    OR?: PredictionScalarWhereWithAggregatesInput[]
    NOT?: PredictionScalarWhereWithAggregatesInput | PredictionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Prediction"> | string
    predictionType?: StringWithAggregatesFilter<"Prediction"> | string
    predictedIssue?: StringNullableWithAggregatesFilter<"Prediction"> | string | null
    predictedTime?: DateTimeNullableWithAggregatesFilter<"Prediction"> | Date | string | null
    confidence?: DecimalNullableWithAggregatesFilter<"Prediction"> | Decimal | DecimalJsLike | number | string | null
    dataPoints?: JsonNullableWithAggregatesFilter<"Prediction">
    proactiveAction?: StringNullableWithAggregatesFilter<"Prediction"> | string | null
    actionTaken?: BoolWithAggregatesFilter<"Prediction"> | boolean
    outcome?: StringNullableWithAggregatesFilter<"Prediction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Prediction"> | Date | string
  }

  export type SecurityIncidentWhereInput = {
    AND?: SecurityIncidentWhereInput | SecurityIncidentWhereInput[]
    OR?: SecurityIncidentWhereInput[]
    NOT?: SecurityIncidentWhereInput | SecurityIncidentWhereInput[]
    id?: StringFilter<"SecurityIncident"> | string
    threatType?: StringFilter<"SecurityIncident"> | string
    severity?: StringNullableFilter<"SecurityIncident"> | string | null
    sourceIp?: StringNullableFilter<"SecurityIncident"> | string | null
    targetEndpoint?: StringNullableFilter<"SecurityIncident"> | string | null
    payload?: StringNullableFilter<"SecurityIncident"> | string | null
    userId?: StringNullableFilter<"SecurityIncident"> | string | null
    mitigationAction?: StringNullableFilter<"SecurityIncident"> | string | null
    blocked?: BoolFilter<"SecurityIncident"> | boolean
    createdAt?: DateTimeFilter<"SecurityIncident"> | Date | string
  }

  export type SecurityIncidentOrderByWithRelationInput = {
    id?: SortOrder
    threatType?: SortOrder
    severity?: SortOrderInput | SortOrder
    sourceIp?: SortOrderInput | SortOrder
    targetEndpoint?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    mitigationAction?: SortOrderInput | SortOrder
    blocked?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityIncidentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SecurityIncidentWhereInput | SecurityIncidentWhereInput[]
    OR?: SecurityIncidentWhereInput[]
    NOT?: SecurityIncidentWhereInput | SecurityIncidentWhereInput[]
    threatType?: StringFilter<"SecurityIncident"> | string
    severity?: StringNullableFilter<"SecurityIncident"> | string | null
    sourceIp?: StringNullableFilter<"SecurityIncident"> | string | null
    targetEndpoint?: StringNullableFilter<"SecurityIncident"> | string | null
    payload?: StringNullableFilter<"SecurityIncident"> | string | null
    userId?: StringNullableFilter<"SecurityIncident"> | string | null
    mitigationAction?: StringNullableFilter<"SecurityIncident"> | string | null
    blocked?: BoolFilter<"SecurityIncident"> | boolean
    createdAt?: DateTimeFilter<"SecurityIncident"> | Date | string
  }, "id">

  export type SecurityIncidentOrderByWithAggregationInput = {
    id?: SortOrder
    threatType?: SortOrder
    severity?: SortOrderInput | SortOrder
    sourceIp?: SortOrderInput | SortOrder
    targetEndpoint?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    mitigationAction?: SortOrderInput | SortOrder
    blocked?: SortOrder
    createdAt?: SortOrder
    _count?: SecurityIncidentCountOrderByAggregateInput
    _max?: SecurityIncidentMaxOrderByAggregateInput
    _min?: SecurityIncidentMinOrderByAggregateInput
  }

  export type SecurityIncidentScalarWhereWithAggregatesInput = {
    AND?: SecurityIncidentScalarWhereWithAggregatesInput | SecurityIncidentScalarWhereWithAggregatesInput[]
    OR?: SecurityIncidentScalarWhereWithAggregatesInput[]
    NOT?: SecurityIncidentScalarWhereWithAggregatesInput | SecurityIncidentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SecurityIncident"> | string
    threatType?: StringWithAggregatesFilter<"SecurityIncident"> | string
    severity?: StringNullableWithAggregatesFilter<"SecurityIncident"> | string | null
    sourceIp?: StringNullableWithAggregatesFilter<"SecurityIncident"> | string | null
    targetEndpoint?: StringNullableWithAggregatesFilter<"SecurityIncident"> | string | null
    payload?: StringNullableWithAggregatesFilter<"SecurityIncident"> | string | null
    userId?: StringNullableWithAggregatesFilter<"SecurityIncident"> | string | null
    mitigationAction?: StringNullableWithAggregatesFilter<"SecurityIncident"> | string | null
    blocked?: BoolWithAggregatesFilter<"SecurityIncident"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SecurityIncident"> | Date | string
  }

  export type PerformanceMetricWhereInput = {
    AND?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    OR?: PerformanceMetricWhereInput[]
    NOT?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    id?: StringFilter<"PerformanceMetric"> | string
    metricType?: StringFilter<"PerformanceMetric"> | string
    endpoint?: StringNullableFilter<"PerformanceMetric"> | string | null
    queryHash?: StringNullableFilter<"PerformanceMetric"> | string | null
    valueMs?: DecimalNullableFilter<"PerformanceMetric"> | Decimal | DecimalJsLike | number | string | null
    percentile95?: DecimalNullableFilter<"PerformanceMetric"> | Decimal | DecimalJsLike | number | string | null
    percentile99?: DecimalNullableFilter<"PerformanceMetric"> | Decimal | DecimalJsLike | number | string | null
    sampleCount?: IntNullableFilter<"PerformanceMetric"> | number | null
    optimizationApplied?: StringNullableFilter<"PerformanceMetric"> | string | null
    improvementPercent?: DecimalNullableFilter<"PerformanceMetric"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"PerformanceMetric"> | Date | string
  }

  export type PerformanceMetricOrderByWithRelationInput = {
    id?: SortOrder
    metricType?: SortOrder
    endpoint?: SortOrderInput | SortOrder
    queryHash?: SortOrderInput | SortOrder
    valueMs?: SortOrderInput | SortOrder
    percentile95?: SortOrderInput | SortOrder
    percentile99?: SortOrderInput | SortOrder
    sampleCount?: SortOrderInput | SortOrder
    optimizationApplied?: SortOrderInput | SortOrder
    improvementPercent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type PerformanceMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    OR?: PerformanceMetricWhereInput[]
    NOT?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    metricType?: StringFilter<"PerformanceMetric"> | string
    endpoint?: StringNullableFilter<"PerformanceMetric"> | string | null
    queryHash?: StringNullableFilter<"PerformanceMetric"> | string | null
    valueMs?: DecimalNullableFilter<"PerformanceMetric"> | Decimal | DecimalJsLike | number | string | null
    percentile95?: DecimalNullableFilter<"PerformanceMetric"> | Decimal | DecimalJsLike | number | string | null
    percentile99?: DecimalNullableFilter<"PerformanceMetric"> | Decimal | DecimalJsLike | number | string | null
    sampleCount?: IntNullableFilter<"PerformanceMetric"> | number | null
    optimizationApplied?: StringNullableFilter<"PerformanceMetric"> | string | null
    improvementPercent?: DecimalNullableFilter<"PerformanceMetric"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"PerformanceMetric"> | Date | string
  }, "id">

  export type PerformanceMetricOrderByWithAggregationInput = {
    id?: SortOrder
    metricType?: SortOrder
    endpoint?: SortOrderInput | SortOrder
    queryHash?: SortOrderInput | SortOrder
    valueMs?: SortOrderInput | SortOrder
    percentile95?: SortOrderInput | SortOrder
    percentile99?: SortOrderInput | SortOrder
    sampleCount?: SortOrderInput | SortOrder
    optimizationApplied?: SortOrderInput | SortOrder
    improvementPercent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PerformanceMetricCountOrderByAggregateInput
    _avg?: PerformanceMetricAvgOrderByAggregateInput
    _max?: PerformanceMetricMaxOrderByAggregateInput
    _min?: PerformanceMetricMinOrderByAggregateInput
    _sum?: PerformanceMetricSumOrderByAggregateInput
  }

  export type PerformanceMetricScalarWhereWithAggregatesInput = {
    AND?: PerformanceMetricScalarWhereWithAggregatesInput | PerformanceMetricScalarWhereWithAggregatesInput[]
    OR?: PerformanceMetricScalarWhereWithAggregatesInput[]
    NOT?: PerformanceMetricScalarWhereWithAggregatesInput | PerformanceMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PerformanceMetric"> | string
    metricType?: StringWithAggregatesFilter<"PerformanceMetric"> | string
    endpoint?: StringNullableWithAggregatesFilter<"PerformanceMetric"> | string | null
    queryHash?: StringNullableWithAggregatesFilter<"PerformanceMetric"> | string | null
    valueMs?: DecimalNullableWithAggregatesFilter<"PerformanceMetric"> | Decimal | DecimalJsLike | number | string | null
    percentile95?: DecimalNullableWithAggregatesFilter<"PerformanceMetric"> | Decimal | DecimalJsLike | number | string | null
    percentile99?: DecimalNullableWithAggregatesFilter<"PerformanceMetric"> | Decimal | DecimalJsLike | number | string | null
    sampleCount?: IntNullableWithAggregatesFilter<"PerformanceMetric"> | number | null
    optimizationApplied?: StringNullableWithAggregatesFilter<"PerformanceMetric"> | string | null
    improvementPercent?: DecimalNullableWithAggregatesFilter<"PerformanceMetric"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PerformanceMetric"> | Date | string
  }

  export type SystemAlertWhereInput = {
    AND?: SystemAlertWhereInput | SystemAlertWhereInput[]
    OR?: SystemAlertWhereInput[]
    NOT?: SystemAlertWhereInput | SystemAlertWhereInput[]
    id?: StringFilter<"SystemAlert"> | string
    alertType?: StringFilter<"SystemAlert"> | string
    component?: StringNullableFilter<"SystemAlert"> | string | null
    message?: StringNullableFilter<"SystemAlert"> | string | null
    severity?: StringNullableFilter<"SystemAlert"> | string | null
    thresholdValue?: DecimalNullableFilter<"SystemAlert"> | Decimal | DecimalJsLike | number | string | null
    actualValue?: DecimalNullableFilter<"SystemAlert"> | Decimal | DecimalJsLike | number | string | null
    acknowledged?: BoolFilter<"SystemAlert"> | boolean
    acknowledgedBy?: StringNullableFilter<"SystemAlert"> | string | null
    resolved?: BoolFilter<"SystemAlert"> | boolean
    resolvedAt?: DateTimeNullableFilter<"SystemAlert"> | Date | string | null
    autoResolved?: BoolFilter<"SystemAlert"> | boolean
    createdAt?: DateTimeFilter<"SystemAlert"> | Date | string
  }

  export type SystemAlertOrderByWithRelationInput = {
    id?: SortOrder
    alertType?: SortOrder
    component?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    severity?: SortOrderInput | SortOrder
    thresholdValue?: SortOrderInput | SortOrder
    actualValue?: SortOrderInput | SortOrder
    acknowledged?: SortOrder
    acknowledgedBy?: SortOrderInput | SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    autoResolved?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemAlertWhereInput | SystemAlertWhereInput[]
    OR?: SystemAlertWhereInput[]
    NOT?: SystemAlertWhereInput | SystemAlertWhereInput[]
    alertType?: StringFilter<"SystemAlert"> | string
    component?: StringNullableFilter<"SystemAlert"> | string | null
    message?: StringNullableFilter<"SystemAlert"> | string | null
    severity?: StringNullableFilter<"SystemAlert"> | string | null
    thresholdValue?: DecimalNullableFilter<"SystemAlert"> | Decimal | DecimalJsLike | number | string | null
    actualValue?: DecimalNullableFilter<"SystemAlert"> | Decimal | DecimalJsLike | number | string | null
    acknowledged?: BoolFilter<"SystemAlert"> | boolean
    acknowledgedBy?: StringNullableFilter<"SystemAlert"> | string | null
    resolved?: BoolFilter<"SystemAlert"> | boolean
    resolvedAt?: DateTimeNullableFilter<"SystemAlert"> | Date | string | null
    autoResolved?: BoolFilter<"SystemAlert"> | boolean
    createdAt?: DateTimeFilter<"SystemAlert"> | Date | string
  }, "id">

  export type SystemAlertOrderByWithAggregationInput = {
    id?: SortOrder
    alertType?: SortOrder
    component?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    severity?: SortOrderInput | SortOrder
    thresholdValue?: SortOrderInput | SortOrder
    actualValue?: SortOrderInput | SortOrder
    acknowledged?: SortOrder
    acknowledgedBy?: SortOrderInput | SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    autoResolved?: SortOrder
    createdAt?: SortOrder
    _count?: SystemAlertCountOrderByAggregateInput
    _avg?: SystemAlertAvgOrderByAggregateInput
    _max?: SystemAlertMaxOrderByAggregateInput
    _min?: SystemAlertMinOrderByAggregateInput
    _sum?: SystemAlertSumOrderByAggregateInput
  }

  export type SystemAlertScalarWhereWithAggregatesInput = {
    AND?: SystemAlertScalarWhereWithAggregatesInput | SystemAlertScalarWhereWithAggregatesInput[]
    OR?: SystemAlertScalarWhereWithAggregatesInput[]
    NOT?: SystemAlertScalarWhereWithAggregatesInput | SystemAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemAlert"> | string
    alertType?: StringWithAggregatesFilter<"SystemAlert"> | string
    component?: StringNullableWithAggregatesFilter<"SystemAlert"> | string | null
    message?: StringNullableWithAggregatesFilter<"SystemAlert"> | string | null
    severity?: StringNullableWithAggregatesFilter<"SystemAlert"> | string | null
    thresholdValue?: DecimalNullableWithAggregatesFilter<"SystemAlert"> | Decimal | DecimalJsLike | number | string | null
    actualValue?: DecimalNullableWithAggregatesFilter<"SystemAlert"> | Decimal | DecimalJsLike | number | string | null
    acknowledged?: BoolWithAggregatesFilter<"SystemAlert"> | boolean
    acknowledgedBy?: StringNullableWithAggregatesFilter<"SystemAlert"> | string | null
    resolved?: BoolWithAggregatesFilter<"SystemAlert"> | boolean
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"SystemAlert"> | Date | string | null
    autoResolved?: BoolWithAggregatesFilter<"SystemAlert"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SystemAlert"> | Date | string
  }

  export type AdminUserWhereInput = {
    AND?: AdminUserWhereInput | AdminUserWhereInput[]
    OR?: AdminUserWhereInput[]
    NOT?: AdminUserWhereInput | AdminUserWhereInput[]
    id?: StringFilter<"AdminUser"> | string
    email?: StringFilter<"AdminUser"> | string
    passwordHash?: StringFilter<"AdminUser"> | string
    name?: StringFilter<"AdminUser"> | string
    role?: StringFilter<"AdminUser"> | string
    permissions?: StringNullableListFilter<"AdminUser">
    mfaEnabled?: BoolFilter<"AdminUser"> | boolean
    mfaSecret?: StringNullableFilter<"AdminUser"> | string | null
    lastLoginAt?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"AdminUser"> | string | null
    failedLogins?: IntFilter<"AdminUser"> | number
    lockedUntil?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    createdBy?: StringNullableFilter<"AdminUser"> | string | null
    createdAt?: DateTimeFilter<"AdminUser"> | Date | string
    updatedAt?: DateTimeFilter<"AdminUser"> | Date | string
    auditLogs?: AdminAuditLogListRelationFilter
  }

  export type AdminUserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    failedLogins?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    auditLogs?: AdminAuditLogOrderByRelationAggregateInput
  }

  export type AdminUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: AdminUserWhereInput | AdminUserWhereInput[]
    OR?: AdminUserWhereInput[]
    NOT?: AdminUserWhereInput | AdminUserWhereInput[]
    passwordHash?: StringFilter<"AdminUser"> | string
    name?: StringFilter<"AdminUser"> | string
    role?: StringFilter<"AdminUser"> | string
    permissions?: StringNullableListFilter<"AdminUser">
    mfaEnabled?: BoolFilter<"AdminUser"> | boolean
    mfaSecret?: StringNullableFilter<"AdminUser"> | string | null
    lastLoginAt?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"AdminUser"> | string | null
    failedLogins?: IntFilter<"AdminUser"> | number
    lockedUntil?: DateTimeNullableFilter<"AdminUser"> | Date | string | null
    createdBy?: StringNullableFilter<"AdminUser"> | string | null
    createdAt?: DateTimeFilter<"AdminUser"> | Date | string
    updatedAt?: DateTimeFilter<"AdminUser"> | Date | string
    auditLogs?: AdminAuditLogListRelationFilter
  }, "id" | "email">

  export type AdminUserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    failedLogins?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminUserCountOrderByAggregateInput
    _avg?: AdminUserAvgOrderByAggregateInput
    _max?: AdminUserMaxOrderByAggregateInput
    _min?: AdminUserMinOrderByAggregateInput
    _sum?: AdminUserSumOrderByAggregateInput
  }

  export type AdminUserScalarWhereWithAggregatesInput = {
    AND?: AdminUserScalarWhereWithAggregatesInput | AdminUserScalarWhereWithAggregatesInput[]
    OR?: AdminUserScalarWhereWithAggregatesInput[]
    NOT?: AdminUserScalarWhereWithAggregatesInput | AdminUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminUser"> | string
    email?: StringWithAggregatesFilter<"AdminUser"> | string
    passwordHash?: StringWithAggregatesFilter<"AdminUser"> | string
    name?: StringWithAggregatesFilter<"AdminUser"> | string
    role?: StringWithAggregatesFilter<"AdminUser"> | string
    permissions?: StringNullableListFilter<"AdminUser">
    mfaEnabled?: BoolWithAggregatesFilter<"AdminUser"> | boolean
    mfaSecret?: StringNullableWithAggregatesFilter<"AdminUser"> | string | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"AdminUser"> | Date | string | null
    lastLoginIp?: StringNullableWithAggregatesFilter<"AdminUser"> | string | null
    failedLogins?: IntWithAggregatesFilter<"AdminUser"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"AdminUser"> | Date | string | null
    createdBy?: StringNullableWithAggregatesFilter<"AdminUser"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdminUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminUser"> | Date | string
  }

  export type AdminAuditLogWhereInput = {
    AND?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    OR?: AdminAuditLogWhereInput[]
    NOT?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    id?: StringFilter<"AdminAuditLog"> | string
    adminUserId?: StringFilter<"AdminAuditLog"> | string
    action?: StringFilter<"AdminAuditLog"> | string
    resource?: StringNullableFilter<"AdminAuditLog"> | string | null
    resourceId?: StringNullableFilter<"AdminAuditLog"> | string | null
    details?: JsonNullableFilter<"AdminAuditLog">
    ipAddress?: StringNullableFilter<"AdminAuditLog"> | string | null
    userAgent?: StringNullableFilter<"AdminAuditLog"> | string | null
    createdAt?: DateTimeFilter<"AdminAuditLog"> | Date | string
    adminUser?: XOR<AdminUserRelationFilter, AdminUserWhereInput>
  }

  export type AdminAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    adminUserId?: SortOrder
    action?: SortOrder
    resource?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    adminUser?: AdminUserOrderByWithRelationInput
  }

  export type AdminAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    OR?: AdminAuditLogWhereInput[]
    NOT?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    adminUserId?: StringFilter<"AdminAuditLog"> | string
    action?: StringFilter<"AdminAuditLog"> | string
    resource?: StringNullableFilter<"AdminAuditLog"> | string | null
    resourceId?: StringNullableFilter<"AdminAuditLog"> | string | null
    details?: JsonNullableFilter<"AdminAuditLog">
    ipAddress?: StringNullableFilter<"AdminAuditLog"> | string | null
    userAgent?: StringNullableFilter<"AdminAuditLog"> | string | null
    createdAt?: DateTimeFilter<"AdminAuditLog"> | Date | string
    adminUser?: XOR<AdminUserRelationFilter, AdminUserWhereInput>
  }, "id">

  export type AdminAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    adminUserId?: SortOrder
    action?: SortOrder
    resource?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AdminAuditLogCountOrderByAggregateInput
    _max?: AdminAuditLogMaxOrderByAggregateInput
    _min?: AdminAuditLogMinOrderByAggregateInput
  }

  export type AdminAuditLogScalarWhereWithAggregatesInput = {
    AND?: AdminAuditLogScalarWhereWithAggregatesInput | AdminAuditLogScalarWhereWithAggregatesInput[]
    OR?: AdminAuditLogScalarWhereWithAggregatesInput[]
    NOT?: AdminAuditLogScalarWhereWithAggregatesInput | AdminAuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    adminUserId?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    action?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    resource?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    resourceId?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AdminAuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdminAuditLog"> | Date | string
  }

  export type AdminSessionWhereInput = {
    AND?: AdminSessionWhereInput | AdminSessionWhereInput[]
    OR?: AdminSessionWhereInput[]
    NOT?: AdminSessionWhereInput | AdminSessionWhereInput[]
    id?: StringFilter<"AdminSession"> | string
    adminUserId?: StringFilter<"AdminSession"> | string
    token?: StringFilter<"AdminSession"> | string
    ipAddress?: StringNullableFilter<"AdminSession"> | string | null
    userAgent?: StringNullableFilter<"AdminSession"> | string | null
    expiresAt?: DateTimeFilter<"AdminSession"> | Date | string
    createdAt?: DateTimeFilter<"AdminSession"> | Date | string
    lastActiveAt?: DateTimeFilter<"AdminSession"> | Date | string
  }

  export type AdminSessionOrderByWithRelationInput = {
    id?: SortOrder
    adminUserId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    lastActiveAt?: SortOrder
  }

  export type AdminSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: AdminSessionWhereInput | AdminSessionWhereInput[]
    OR?: AdminSessionWhereInput[]
    NOT?: AdminSessionWhereInput | AdminSessionWhereInput[]
    adminUserId?: StringFilter<"AdminSession"> | string
    ipAddress?: StringNullableFilter<"AdminSession"> | string | null
    userAgent?: StringNullableFilter<"AdminSession"> | string | null
    expiresAt?: DateTimeFilter<"AdminSession"> | Date | string
    createdAt?: DateTimeFilter<"AdminSession"> | Date | string
    lastActiveAt?: DateTimeFilter<"AdminSession"> | Date | string
  }, "id" | "token">

  export type AdminSessionOrderByWithAggregationInput = {
    id?: SortOrder
    adminUserId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    lastActiveAt?: SortOrder
    _count?: AdminSessionCountOrderByAggregateInput
    _max?: AdminSessionMaxOrderByAggregateInput
    _min?: AdminSessionMinOrderByAggregateInput
  }

  export type AdminSessionScalarWhereWithAggregatesInput = {
    AND?: AdminSessionScalarWhereWithAggregatesInput | AdminSessionScalarWhereWithAggregatesInput[]
    OR?: AdminSessionScalarWhereWithAggregatesInput[]
    NOT?: AdminSessionScalarWhereWithAggregatesInput | AdminSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminSession"> | string
    adminUserId?: StringWithAggregatesFilter<"AdminSession"> | string
    token?: StringWithAggregatesFilter<"AdminSession"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"AdminSession"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AdminSession"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"AdminSession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminSession"> | Date | string
    lastActiveAt?: DateTimeWithAggregatesFilter<"AdminSession"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    leads?: LeadCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutUserInput
    websites?: WebsiteCreateNestedManyWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    cannedResponses?: CannedResponseCreateNestedManyWithoutUserInput
    autoResponses?: AutoResponseCreateNestedManyWithoutUserInput
    conversationNotes?: ConversationNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    leads?: LeadUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    websites?: WebsiteUncheckedCreateNestedManyWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    cannedResponses?: CannedResponseUncheckedCreateNestedManyWithoutUserInput
    autoResponses?: AutoResponseUncheckedCreateNestedManyWithoutUserInput
    conversationNotes?: ConversationNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutUserNestedInput
    websites?: WebsiteUpdateManyWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    cannedResponses?: CannedResponseUpdateManyWithoutUserNestedInput
    autoResponses?: AutoResponseUpdateManyWithoutUserNestedInput
    conversationNotes?: ConversationNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    websites?: WebsiteUncheckedUpdateManyWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    cannedResponses?: CannedResponseUncheckedUpdateManyWithoutUserNestedInput
    autoResponses?: AutoResponseUncheckedUpdateManyWithoutUserNestedInput
    conversationNotes?: ConversationNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeadCreateInput = {
    id?: string
    email: string
    name?: string | null
    company?: string | null
    phone?: string | null
    title?: string | null
    website?: string | null
    linkedinUrl?: string | null
    source?: string | null
    status?: string
    score?: number | null
    notes?: string | null
    tags?: LeadCreatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastContactedAt?: Date | string | null
    user: UserCreateNestedOneWithoutLeadsInput
    campaignLeads?: CampaignLeadCreateNestedManyWithoutLeadInput
    emailEvents?: EmailEventCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateInput = {
    id?: string
    userId: string
    email: string
    name?: string | null
    company?: string | null
    phone?: string | null
    title?: string | null
    website?: string | null
    linkedinUrl?: string | null
    source?: string | null
    status?: string
    score?: number | null
    notes?: string | null
    tags?: LeadCreatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastContactedAt?: Date | string | null
    campaignLeads?: CampaignLeadUncheckedCreateNestedManyWithoutLeadInput
    emailEvents?: EmailEventUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LeadUpdatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutLeadsNestedInput
    campaignLeads?: CampaignLeadUpdateManyWithoutLeadNestedInput
    emailEvents?: EmailEventUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LeadUpdatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaignLeads?: CampaignLeadUncheckedUpdateManyWithoutLeadNestedInput
    emailEvents?: EmailEventUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadCreateManyInput = {
    id?: string
    userId: string
    email: string
    name?: string | null
    company?: string | null
    phone?: string | null
    title?: string | null
    website?: string | null
    linkedinUrl?: string | null
    source?: string | null
    status?: string
    score?: number | null
    notes?: string | null
    tags?: LeadCreatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastContactedAt?: Date | string | null
  }

  export type LeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LeadUpdatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LeadUpdatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignCreateInput = {
    id?: string
    name: string
    description?: string | null
    type?: string
    status?: string
    subject?: string | null
    fromName?: string | null
    fromEmail?: string | null
    replyTo?: string | null
    htmlContent?: string | null
    textContent?: string | null
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    totalLeads?: number
    sentCount?: number
    openCount?: number
    clickCount?: number
    replyCount?: number
    bounceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignsInput
    template?: EmailTemplateCreateNestedOneWithoutCampaignsInput
    campaignLeads?: CampaignLeadCreateNestedManyWithoutCampaignInput
    emailEvents?: EmailEventCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    type?: string
    status?: string
    subject?: string | null
    fromName?: string | null
    fromEmail?: string | null
    replyTo?: string | null
    templateId?: string | null
    htmlContent?: string | null
    textContent?: string | null
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    totalLeads?: number
    sentCount?: number
    openCount?: number
    clickCount?: number
    replyCount?: number
    bounceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignLeads?: CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput
    emailEvents?: EmailEventUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    template?: EmailTemplateUpdateOneWithoutCampaignsNestedInput
    campaignLeads?: CampaignLeadUpdateManyWithoutCampaignNestedInput
    emailEvents?: EmailEventUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignLeads?: CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput
    emailEvents?: EmailEventUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    type?: string
    status?: string
    subject?: string | null
    fromName?: string | null
    fromEmail?: string | null
    replyTo?: string | null
    templateId?: string | null
    htmlContent?: string | null
    textContent?: string | null
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    totalLeads?: number
    sentCount?: number
    openCount?: number
    clickCount?: number
    replyCount?: number
    bounceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignLeadCreateInput = {
    id?: string
    status?: string
    sentAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    repliedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutCampaignLeadsInput
    lead: LeadCreateNestedOneWithoutCampaignLeadsInput
  }

  export type CampaignLeadUncheckedCreateInput = {
    id?: string
    campaignId: string
    leadId: string
    status?: string
    sentAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    repliedAt?: Date | string | null
  }

  export type CampaignLeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutCampaignLeadsNestedInput
    lead?: LeadUpdateOneRequiredWithoutCampaignLeadsNestedInput
  }

  export type CampaignLeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignLeadCreateManyInput = {
    id?: string
    campaignId: string
    leadId: string
    status?: string
    sentAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    repliedAt?: Date | string | null
  }

  export type CampaignLeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignLeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailTemplateCreateInput = {
    id?: string
    name: string
    subject?: string | null
    htmlContent?: string | null
    textContent?: string | null
    variables?: EmailTemplateCreatevariablesInput | string[]
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmailTemplatesInput
    campaigns?: CampaignCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    subject?: string | null
    htmlContent?: string | null
    textContent?: string | null
    variables?: EmailTemplateCreatevariablesInput | string[]
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailTemplatesNestedInput
    campaigns?: CampaignUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateCreateManyInput = {
    id?: string
    userId: string
    name: string
    subject?: string | null
    htmlContent?: string | null
    textContent?: string | null
    variables?: EmailTemplateCreatevariablesInput | string[]
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailEventCreateInput = {
    id?: string
    eventType: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutEmailEventsInput
    lead: LeadCreateNestedOneWithoutEmailEventsInput
  }

  export type EmailEventUncheckedCreateInput = {
    id?: string
    campaignId: string
    leadId: string
    eventType: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutEmailEventsNestedInput
    lead?: LeadUpdateOneRequiredWithoutEmailEventsNestedInput
  }

  export type EmailEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailEventCreateManyInput = {
    id?: string
    campaignId: string
    leadId: string
    eventType: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteCreateInput = {
    id?: string
    name: string
    domain?: string | null
    subdomain?: string | null
    pages?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    theme?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWebsitesInput
  }

  export type WebsiteUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    domain?: string | null
    subdomain?: string | null
    pages?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    theme?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebsiteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWebsitesNestedInput
  }

  export type WebsiteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteCreateManyInput = {
    id?: string
    userId: string
    name: string
    domain?: string | null
    subdomain?: string | null
    pages?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    theme?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebsiteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCreateInput = {
    id?: string
    title: string
    description?: string | null
    filename?: string | null
    fileUrl?: string | null
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: number | null
    isMonetized?: boolean
    viewCount?: number
    earnings?: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVideosInput
  }

  export type VideoUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    filename?: string | null
    fileUrl?: string | null
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: number | null
    isMonetized?: boolean
    viewCount?: number
    earnings?: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    isMonetized?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    earnings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVideosNestedInput
  }

  export type VideoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    isMonetized?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    earnings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCreateManyInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    filename?: string | null
    fileUrl?: string | null
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: number | null
    isMonetized?: boolean
    viewCount?: number
    earnings?: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    isMonetized?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    earnings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    isMonetized?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    earnings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateInput = {
    id?: string
    name: string
    key: string
    permissions?: ApiKeyCreatepermissionsInput | string[]
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutApiKeysInput
  }

  export type ApiKeyUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    key: string
    permissions?: ApiKeyCreatepermissionsInput | string[]
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ApiKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    permissions?: ApiKeyUpdatepermissionsInput | string[]
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ApiKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    permissions?: ApiKeyUpdatepermissionsInput | string[]
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateManyInput = {
    id?: string
    userId: string
    name: string
    key: string
    permissions?: ApiKeyCreatepermissionsInput | string[]
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ApiKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    permissions?: ApiKeyUpdatepermissionsInput | string[]
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    permissions?: ApiKeyUpdatepermissionsInput | string[]
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateInput = {
    id?: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    contactId?: string | null
    channel: string
    channelId?: string | null
    subject?: string | null
    status?: string
    priority?: string
    assignedTo?: string | null
    tags?: ConversationCreatetagsInput | string[]
    labels?: ConversationCreatelabelsInput | string[]
    messageCount?: number
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string | null
    closedAt?: Date | string | null
    user: UserCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    notes?: ConversationNoteCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    userId: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    contactId?: string | null
    channel: string
    channelId?: string | null
    subject?: string | null
    status?: string
    priority?: string
    assignedTo?: string | null
    tags?: ConversationCreatetagsInput | string[]
    labels?: ConversationCreatelabelsInput | string[]
    messageCount?: number
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string | null
    closedAt?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    notes?: ConversationNoteUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ConversationUpdatetagsInput | string[]
    labels?: ConversationUpdatelabelsInput | string[]
    messageCount?: IntFieldUpdateOperationsInput | number
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    notes?: ConversationNoteUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ConversationUpdatetagsInput | string[]
    labels?: ConversationUpdatelabelsInput | string[]
    messageCount?: IntFieldUpdateOperationsInput | number
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    notes?: ConversationNoteUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    userId: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    contactId?: string | null
    channel: string
    channelId?: string | null
    subject?: string | null
    status?: string
    priority?: string
    assignedTo?: string | null
    tags?: ConversationCreatetagsInput | string[]
    labels?: ConversationCreatelabelsInput | string[]
    messageCount?: number
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string | null
    closedAt?: Date | string | null
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ConversationUpdatetagsInput | string[]
    labels?: ConversationUpdatelabelsInput | string[]
    messageCount?: IntFieldUpdateOperationsInput | number
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ConversationUpdatetagsInput | string[]
    labels?: ConversationUpdatelabelsInput | string[]
    messageCount?: IntFieldUpdateOperationsInput | number
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    htmlContent?: string | null
    subject?: string | null
    channel: string
    channelMessageId?: string | null
    direction?: string
    status?: string
    isRead?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    user: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    userId: string
    content: string
    htmlContent?: string | null
    subject?: string | null
    channel: string
    channelMessageId?: string | null
    direction?: string
    status?: string
    isRead?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    channelMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    channelMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateManyInput = {
    id?: string
    conversationId: string
    userId: string
    content: string
    htmlContent?: string | null
    subject?: string | null
    channel: string
    channelMessageId?: string | null
    direction?: string
    status?: string
    isRead?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    channelMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    channelMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CannedResponseCreateInput = {
    id?: string
    name: string
    content: string
    htmlContent?: string | null
    subject?: string | null
    category?: string | null
    tags?: CannedResponseCreatetagsInput | string[]
    channels?: CannedResponseCreatechannelsInput | string[]
    variables?: CannedResponseCreatevariablesInput | string[]
    useCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCannedResponsesInput
    AutoResponse?: AutoResponseCreateNestedManyWithoutCannedResponseInput
  }

  export type CannedResponseUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    content: string
    htmlContent?: string | null
    subject?: string | null
    category?: string | null
    tags?: CannedResponseCreatetagsInput | string[]
    channels?: CannedResponseCreatechannelsInput | string[]
    variables?: CannedResponseCreatevariablesInput | string[]
    useCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    AutoResponse?: AutoResponseUncheckedCreateNestedManyWithoutCannedResponseInput
  }

  export type CannedResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CannedResponseUpdatetagsInput | string[]
    channels?: CannedResponseUpdatechannelsInput | string[]
    variables?: CannedResponseUpdatevariablesInput | string[]
    useCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCannedResponsesNestedInput
    AutoResponse?: AutoResponseUpdateManyWithoutCannedResponseNestedInput
  }

  export type CannedResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CannedResponseUpdatetagsInput | string[]
    channels?: CannedResponseUpdatechannelsInput | string[]
    variables?: CannedResponseUpdatevariablesInput | string[]
    useCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AutoResponse?: AutoResponseUncheckedUpdateManyWithoutCannedResponseNestedInput
  }

  export type CannedResponseCreateManyInput = {
    id?: string
    userId: string
    name: string
    content: string
    htmlContent?: string | null
    subject?: string | null
    category?: string | null
    tags?: CannedResponseCreatetagsInput | string[]
    channels?: CannedResponseCreatechannelsInput | string[]
    variables?: CannedResponseCreatevariablesInput | string[]
    useCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CannedResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CannedResponseUpdatetagsInput | string[]
    channels?: CannedResponseUpdatechannelsInput | string[]
    variables?: CannedResponseUpdatevariablesInput | string[]
    useCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CannedResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CannedResponseUpdatetagsInput | string[]
    channels?: CannedResponseUpdatechannelsInput | string[]
    variables?: CannedResponseUpdatevariablesInput | string[]
    useCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoResponseCreateInput = {
    id?: string
    name: string
    description?: string | null
    enabled?: boolean
    triggerType: string
    conditions: JsonNullValueInput | InputJsonValue
    responseContent?: string | null
    responseSubject?: string | null
    channels?: AutoResponseCreatechannelsInput | string[]
    priority?: number
    delaySeconds?: number
    maxPerDay?: number | null
    maxPerContact?: number | null
    triggerCount?: number
    lastTriggeredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAutoResponsesInput
    cannedResponse?: CannedResponseCreateNestedOneWithoutAutoResponseInput
  }

  export type AutoResponseUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    enabled?: boolean
    triggerType: string
    conditions: JsonNullValueInput | InputJsonValue
    cannedResponseId?: string | null
    responseContent?: string | null
    responseSubject?: string | null
    channels?: AutoResponseCreatechannelsInput | string[]
    priority?: number
    delaySeconds?: number
    maxPerDay?: number | null
    maxPerContact?: number | null
    triggerCount?: number
    lastTriggeredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutoResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    responseContent?: NullableStringFieldUpdateOperationsInput | string | null
    responseSubject?: NullableStringFieldUpdateOperationsInput | string | null
    channels?: AutoResponseUpdatechannelsInput | string[]
    priority?: IntFieldUpdateOperationsInput | number
    delaySeconds?: IntFieldUpdateOperationsInput | number
    maxPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    maxPerContact?: NullableIntFieldUpdateOperationsInput | number | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAutoResponsesNestedInput
    cannedResponse?: CannedResponseUpdateOneWithoutAutoResponseNestedInput
  }

  export type AutoResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    cannedResponseId?: NullableStringFieldUpdateOperationsInput | string | null
    responseContent?: NullableStringFieldUpdateOperationsInput | string | null
    responseSubject?: NullableStringFieldUpdateOperationsInput | string | null
    channels?: AutoResponseUpdatechannelsInput | string[]
    priority?: IntFieldUpdateOperationsInput | number
    delaySeconds?: IntFieldUpdateOperationsInput | number
    maxPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    maxPerContact?: NullableIntFieldUpdateOperationsInput | number | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoResponseCreateManyInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    enabled?: boolean
    triggerType: string
    conditions: JsonNullValueInput | InputJsonValue
    cannedResponseId?: string | null
    responseContent?: string | null
    responseSubject?: string | null
    channels?: AutoResponseCreatechannelsInput | string[]
    priority?: number
    delaySeconds?: number
    maxPerDay?: number | null
    maxPerContact?: number | null
    triggerCount?: number
    lastTriggeredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutoResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    responseContent?: NullableStringFieldUpdateOperationsInput | string | null
    responseSubject?: NullableStringFieldUpdateOperationsInput | string | null
    channels?: AutoResponseUpdatechannelsInput | string[]
    priority?: IntFieldUpdateOperationsInput | number
    delaySeconds?: IntFieldUpdateOperationsInput | number
    maxPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    maxPerContact?: NullableIntFieldUpdateOperationsInput | number | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    cannedResponseId?: NullableStringFieldUpdateOperationsInput | string | null
    responseContent?: NullableStringFieldUpdateOperationsInput | string | null
    responseSubject?: NullableStringFieldUpdateOperationsInput | string | null
    channels?: AutoResponseUpdatechannelsInput | string[]
    priority?: IntFieldUpdateOperationsInput | number
    delaySeconds?: IntFieldUpdateOperationsInput | number
    maxPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    maxPerContact?: NullableIntFieldUpdateOperationsInput | number | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationNoteCreateInput = {
    id?: string
    content: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutNotesInput
    user: UserCreateNestedOneWithoutConversationNotesInput
  }

  export type ConversationNoteUncheckedCreateInput = {
    id?: string
    conversationId: string
    userId: string
    content: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutNotesNestedInput
    user?: UserUpdateOneRequiredWithoutConversationNotesNestedInput
  }

  export type ConversationNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationNoteCreateManyInput = {
    id?: string
    conversationId: string
    userId: string
    content: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemHealthMetricCreateInput = {
    id?: string
    metricName: string
    metricValue: Decimal | DecimalJsLike | number | string
    metricUnit?: string | null
    component: string
    severity?: string
    createdAt?: Date | string
  }

  export type SystemHealthMetricUncheckedCreateInput = {
    id?: string
    metricName: string
    metricValue: Decimal | DecimalJsLike | number | string
    metricUnit?: string | null
    component: string
    severity?: string
    createdAt?: Date | string
  }

  export type SystemHealthMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metricUnit?: NullableStringFieldUpdateOperationsInput | string | null
    component?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemHealthMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metricUnit?: NullableStringFieldUpdateOperationsInput | string | null
    component?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemHealthMetricCreateManyInput = {
    id?: string
    metricName: string
    metricValue: Decimal | DecimalJsLike | number | string
    metricUnit?: string | null
    component: string
    severity?: string
    createdAt?: Date | string
  }

  export type SystemHealthMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metricUnit?: NullableStringFieldUpdateOperationsInput | string | null
    component?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemHealthMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metricUnit?: NullableStringFieldUpdateOperationsInput | string | null
    component?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosticReportCreateInput = {
    id?: string
    alertId?: string | null
    issueType: string
    rootCause?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: string | null
    aiModel?: string | null
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    suggestedFix?: string | null
    severity?: string | null
    affectedUsers?: number | null
    createdAt?: Date | string
    repairs?: RepairHistoryCreateNestedManyWithoutDiagnosticInput
  }

  export type DiagnosticReportUncheckedCreateInput = {
    id?: string
    alertId?: string | null
    issueType: string
    rootCause?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: string | null
    aiModel?: string | null
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    suggestedFix?: string | null
    severity?: string | null
    affectedUsers?: number | null
    createdAt?: Date | string
    repairs?: RepairHistoryUncheckedCreateNestedManyWithoutDiagnosticInput
  }

  export type DiagnosticReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: StringFieldUpdateOperationsInput | string
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    suggestedFix?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    affectedUsers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    repairs?: RepairHistoryUpdateManyWithoutDiagnosticNestedInput
  }

  export type DiagnosticReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: StringFieldUpdateOperationsInput | string
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    suggestedFix?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    affectedUsers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    repairs?: RepairHistoryUncheckedUpdateManyWithoutDiagnosticNestedInput
  }

  export type DiagnosticReportCreateManyInput = {
    id?: string
    alertId?: string | null
    issueType: string
    rootCause?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: string | null
    aiModel?: string | null
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    suggestedFix?: string | null
    severity?: string | null
    affectedUsers?: number | null
    createdAt?: Date | string
  }

  export type DiagnosticReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: StringFieldUpdateOperationsInput | string
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    suggestedFix?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    affectedUsers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosticReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: StringFieldUpdateOperationsInput | string
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    suggestedFix?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    affectedUsers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairHistoryCreateInput = {
    id?: string
    repairType: string
    fixApplied?: string | null
    fixCode?: string | null
    success: boolean
    timeToFixSeconds?: number | null
    verificationResult?: NullableJsonNullValueInput | InputJsonValue
    rollbackPlan?: string | null
    createdAt?: Date | string
    diagnostic?: DiagnosticReportCreateNestedOneWithoutRepairsInput
  }

  export type RepairHistoryUncheckedCreateInput = {
    id?: string
    diagnosticId?: string | null
    repairType: string
    fixApplied?: string | null
    fixCode?: string | null
    success: boolean
    timeToFixSeconds?: number | null
    verificationResult?: NullableJsonNullValueInput | InputJsonValue
    rollbackPlan?: string | null
    createdAt?: Date | string
  }

  export type RepairHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    repairType?: StringFieldUpdateOperationsInput | string
    fixApplied?: NullableStringFieldUpdateOperationsInput | string | null
    fixCode?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    timeToFixSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    verificationResult?: NullableJsonNullValueInput | InputJsonValue
    rollbackPlan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    diagnostic?: DiagnosticReportUpdateOneWithoutRepairsNestedInput
  }

  export type RepairHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnosticId?: NullableStringFieldUpdateOperationsInput | string | null
    repairType?: StringFieldUpdateOperationsInput | string
    fixApplied?: NullableStringFieldUpdateOperationsInput | string | null
    fixCode?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    timeToFixSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    verificationResult?: NullableJsonNullValueInput | InputJsonValue
    rollbackPlan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairHistoryCreateManyInput = {
    id?: string
    diagnosticId?: string | null
    repairType: string
    fixApplied?: string | null
    fixCode?: string | null
    success: boolean
    timeToFixSeconds?: number | null
    verificationResult?: NullableJsonNullValueInput | InputJsonValue
    rollbackPlan?: string | null
    createdAt?: Date | string
  }

  export type RepairHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    repairType?: StringFieldUpdateOperationsInput | string
    fixApplied?: NullableStringFieldUpdateOperationsInput | string | null
    fixCode?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    timeToFixSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    verificationResult?: NullableJsonNullValueInput | InputJsonValue
    rollbackPlan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnosticId?: NullableStringFieldUpdateOperationsInput | string | null
    repairType?: StringFieldUpdateOperationsInput | string
    fixApplied?: NullableStringFieldUpdateOperationsInput | string | null
    fixCode?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    timeToFixSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    verificationResult?: NullableJsonNullValueInput | InputJsonValue
    rollbackPlan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningPatternCreateInput = {
    id?: string
    patternHash: string
    symptoms: JsonNullValueInput | InputJsonValue
    rootCause?: string | null
    solution?: string | null
    successCount?: number
    failureCount?: number
    avgFixTimeSeconds?: number | null
    autoFixEnabled?: boolean
    lastAppliedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LearningPatternUncheckedCreateInput = {
    id?: string
    patternHash: string
    symptoms: JsonNullValueInput | InputJsonValue
    rootCause?: string | null
    solution?: string | null
    successCount?: number
    failureCount?: number
    avgFixTimeSeconds?: number | null
    autoFixEnabled?: boolean
    lastAppliedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LearningPatternUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternHash?: StringFieldUpdateOperationsInput | string
    symptoms?: JsonNullValueInput | InputJsonValue
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    avgFixTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    autoFixEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastAppliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningPatternUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternHash?: StringFieldUpdateOperationsInput | string
    symptoms?: JsonNullValueInput | InputJsonValue
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    avgFixTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    autoFixEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastAppliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningPatternCreateManyInput = {
    id?: string
    patternHash: string
    symptoms: JsonNullValueInput | InputJsonValue
    rootCause?: string | null
    solution?: string | null
    successCount?: number
    failureCount?: number
    avgFixTimeSeconds?: number | null
    autoFixEnabled?: boolean
    lastAppliedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LearningPatternUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternHash?: StringFieldUpdateOperationsInput | string
    symptoms?: JsonNullValueInput | InputJsonValue
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    avgFixTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    autoFixEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastAppliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningPatternUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternHash?: StringFieldUpdateOperationsInput | string
    symptoms?: JsonNullValueInput | InputJsonValue
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    avgFixTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    autoFixEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastAppliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionCreateInput = {
    id?: string
    predictionType: string
    predictedIssue?: string | null
    predictedTime?: Date | string | null
    confidence?: Decimal | DecimalJsLike | number | string | null
    dataPoints?: NullableJsonNullValueInput | InputJsonValue
    proactiveAction?: string | null
    actionTaken?: boolean
    outcome?: string | null
    createdAt?: Date | string
  }

  export type PredictionUncheckedCreateInput = {
    id?: string
    predictionType: string
    predictedIssue?: string | null
    predictedTime?: Date | string | null
    confidence?: Decimal | DecimalJsLike | number | string | null
    dataPoints?: NullableJsonNullValueInput | InputJsonValue
    proactiveAction?: string | null
    actionTaken?: boolean
    outcome?: string | null
    createdAt?: Date | string
  }

  export type PredictionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    predictionType?: StringFieldUpdateOperationsInput | string
    predictedIssue?: NullableStringFieldUpdateOperationsInput | string | null
    predictedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dataPoints?: NullableJsonNullValueInput | InputJsonValue
    proactiveAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: BoolFieldUpdateOperationsInput | boolean
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    predictionType?: StringFieldUpdateOperationsInput | string
    predictedIssue?: NullableStringFieldUpdateOperationsInput | string | null
    predictedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dataPoints?: NullableJsonNullValueInput | InputJsonValue
    proactiveAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: BoolFieldUpdateOperationsInput | boolean
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionCreateManyInput = {
    id?: string
    predictionType: string
    predictedIssue?: string | null
    predictedTime?: Date | string | null
    confidence?: Decimal | DecimalJsLike | number | string | null
    dataPoints?: NullableJsonNullValueInput | InputJsonValue
    proactiveAction?: string | null
    actionTaken?: boolean
    outcome?: string | null
    createdAt?: Date | string
  }

  export type PredictionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    predictionType?: StringFieldUpdateOperationsInput | string
    predictedIssue?: NullableStringFieldUpdateOperationsInput | string | null
    predictedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dataPoints?: NullableJsonNullValueInput | InputJsonValue
    proactiveAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: BoolFieldUpdateOperationsInput | boolean
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    predictionType?: StringFieldUpdateOperationsInput | string
    predictedIssue?: NullableStringFieldUpdateOperationsInput | string | null
    predictedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dataPoints?: NullableJsonNullValueInput | InputJsonValue
    proactiveAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: BoolFieldUpdateOperationsInput | boolean
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityIncidentCreateInput = {
    id?: string
    threatType: string
    severity?: string | null
    sourceIp?: string | null
    targetEndpoint?: string | null
    payload?: string | null
    userId?: string | null
    mitigationAction?: string | null
    blocked?: boolean
    createdAt?: Date | string
  }

  export type SecurityIncidentUncheckedCreateInput = {
    id?: string
    threatType: string
    severity?: string | null
    sourceIp?: string | null
    targetEndpoint?: string | null
    payload?: string | null
    userId?: string | null
    mitigationAction?: string | null
    blocked?: boolean
    createdAt?: Date | string
  }

  export type SecurityIncidentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    threatType?: StringFieldUpdateOperationsInput | string
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    sourceIp?: NullableStringFieldUpdateOperationsInput | string | null
    targetEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    mitigationAction?: NullableStringFieldUpdateOperationsInput | string | null
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityIncidentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    threatType?: StringFieldUpdateOperationsInput | string
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    sourceIp?: NullableStringFieldUpdateOperationsInput | string | null
    targetEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    mitigationAction?: NullableStringFieldUpdateOperationsInput | string | null
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityIncidentCreateManyInput = {
    id?: string
    threatType: string
    severity?: string | null
    sourceIp?: string | null
    targetEndpoint?: string | null
    payload?: string | null
    userId?: string | null
    mitigationAction?: string | null
    blocked?: boolean
    createdAt?: Date | string
  }

  export type SecurityIncidentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    threatType?: StringFieldUpdateOperationsInput | string
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    sourceIp?: NullableStringFieldUpdateOperationsInput | string | null
    targetEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    mitigationAction?: NullableStringFieldUpdateOperationsInput | string | null
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityIncidentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    threatType?: StringFieldUpdateOperationsInput | string
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    sourceIp?: NullableStringFieldUpdateOperationsInput | string | null
    targetEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    mitigationAction?: NullableStringFieldUpdateOperationsInput | string | null
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceMetricCreateInput = {
    id?: string
    metricType: string
    endpoint?: string | null
    queryHash?: string | null
    valueMs?: Decimal | DecimalJsLike | number | string | null
    percentile95?: Decimal | DecimalJsLike | number | string | null
    percentile99?: Decimal | DecimalJsLike | number | string | null
    sampleCount?: number | null
    optimizationApplied?: string | null
    improvementPercent?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type PerformanceMetricUncheckedCreateInput = {
    id?: string
    metricType: string
    endpoint?: string | null
    queryHash?: string | null
    valueMs?: Decimal | DecimalJsLike | number | string | null
    percentile95?: Decimal | DecimalJsLike | number | string | null
    percentile99?: Decimal | DecimalJsLike | number | string | null
    sampleCount?: number | null
    optimizationApplied?: string | null
    improvementPercent?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type PerformanceMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    queryHash?: NullableStringFieldUpdateOperationsInput | string | null
    valueMs?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentile95?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentile99?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sampleCount?: NullableIntFieldUpdateOperationsInput | number | null
    optimizationApplied?: NullableStringFieldUpdateOperationsInput | string | null
    improvementPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    queryHash?: NullableStringFieldUpdateOperationsInput | string | null
    valueMs?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentile95?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentile99?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sampleCount?: NullableIntFieldUpdateOperationsInput | number | null
    optimizationApplied?: NullableStringFieldUpdateOperationsInput | string | null
    improvementPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceMetricCreateManyInput = {
    id?: string
    metricType: string
    endpoint?: string | null
    queryHash?: string | null
    valueMs?: Decimal | DecimalJsLike | number | string | null
    percentile95?: Decimal | DecimalJsLike | number | string | null
    percentile99?: Decimal | DecimalJsLike | number | string | null
    sampleCount?: number | null
    optimizationApplied?: string | null
    improvementPercent?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type PerformanceMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    queryHash?: NullableStringFieldUpdateOperationsInput | string | null
    valueMs?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentile95?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentile99?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sampleCount?: NullableIntFieldUpdateOperationsInput | number | null
    optimizationApplied?: NullableStringFieldUpdateOperationsInput | string | null
    improvementPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    queryHash?: NullableStringFieldUpdateOperationsInput | string | null
    valueMs?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentile95?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentile99?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sampleCount?: NullableIntFieldUpdateOperationsInput | number | null
    optimizationApplied?: NullableStringFieldUpdateOperationsInput | string | null
    improvementPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemAlertCreateInput = {
    id?: string
    alertType: string
    component?: string | null
    message?: string | null
    severity?: string | null
    thresholdValue?: Decimal | DecimalJsLike | number | string | null
    actualValue?: Decimal | DecimalJsLike | number | string | null
    acknowledged?: boolean
    acknowledgedBy?: string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    autoResolved?: boolean
    createdAt?: Date | string
  }

  export type SystemAlertUncheckedCreateInput = {
    id?: string
    alertType: string
    component?: string | null
    message?: string | null
    severity?: string | null
    thresholdValue?: Decimal | DecimalJsLike | number | string | null
    actualValue?: Decimal | DecimalJsLike | number | string | null
    acknowledged?: boolean
    acknowledgedBy?: string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    autoResolved?: boolean
    createdAt?: Date | string
  }

  export type SystemAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    component?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    thresholdValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    component?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    thresholdValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemAlertCreateManyInput = {
    id?: string
    alertType: string
    component?: string | null
    message?: string | null
    severity?: string | null
    thresholdValue?: Decimal | DecimalJsLike | number | string | null
    actualValue?: Decimal | DecimalJsLike | number | string | null
    acknowledged?: boolean
    acknowledgedBy?: string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    autoResolved?: boolean
    createdAt?: Date | string
  }

  export type SystemAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    component?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    thresholdValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    component?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    thresholdValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: string
    permissions?: AdminUserCreatepermissionsInput | string[]
    mfaEnabled?: boolean
    mfaSecret?: string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminUserInput
  }

  export type AdminUserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: string
    permissions?: AdminUserCreatepermissionsInput | string[]
    mfaEnabled?: boolean
    mfaSecret?: string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminUserInput
  }

  export type AdminUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUserUpdatepermissionsInput | string[]
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminUserNestedInput
  }

  export type AdminUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUserUpdatepermissionsInput | string[]
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminUserNestedInput
  }

  export type AdminUserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: string
    permissions?: AdminUserCreatepermissionsInput | string[]
    mfaEnabled?: boolean
    mfaSecret?: string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUserUpdatepermissionsInput | string[]
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUserUpdatepermissionsInput | string[]
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogCreateInput = {
    id?: string
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    adminUser: AdminUserCreateNestedOneWithoutAuditLogsInput
  }

  export type AdminAuditLogUncheckedCreateInput = {
    id?: string
    adminUserId: string
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AdminAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminUser?: AdminUserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AdminAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminUserId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogCreateManyInput = {
    id?: string
    adminUserId: string
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AdminAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminUserId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSessionCreateInput = {
    id?: string
    adminUserId: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    lastActiveAt?: Date | string
  }

  export type AdminSessionUncheckedCreateInput = {
    id?: string
    adminUserId: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    lastActiveAt?: Date | string
  }

  export type AdminSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminUserId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminUserId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSessionCreateManyInput = {
    id?: string
    adminUserId: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    lastActiveAt?: Date | string
  }

  export type AdminSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminUserId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminUserId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type LeadListRelationFilter = {
    every?: LeadWhereInput
    some?: LeadWhereInput
    none?: LeadWhereInput
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type EmailTemplateListRelationFilter = {
    every?: EmailTemplateWhereInput
    some?: EmailTemplateWhereInput
    none?: EmailTemplateWhereInput
  }

  export type WebsiteListRelationFilter = {
    every?: WebsiteWhereInput
    some?: WebsiteWhereInput
    none?: WebsiteWhereInput
  }

  export type VideoListRelationFilter = {
    every?: VideoWhereInput
    some?: VideoWhereInput
    none?: VideoWhereInput
  }

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput
    some?: ApiKeyWhereInput
    none?: ApiKeyWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type CannedResponseListRelationFilter = {
    every?: CannedResponseWhereInput
    some?: CannedResponseWhereInput
    none?: CannedResponseWhereInput
  }

  export type AutoResponseListRelationFilter = {
    every?: AutoResponseWhereInput
    some?: AutoResponseWhereInput
    none?: AutoResponseWhereInput
  }

  export type ConversationNoteListRelationFilter = {
    every?: ConversationNoteWhereInput
    some?: ConversationNoteWhereInput
    none?: ConversationNoteWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type LeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebsiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CannedResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutoResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    company?: SortOrder
    tier?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    subscriptionStatus?: SortOrder
    trialEndsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    tier?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    company?: SortOrder
    tier?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    subscriptionStatus?: SortOrder
    trialEndsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    company?: SortOrder
    tier?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    subscriptionStatus?: SortOrder
    trialEndsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    tier?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CampaignLeadListRelationFilter = {
    every?: CampaignLeadWhereInput
    some?: CampaignLeadWhereInput
    none?: CampaignLeadWhereInput
  }

  export type EmailEventListRelationFilter = {
    every?: EmailEventWhereInput
    some?: EmailEventWhereInput
    none?: EmailEventWhereInput
  }

  export type CampaignLeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadUserIdEmailCompoundUniqueInput = {
    userId: string
    email: string
  }

  export type LeadCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    company?: SortOrder
    phone?: SortOrder
    title?: SortOrder
    website?: SortOrder
    linkedinUrl?: SortOrder
    source?: SortOrder
    status?: SortOrder
    score?: SortOrder
    notes?: SortOrder
    tags?: SortOrder
    customFields?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastContactedAt?: SortOrder
  }

  export type LeadAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type LeadMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    company?: SortOrder
    phone?: SortOrder
    title?: SortOrder
    website?: SortOrder
    linkedinUrl?: SortOrder
    source?: SortOrder
    status?: SortOrder
    score?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastContactedAt?: SortOrder
  }

  export type LeadMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    company?: SortOrder
    phone?: SortOrder
    title?: SortOrder
    website?: SortOrder
    linkedinUrl?: SortOrder
    source?: SortOrder
    status?: SortOrder
    score?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastContactedAt?: SortOrder
  }

  export type LeadSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EmailTemplateNullableRelationFilter = {
    is?: EmailTemplateWhereInput | null
    isNot?: EmailTemplateWhereInput | null
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrder
    fromName?: SortOrder
    fromEmail?: SortOrder
    replyTo?: SortOrder
    templateId?: SortOrder
    htmlContent?: SortOrder
    textContent?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    totalLeads?: SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    replyCount?: SortOrder
    bounceCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    totalLeads?: SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    replyCount?: SortOrder
    bounceCount?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrder
    fromName?: SortOrder
    fromEmail?: SortOrder
    replyTo?: SortOrder
    templateId?: SortOrder
    htmlContent?: SortOrder
    textContent?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    totalLeads?: SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    replyCount?: SortOrder
    bounceCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrder
    fromName?: SortOrder
    fromEmail?: SortOrder
    replyTo?: SortOrder
    templateId?: SortOrder
    htmlContent?: SortOrder
    textContent?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    totalLeads?: SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    replyCount?: SortOrder
    bounceCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    totalLeads?: SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    replyCount?: SortOrder
    bounceCount?: SortOrder
  }

  export type CampaignRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type LeadRelationFilter = {
    is?: LeadWhereInput
    isNot?: LeadWhereInput
  }

  export type CampaignLeadCampaignIdLeadIdCompoundUniqueInput = {
    campaignId: string
    leadId: string
  }

  export type CampaignLeadCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    leadId?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    openedAt?: SortOrder
    clickedAt?: SortOrder
    repliedAt?: SortOrder
  }

  export type CampaignLeadMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    leadId?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    openedAt?: SortOrder
    clickedAt?: SortOrder
    repliedAt?: SortOrder
  }

  export type CampaignLeadMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    leadId?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    openedAt?: SortOrder
    clickedAt?: SortOrder
    repliedAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EmailTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    htmlContent?: SortOrder
    textContent?: SortOrder
    variables?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    htmlContent?: SortOrder
    textContent?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    htmlContent?: SortOrder
    textContent?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EmailEventCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    leadId?: SortOrder
    eventType?: SortOrder
    eventData?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailEventMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    leadId?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailEventMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    leadId?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
  }

  export type WebsiteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    subdomain?: SortOrder
    pages?: SortOrder
    settings?: SortOrder
    theme?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebsiteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    subdomain?: SortOrder
    theme?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebsiteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    subdomain?: SortOrder
    theme?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type VideoCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    filename?: SortOrder
    fileUrl?: SortOrder
    thumbnailUrl?: SortOrder
    duration?: SortOrder
    fileSize?: SortOrder
    isMonetized?: SortOrder
    viewCount?: SortOrder
    earnings?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoAvgOrderByAggregateInput = {
    duration?: SortOrder
    fileSize?: SortOrder
    viewCount?: SortOrder
    earnings?: SortOrder
  }

  export type VideoMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    filename?: SortOrder
    fileUrl?: SortOrder
    thumbnailUrl?: SortOrder
    duration?: SortOrder
    fileSize?: SortOrder
    isMonetized?: SortOrder
    viewCount?: SortOrder
    earnings?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    filename?: SortOrder
    fileUrl?: SortOrder
    thumbnailUrl?: SortOrder
    duration?: SortOrder
    fileSize?: SortOrder
    isMonetized?: SortOrder
    viewCount?: SortOrder
    earnings?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoSumOrderByAggregateInput = {
    duration?: SortOrder
    fileSize?: SortOrder
    viewCount?: SortOrder
    earnings?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    key?: SortOrder
    permissions?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    key?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    key?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contactName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    contactId?: SortOrder
    channel?: SortOrder
    channelId?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assignedTo?: SortOrder
    tags?: SortOrder
    labels?: SortOrder
    messageCount?: SortOrder
    unreadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastMessageAt?: SortOrder
    closedAt?: SortOrder
  }

  export type ConversationAvgOrderByAggregateInput = {
    messageCount?: SortOrder
    unreadCount?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contactName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    contactId?: SortOrder
    channel?: SortOrder
    channelId?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assignedTo?: SortOrder
    messageCount?: SortOrder
    unreadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastMessageAt?: SortOrder
    closedAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contactName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    contactId?: SortOrder
    channel?: SortOrder
    channelId?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assignedTo?: SortOrder
    messageCount?: SortOrder
    unreadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastMessageAt?: SortOrder
    closedAt?: SortOrder
  }

  export type ConversationSumOrderByAggregateInput = {
    messageCount?: SortOrder
    unreadCount?: SortOrder
  }

  export type ConversationRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    htmlContent?: SortOrder
    subject?: SortOrder
    channel?: SortOrder
    channelMessageId?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    isRead?: SortOrder
    attachments?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    htmlContent?: SortOrder
    subject?: SortOrder
    channel?: SortOrder
    channelMessageId?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    htmlContent?: SortOrder
    subject?: SortOrder
    channel?: SortOrder
    channelMessageId?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type CannedResponseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    content?: SortOrder
    htmlContent?: SortOrder
    subject?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    channels?: SortOrder
    variables?: SortOrder
    useCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CannedResponseAvgOrderByAggregateInput = {
    useCount?: SortOrder
  }

  export type CannedResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    content?: SortOrder
    htmlContent?: SortOrder
    subject?: SortOrder
    category?: SortOrder
    useCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CannedResponseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    content?: SortOrder
    htmlContent?: SortOrder
    subject?: SortOrder
    category?: SortOrder
    useCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CannedResponseSumOrderByAggregateInput = {
    useCount?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CannedResponseNullableRelationFilter = {
    is?: CannedResponseWhereInput | null
    isNot?: CannedResponseWhereInput | null
  }

  export type AutoResponseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    enabled?: SortOrder
    triggerType?: SortOrder
    conditions?: SortOrder
    cannedResponseId?: SortOrder
    responseContent?: SortOrder
    responseSubject?: SortOrder
    channels?: SortOrder
    priority?: SortOrder
    delaySeconds?: SortOrder
    maxPerDay?: SortOrder
    maxPerContact?: SortOrder
    triggerCount?: SortOrder
    lastTriggeredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutoResponseAvgOrderByAggregateInput = {
    priority?: SortOrder
    delaySeconds?: SortOrder
    maxPerDay?: SortOrder
    maxPerContact?: SortOrder
    triggerCount?: SortOrder
  }

  export type AutoResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    enabled?: SortOrder
    triggerType?: SortOrder
    cannedResponseId?: SortOrder
    responseContent?: SortOrder
    responseSubject?: SortOrder
    priority?: SortOrder
    delaySeconds?: SortOrder
    maxPerDay?: SortOrder
    maxPerContact?: SortOrder
    triggerCount?: SortOrder
    lastTriggeredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutoResponseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    enabled?: SortOrder
    triggerType?: SortOrder
    cannedResponseId?: SortOrder
    responseContent?: SortOrder
    responseSubject?: SortOrder
    priority?: SortOrder
    delaySeconds?: SortOrder
    maxPerDay?: SortOrder
    maxPerContact?: SortOrder
    triggerCount?: SortOrder
    lastTriggeredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutoResponseSumOrderByAggregateInput = {
    priority?: SortOrder
    delaySeconds?: SortOrder
    maxPerDay?: SortOrder
    maxPerContact?: SortOrder
    triggerCount?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ConversationNoteCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationNoteMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemHealthMetricCountOrderByAggregateInput = {
    id?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    metricUnit?: SortOrder
    component?: SortOrder
    severity?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemHealthMetricAvgOrderByAggregateInput = {
    metricValue?: SortOrder
  }

  export type SystemHealthMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    metricUnit?: SortOrder
    component?: SortOrder
    severity?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemHealthMetricMinOrderByAggregateInput = {
    id?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    metricUnit?: SortOrder
    component?: SortOrder
    severity?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemHealthMetricSumOrderByAggregateInput = {
    metricValue?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type RepairHistoryListRelationFilter = {
    every?: RepairHistoryWhereInput
    some?: RepairHistoryWhereInput
    none?: RepairHistoryWhereInput
  }

  export type RepairHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiagnosticReportCountOrderByAggregateInput = {
    id?: SortOrder
    alertId?: SortOrder
    issueType?: SortOrder
    rootCause?: SortOrder
    evidence?: SortOrder
    aiAnalysis?: SortOrder
    aiModel?: SortOrder
    confidenceScore?: SortOrder
    suggestedFix?: SortOrder
    severity?: SortOrder
    affectedUsers?: SortOrder
    createdAt?: SortOrder
  }

  export type DiagnosticReportAvgOrderByAggregateInput = {
    confidenceScore?: SortOrder
    affectedUsers?: SortOrder
  }

  export type DiagnosticReportMaxOrderByAggregateInput = {
    id?: SortOrder
    alertId?: SortOrder
    issueType?: SortOrder
    rootCause?: SortOrder
    aiAnalysis?: SortOrder
    aiModel?: SortOrder
    confidenceScore?: SortOrder
    suggestedFix?: SortOrder
    severity?: SortOrder
    affectedUsers?: SortOrder
    createdAt?: SortOrder
  }

  export type DiagnosticReportMinOrderByAggregateInput = {
    id?: SortOrder
    alertId?: SortOrder
    issueType?: SortOrder
    rootCause?: SortOrder
    aiAnalysis?: SortOrder
    aiModel?: SortOrder
    confidenceScore?: SortOrder
    suggestedFix?: SortOrder
    severity?: SortOrder
    affectedUsers?: SortOrder
    createdAt?: SortOrder
  }

  export type DiagnosticReportSumOrderByAggregateInput = {
    confidenceScore?: SortOrder
    affectedUsers?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DiagnosticReportNullableRelationFilter = {
    is?: DiagnosticReportWhereInput | null
    isNot?: DiagnosticReportWhereInput | null
  }

  export type RepairHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    diagnosticId?: SortOrder
    repairType?: SortOrder
    fixApplied?: SortOrder
    fixCode?: SortOrder
    success?: SortOrder
    timeToFixSeconds?: SortOrder
    verificationResult?: SortOrder
    rollbackPlan?: SortOrder
    createdAt?: SortOrder
  }

  export type RepairHistoryAvgOrderByAggregateInput = {
    timeToFixSeconds?: SortOrder
  }

  export type RepairHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    diagnosticId?: SortOrder
    repairType?: SortOrder
    fixApplied?: SortOrder
    fixCode?: SortOrder
    success?: SortOrder
    timeToFixSeconds?: SortOrder
    rollbackPlan?: SortOrder
    createdAt?: SortOrder
  }

  export type RepairHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    diagnosticId?: SortOrder
    repairType?: SortOrder
    fixApplied?: SortOrder
    fixCode?: SortOrder
    success?: SortOrder
    timeToFixSeconds?: SortOrder
    rollbackPlan?: SortOrder
    createdAt?: SortOrder
  }

  export type RepairHistorySumOrderByAggregateInput = {
    timeToFixSeconds?: SortOrder
  }

  export type LearningPatternCountOrderByAggregateInput = {
    id?: SortOrder
    patternHash?: SortOrder
    symptoms?: SortOrder
    rootCause?: SortOrder
    solution?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    avgFixTimeSeconds?: SortOrder
    autoFixEnabled?: SortOrder
    lastAppliedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LearningPatternAvgOrderByAggregateInput = {
    successCount?: SortOrder
    failureCount?: SortOrder
    avgFixTimeSeconds?: SortOrder
  }

  export type LearningPatternMaxOrderByAggregateInput = {
    id?: SortOrder
    patternHash?: SortOrder
    rootCause?: SortOrder
    solution?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    avgFixTimeSeconds?: SortOrder
    autoFixEnabled?: SortOrder
    lastAppliedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LearningPatternMinOrderByAggregateInput = {
    id?: SortOrder
    patternHash?: SortOrder
    rootCause?: SortOrder
    solution?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    avgFixTimeSeconds?: SortOrder
    autoFixEnabled?: SortOrder
    lastAppliedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LearningPatternSumOrderByAggregateInput = {
    successCount?: SortOrder
    failureCount?: SortOrder
    avgFixTimeSeconds?: SortOrder
  }

  export type PredictionCountOrderByAggregateInput = {
    id?: SortOrder
    predictionType?: SortOrder
    predictedIssue?: SortOrder
    predictedTime?: SortOrder
    confidence?: SortOrder
    dataPoints?: SortOrder
    proactiveAction?: SortOrder
    actionTaken?: SortOrder
    outcome?: SortOrder
    createdAt?: SortOrder
  }

  export type PredictionAvgOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type PredictionMaxOrderByAggregateInput = {
    id?: SortOrder
    predictionType?: SortOrder
    predictedIssue?: SortOrder
    predictedTime?: SortOrder
    confidence?: SortOrder
    proactiveAction?: SortOrder
    actionTaken?: SortOrder
    outcome?: SortOrder
    createdAt?: SortOrder
  }

  export type PredictionMinOrderByAggregateInput = {
    id?: SortOrder
    predictionType?: SortOrder
    predictedIssue?: SortOrder
    predictedTime?: SortOrder
    confidence?: SortOrder
    proactiveAction?: SortOrder
    actionTaken?: SortOrder
    outcome?: SortOrder
    createdAt?: SortOrder
  }

  export type PredictionSumOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type SecurityIncidentCountOrderByAggregateInput = {
    id?: SortOrder
    threatType?: SortOrder
    severity?: SortOrder
    sourceIp?: SortOrder
    targetEndpoint?: SortOrder
    payload?: SortOrder
    userId?: SortOrder
    mitigationAction?: SortOrder
    blocked?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityIncidentMaxOrderByAggregateInput = {
    id?: SortOrder
    threatType?: SortOrder
    severity?: SortOrder
    sourceIp?: SortOrder
    targetEndpoint?: SortOrder
    payload?: SortOrder
    userId?: SortOrder
    mitigationAction?: SortOrder
    blocked?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityIncidentMinOrderByAggregateInput = {
    id?: SortOrder
    threatType?: SortOrder
    severity?: SortOrder
    sourceIp?: SortOrder
    targetEndpoint?: SortOrder
    payload?: SortOrder
    userId?: SortOrder
    mitigationAction?: SortOrder
    blocked?: SortOrder
    createdAt?: SortOrder
  }

  export type PerformanceMetricCountOrderByAggregateInput = {
    id?: SortOrder
    metricType?: SortOrder
    endpoint?: SortOrder
    queryHash?: SortOrder
    valueMs?: SortOrder
    percentile95?: SortOrder
    percentile99?: SortOrder
    sampleCount?: SortOrder
    optimizationApplied?: SortOrder
    improvementPercent?: SortOrder
    createdAt?: SortOrder
  }

  export type PerformanceMetricAvgOrderByAggregateInput = {
    valueMs?: SortOrder
    percentile95?: SortOrder
    percentile99?: SortOrder
    sampleCount?: SortOrder
    improvementPercent?: SortOrder
  }

  export type PerformanceMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    metricType?: SortOrder
    endpoint?: SortOrder
    queryHash?: SortOrder
    valueMs?: SortOrder
    percentile95?: SortOrder
    percentile99?: SortOrder
    sampleCount?: SortOrder
    optimizationApplied?: SortOrder
    improvementPercent?: SortOrder
    createdAt?: SortOrder
  }

  export type PerformanceMetricMinOrderByAggregateInput = {
    id?: SortOrder
    metricType?: SortOrder
    endpoint?: SortOrder
    queryHash?: SortOrder
    valueMs?: SortOrder
    percentile95?: SortOrder
    percentile99?: SortOrder
    sampleCount?: SortOrder
    optimizationApplied?: SortOrder
    improvementPercent?: SortOrder
    createdAt?: SortOrder
  }

  export type PerformanceMetricSumOrderByAggregateInput = {
    valueMs?: SortOrder
    percentile95?: SortOrder
    percentile99?: SortOrder
    sampleCount?: SortOrder
    improvementPercent?: SortOrder
  }

  export type SystemAlertCountOrderByAggregateInput = {
    id?: SortOrder
    alertType?: SortOrder
    component?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    thresholdValue?: SortOrder
    actualValue?: SortOrder
    acknowledged?: SortOrder
    acknowledgedBy?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    autoResolved?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemAlertAvgOrderByAggregateInput = {
    thresholdValue?: SortOrder
    actualValue?: SortOrder
  }

  export type SystemAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    alertType?: SortOrder
    component?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    thresholdValue?: SortOrder
    actualValue?: SortOrder
    acknowledged?: SortOrder
    acknowledgedBy?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    autoResolved?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemAlertMinOrderByAggregateInput = {
    id?: SortOrder
    alertType?: SortOrder
    component?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    thresholdValue?: SortOrder
    actualValue?: SortOrder
    acknowledged?: SortOrder
    acknowledgedBy?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    autoResolved?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemAlertSumOrderByAggregateInput = {
    thresholdValue?: SortOrder
    actualValue?: SortOrder
  }

  export type AdminAuditLogListRelationFilter = {
    every?: AdminAuditLogWhereInput
    some?: AdminAuditLogWhereInput
    none?: AdminAuditLogWhereInput
  }

  export type AdminAuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminUserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    failedLogins?: SortOrder
    lockedUntil?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminUserAvgOrderByAggregateInput = {
    failedLogins?: SortOrder
  }

  export type AdminUserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    failedLogins?: SortOrder
    lockedUntil?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminUserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    failedLogins?: SortOrder
    lockedUntil?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminUserSumOrderByAggregateInput = {
    failedLogins?: SortOrder
  }

  export type AdminUserRelationFilter = {
    is?: AdminUserWhereInput
    isNot?: AdminUserWhereInput
  }

  export type AdminAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    adminUserId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    adminUserId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    adminUserId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminSessionCountOrderByAggregateInput = {
    id?: SortOrder
    adminUserId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    lastActiveAt?: SortOrder
  }

  export type AdminSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    adminUserId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    lastActiveAt?: SortOrder
  }

  export type AdminSessionMinOrderByAggregateInput = {
    id?: SortOrder
    adminUserId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    lastActiveAt?: SortOrder
  }

  export type LeadCreateNestedManyWithoutUserInput = {
    create?: XOR<LeadCreateWithoutUserInput, LeadUncheckedCreateWithoutUserInput> | LeadCreateWithoutUserInput[] | LeadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutUserInput | LeadCreateOrConnectWithoutUserInput[]
    createMany?: LeadCreateManyUserInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type EmailTemplateCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailTemplateCreateWithoutUserInput, EmailTemplateUncheckedCreateWithoutUserInput> | EmailTemplateCreateWithoutUserInput[] | EmailTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutUserInput | EmailTemplateCreateOrConnectWithoutUserInput[]
    createMany?: EmailTemplateCreateManyUserInputEnvelope
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
  }

  export type WebsiteCreateNestedManyWithoutUserInput = {
    create?: XOR<WebsiteCreateWithoutUserInput, WebsiteUncheckedCreateWithoutUserInput> | WebsiteCreateWithoutUserInput[] | WebsiteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WebsiteCreateOrConnectWithoutUserInput | WebsiteCreateOrConnectWithoutUserInput[]
    createMany?: WebsiteCreateManyUserInputEnvelope
    connect?: WebsiteWhereUniqueInput | WebsiteWhereUniqueInput[]
  }

  export type VideoCreateNestedManyWithoutUserInput = {
    create?: XOR<VideoCreateWithoutUserInput, VideoUncheckedCreateWithoutUserInput> | VideoCreateWithoutUserInput[] | VideoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutUserInput | VideoCreateOrConnectWithoutUserInput[]
    createMany?: VideoCreateManyUserInputEnvelope
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
  }

  export type ApiKeyCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type CannedResponseCreateNestedManyWithoutUserInput = {
    create?: XOR<CannedResponseCreateWithoutUserInput, CannedResponseUncheckedCreateWithoutUserInput> | CannedResponseCreateWithoutUserInput[] | CannedResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CannedResponseCreateOrConnectWithoutUserInput | CannedResponseCreateOrConnectWithoutUserInput[]
    createMany?: CannedResponseCreateManyUserInputEnvelope
    connect?: CannedResponseWhereUniqueInput | CannedResponseWhereUniqueInput[]
  }

  export type AutoResponseCreateNestedManyWithoutUserInput = {
    create?: XOR<AutoResponseCreateWithoutUserInput, AutoResponseUncheckedCreateWithoutUserInput> | AutoResponseCreateWithoutUserInput[] | AutoResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutoResponseCreateOrConnectWithoutUserInput | AutoResponseCreateOrConnectWithoutUserInput[]
    createMany?: AutoResponseCreateManyUserInputEnvelope
    connect?: AutoResponseWhereUniqueInput | AutoResponseWhereUniqueInput[]
  }

  export type ConversationNoteCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationNoteCreateWithoutUserInput, ConversationNoteUncheckedCreateWithoutUserInput> | ConversationNoteCreateWithoutUserInput[] | ConversationNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationNoteCreateOrConnectWithoutUserInput | ConversationNoteCreateOrConnectWithoutUserInput[]
    createMany?: ConversationNoteCreateManyUserInputEnvelope
    connect?: ConversationNoteWhereUniqueInput | ConversationNoteWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LeadCreateWithoutUserInput, LeadUncheckedCreateWithoutUserInput> | LeadCreateWithoutUserInput[] | LeadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutUserInput | LeadCreateOrConnectWithoutUserInput[]
    createMany?: LeadCreateManyUserInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type EmailTemplateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailTemplateCreateWithoutUserInput, EmailTemplateUncheckedCreateWithoutUserInput> | EmailTemplateCreateWithoutUserInput[] | EmailTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutUserInput | EmailTemplateCreateOrConnectWithoutUserInput[]
    createMany?: EmailTemplateCreateManyUserInputEnvelope
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
  }

  export type WebsiteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WebsiteCreateWithoutUserInput, WebsiteUncheckedCreateWithoutUserInput> | WebsiteCreateWithoutUserInput[] | WebsiteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WebsiteCreateOrConnectWithoutUserInput | WebsiteCreateOrConnectWithoutUserInput[]
    createMany?: WebsiteCreateManyUserInputEnvelope
    connect?: WebsiteWhereUniqueInput | WebsiteWhereUniqueInput[]
  }

  export type VideoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VideoCreateWithoutUserInput, VideoUncheckedCreateWithoutUserInput> | VideoCreateWithoutUserInput[] | VideoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutUserInput | VideoCreateOrConnectWithoutUserInput[]
    createMany?: VideoCreateManyUserInputEnvelope
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
  }

  export type ApiKeyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type CannedResponseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CannedResponseCreateWithoutUserInput, CannedResponseUncheckedCreateWithoutUserInput> | CannedResponseCreateWithoutUserInput[] | CannedResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CannedResponseCreateOrConnectWithoutUserInput | CannedResponseCreateOrConnectWithoutUserInput[]
    createMany?: CannedResponseCreateManyUserInputEnvelope
    connect?: CannedResponseWhereUniqueInput | CannedResponseWhereUniqueInput[]
  }

  export type AutoResponseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AutoResponseCreateWithoutUserInput, AutoResponseUncheckedCreateWithoutUserInput> | AutoResponseCreateWithoutUserInput[] | AutoResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutoResponseCreateOrConnectWithoutUserInput | AutoResponseCreateOrConnectWithoutUserInput[]
    createMany?: AutoResponseCreateManyUserInputEnvelope
    connect?: AutoResponseWhereUniqueInput | AutoResponseWhereUniqueInput[]
  }

  export type ConversationNoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationNoteCreateWithoutUserInput, ConversationNoteUncheckedCreateWithoutUserInput> | ConversationNoteCreateWithoutUserInput[] | ConversationNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationNoteCreateOrConnectWithoutUserInput | ConversationNoteCreateOrConnectWithoutUserInput[]
    createMany?: ConversationNoteCreateManyUserInputEnvelope
    connect?: ConversationNoteWhereUniqueInput | ConversationNoteWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type LeadUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeadCreateWithoutUserInput, LeadUncheckedCreateWithoutUserInput> | LeadCreateWithoutUserInput[] | LeadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutUserInput | LeadCreateOrConnectWithoutUserInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutUserInput | LeadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeadCreateManyUserInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutUserInput | LeadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutUserInput | LeadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutUserInput | CampaignUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutUserInput | CampaignUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutUserInput | CampaignUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type EmailTemplateUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutUserInput, EmailTemplateUncheckedCreateWithoutUserInput> | EmailTemplateCreateWithoutUserInput[] | EmailTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutUserInput | EmailTemplateCreateOrConnectWithoutUserInput[]
    upsert?: EmailTemplateUpsertWithWhereUniqueWithoutUserInput | EmailTemplateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailTemplateCreateManyUserInputEnvelope
    set?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    disconnect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    delete?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    update?: EmailTemplateUpdateWithWhereUniqueWithoutUserInput | EmailTemplateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailTemplateUpdateManyWithWhereWithoutUserInput | EmailTemplateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailTemplateScalarWhereInput | EmailTemplateScalarWhereInput[]
  }

  export type WebsiteUpdateManyWithoutUserNestedInput = {
    create?: XOR<WebsiteCreateWithoutUserInput, WebsiteUncheckedCreateWithoutUserInput> | WebsiteCreateWithoutUserInput[] | WebsiteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WebsiteCreateOrConnectWithoutUserInput | WebsiteCreateOrConnectWithoutUserInput[]
    upsert?: WebsiteUpsertWithWhereUniqueWithoutUserInput | WebsiteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WebsiteCreateManyUserInputEnvelope
    set?: WebsiteWhereUniqueInput | WebsiteWhereUniqueInput[]
    disconnect?: WebsiteWhereUniqueInput | WebsiteWhereUniqueInput[]
    delete?: WebsiteWhereUniqueInput | WebsiteWhereUniqueInput[]
    connect?: WebsiteWhereUniqueInput | WebsiteWhereUniqueInput[]
    update?: WebsiteUpdateWithWhereUniqueWithoutUserInput | WebsiteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WebsiteUpdateManyWithWhereWithoutUserInput | WebsiteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WebsiteScalarWhereInput | WebsiteScalarWhereInput[]
  }

  export type VideoUpdateManyWithoutUserNestedInput = {
    create?: XOR<VideoCreateWithoutUserInput, VideoUncheckedCreateWithoutUserInput> | VideoCreateWithoutUserInput[] | VideoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutUserInput | VideoCreateOrConnectWithoutUserInput[]
    upsert?: VideoUpsertWithWhereUniqueWithoutUserInput | VideoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VideoCreateManyUserInputEnvelope
    set?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    disconnect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    delete?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    update?: VideoUpdateWithWhereUniqueWithoutUserInput | VideoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VideoUpdateManyWithWhereWithoutUserInput | VideoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VideoScalarWhereInput | VideoScalarWhereInput[]
  }

  export type ApiKeyUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutUserInput | ApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutUserInput | ApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutUserInput | ApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUserInput | ConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUserInput | ConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUserInput | ConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUserInput | MessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUserInput | MessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUserInput | MessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type CannedResponseUpdateManyWithoutUserNestedInput = {
    create?: XOR<CannedResponseCreateWithoutUserInput, CannedResponseUncheckedCreateWithoutUserInput> | CannedResponseCreateWithoutUserInput[] | CannedResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CannedResponseCreateOrConnectWithoutUserInput | CannedResponseCreateOrConnectWithoutUserInput[]
    upsert?: CannedResponseUpsertWithWhereUniqueWithoutUserInput | CannedResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CannedResponseCreateManyUserInputEnvelope
    set?: CannedResponseWhereUniqueInput | CannedResponseWhereUniqueInput[]
    disconnect?: CannedResponseWhereUniqueInput | CannedResponseWhereUniqueInput[]
    delete?: CannedResponseWhereUniqueInput | CannedResponseWhereUniqueInput[]
    connect?: CannedResponseWhereUniqueInput | CannedResponseWhereUniqueInput[]
    update?: CannedResponseUpdateWithWhereUniqueWithoutUserInput | CannedResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CannedResponseUpdateManyWithWhereWithoutUserInput | CannedResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CannedResponseScalarWhereInput | CannedResponseScalarWhereInput[]
  }

  export type AutoResponseUpdateManyWithoutUserNestedInput = {
    create?: XOR<AutoResponseCreateWithoutUserInput, AutoResponseUncheckedCreateWithoutUserInput> | AutoResponseCreateWithoutUserInput[] | AutoResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutoResponseCreateOrConnectWithoutUserInput | AutoResponseCreateOrConnectWithoutUserInput[]
    upsert?: AutoResponseUpsertWithWhereUniqueWithoutUserInput | AutoResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AutoResponseCreateManyUserInputEnvelope
    set?: AutoResponseWhereUniqueInput | AutoResponseWhereUniqueInput[]
    disconnect?: AutoResponseWhereUniqueInput | AutoResponseWhereUniqueInput[]
    delete?: AutoResponseWhereUniqueInput | AutoResponseWhereUniqueInput[]
    connect?: AutoResponseWhereUniqueInput | AutoResponseWhereUniqueInput[]
    update?: AutoResponseUpdateWithWhereUniqueWithoutUserInput | AutoResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AutoResponseUpdateManyWithWhereWithoutUserInput | AutoResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AutoResponseScalarWhereInput | AutoResponseScalarWhereInput[]
  }

  export type ConversationNoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationNoteCreateWithoutUserInput, ConversationNoteUncheckedCreateWithoutUserInput> | ConversationNoteCreateWithoutUserInput[] | ConversationNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationNoteCreateOrConnectWithoutUserInput | ConversationNoteCreateOrConnectWithoutUserInput[]
    upsert?: ConversationNoteUpsertWithWhereUniqueWithoutUserInput | ConversationNoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationNoteCreateManyUserInputEnvelope
    set?: ConversationNoteWhereUniqueInput | ConversationNoteWhereUniqueInput[]
    disconnect?: ConversationNoteWhereUniqueInput | ConversationNoteWhereUniqueInput[]
    delete?: ConversationNoteWhereUniqueInput | ConversationNoteWhereUniqueInput[]
    connect?: ConversationNoteWhereUniqueInput | ConversationNoteWhereUniqueInput[]
    update?: ConversationNoteUpdateWithWhereUniqueWithoutUserInput | ConversationNoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationNoteUpdateManyWithWhereWithoutUserInput | ConversationNoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationNoteScalarWhereInput | ConversationNoteScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeadCreateWithoutUserInput, LeadUncheckedCreateWithoutUserInput> | LeadCreateWithoutUserInput[] | LeadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutUserInput | LeadCreateOrConnectWithoutUserInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutUserInput | LeadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeadCreateManyUserInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutUserInput | LeadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutUserInput | LeadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutUserInput | CampaignUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutUserInput | CampaignUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutUserInput | CampaignUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type EmailTemplateUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutUserInput, EmailTemplateUncheckedCreateWithoutUserInput> | EmailTemplateCreateWithoutUserInput[] | EmailTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutUserInput | EmailTemplateCreateOrConnectWithoutUserInput[]
    upsert?: EmailTemplateUpsertWithWhereUniqueWithoutUserInput | EmailTemplateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailTemplateCreateManyUserInputEnvelope
    set?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    disconnect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    delete?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    connect?: EmailTemplateWhereUniqueInput | EmailTemplateWhereUniqueInput[]
    update?: EmailTemplateUpdateWithWhereUniqueWithoutUserInput | EmailTemplateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailTemplateUpdateManyWithWhereWithoutUserInput | EmailTemplateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailTemplateScalarWhereInput | EmailTemplateScalarWhereInput[]
  }

  export type WebsiteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WebsiteCreateWithoutUserInput, WebsiteUncheckedCreateWithoutUserInput> | WebsiteCreateWithoutUserInput[] | WebsiteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WebsiteCreateOrConnectWithoutUserInput | WebsiteCreateOrConnectWithoutUserInput[]
    upsert?: WebsiteUpsertWithWhereUniqueWithoutUserInput | WebsiteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WebsiteCreateManyUserInputEnvelope
    set?: WebsiteWhereUniqueInput | WebsiteWhereUniqueInput[]
    disconnect?: WebsiteWhereUniqueInput | WebsiteWhereUniqueInput[]
    delete?: WebsiteWhereUniqueInput | WebsiteWhereUniqueInput[]
    connect?: WebsiteWhereUniqueInput | WebsiteWhereUniqueInput[]
    update?: WebsiteUpdateWithWhereUniqueWithoutUserInput | WebsiteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WebsiteUpdateManyWithWhereWithoutUserInput | WebsiteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WebsiteScalarWhereInput | WebsiteScalarWhereInput[]
  }

  export type VideoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VideoCreateWithoutUserInput, VideoUncheckedCreateWithoutUserInput> | VideoCreateWithoutUserInput[] | VideoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutUserInput | VideoCreateOrConnectWithoutUserInput[]
    upsert?: VideoUpsertWithWhereUniqueWithoutUserInput | VideoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VideoCreateManyUserInputEnvelope
    set?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    disconnect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    delete?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    update?: VideoUpdateWithWhereUniqueWithoutUserInput | VideoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VideoUpdateManyWithWhereWithoutUserInput | VideoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VideoScalarWhereInput | VideoScalarWhereInput[]
  }

  export type ApiKeyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutUserInput | ApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutUserInput | ApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutUserInput | ApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUserInput | ConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUserInput | ConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUserInput | ConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUserInput | MessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUserInput | MessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUserInput | MessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type CannedResponseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CannedResponseCreateWithoutUserInput, CannedResponseUncheckedCreateWithoutUserInput> | CannedResponseCreateWithoutUserInput[] | CannedResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CannedResponseCreateOrConnectWithoutUserInput | CannedResponseCreateOrConnectWithoutUserInput[]
    upsert?: CannedResponseUpsertWithWhereUniqueWithoutUserInput | CannedResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CannedResponseCreateManyUserInputEnvelope
    set?: CannedResponseWhereUniqueInput | CannedResponseWhereUniqueInput[]
    disconnect?: CannedResponseWhereUniqueInput | CannedResponseWhereUniqueInput[]
    delete?: CannedResponseWhereUniqueInput | CannedResponseWhereUniqueInput[]
    connect?: CannedResponseWhereUniqueInput | CannedResponseWhereUniqueInput[]
    update?: CannedResponseUpdateWithWhereUniqueWithoutUserInput | CannedResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CannedResponseUpdateManyWithWhereWithoutUserInput | CannedResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CannedResponseScalarWhereInput | CannedResponseScalarWhereInput[]
  }

  export type AutoResponseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AutoResponseCreateWithoutUserInput, AutoResponseUncheckedCreateWithoutUserInput> | AutoResponseCreateWithoutUserInput[] | AutoResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutoResponseCreateOrConnectWithoutUserInput | AutoResponseCreateOrConnectWithoutUserInput[]
    upsert?: AutoResponseUpsertWithWhereUniqueWithoutUserInput | AutoResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AutoResponseCreateManyUserInputEnvelope
    set?: AutoResponseWhereUniqueInput | AutoResponseWhereUniqueInput[]
    disconnect?: AutoResponseWhereUniqueInput | AutoResponseWhereUniqueInput[]
    delete?: AutoResponseWhereUniqueInput | AutoResponseWhereUniqueInput[]
    connect?: AutoResponseWhereUniqueInput | AutoResponseWhereUniqueInput[]
    update?: AutoResponseUpdateWithWhereUniqueWithoutUserInput | AutoResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AutoResponseUpdateManyWithWhereWithoutUserInput | AutoResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AutoResponseScalarWhereInput | AutoResponseScalarWhereInput[]
  }

  export type ConversationNoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationNoteCreateWithoutUserInput, ConversationNoteUncheckedCreateWithoutUserInput> | ConversationNoteCreateWithoutUserInput[] | ConversationNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationNoteCreateOrConnectWithoutUserInput | ConversationNoteCreateOrConnectWithoutUserInput[]
    upsert?: ConversationNoteUpsertWithWhereUniqueWithoutUserInput | ConversationNoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationNoteCreateManyUserInputEnvelope
    set?: ConversationNoteWhereUniqueInput | ConversationNoteWhereUniqueInput[]
    disconnect?: ConversationNoteWhereUniqueInput | ConversationNoteWhereUniqueInput[]
    delete?: ConversationNoteWhereUniqueInput | ConversationNoteWhereUniqueInput[]
    connect?: ConversationNoteWhereUniqueInput | ConversationNoteWhereUniqueInput[]
    update?: ConversationNoteUpdateWithWhereUniqueWithoutUserInput | ConversationNoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationNoteUpdateManyWithWhereWithoutUserInput | ConversationNoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationNoteScalarWhereInput | ConversationNoteScalarWhereInput[]
  }

  export type LeadCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutLeadsInput = {
    create?: XOR<UserCreateWithoutLeadsInput, UserUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeadsInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignLeadCreateNestedManyWithoutLeadInput = {
    create?: XOR<CampaignLeadCreateWithoutLeadInput, CampaignLeadUncheckedCreateWithoutLeadInput> | CampaignLeadCreateWithoutLeadInput[] | CampaignLeadUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutLeadInput | CampaignLeadCreateOrConnectWithoutLeadInput[]
    createMany?: CampaignLeadCreateManyLeadInputEnvelope
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
  }

  export type EmailEventCreateNestedManyWithoutLeadInput = {
    create?: XOR<EmailEventCreateWithoutLeadInput, EmailEventUncheckedCreateWithoutLeadInput> | EmailEventCreateWithoutLeadInput[] | EmailEventUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: EmailEventCreateOrConnectWithoutLeadInput | EmailEventCreateOrConnectWithoutLeadInput[]
    createMany?: EmailEventCreateManyLeadInputEnvelope
    connect?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
  }

  export type CampaignLeadUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<CampaignLeadCreateWithoutLeadInput, CampaignLeadUncheckedCreateWithoutLeadInput> | CampaignLeadCreateWithoutLeadInput[] | CampaignLeadUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutLeadInput | CampaignLeadCreateOrConnectWithoutLeadInput[]
    createMany?: CampaignLeadCreateManyLeadInputEnvelope
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
  }

  export type EmailEventUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<EmailEventCreateWithoutLeadInput, EmailEventUncheckedCreateWithoutLeadInput> | EmailEventCreateWithoutLeadInput[] | EmailEventUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: EmailEventCreateOrConnectWithoutLeadInput | EmailEventCreateOrConnectWithoutLeadInput[]
    createMany?: EmailEventCreateManyLeadInputEnvelope
    connect?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LeadUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<UserCreateWithoutLeadsInput, UserUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeadsInput
    upsert?: UserUpsertWithoutLeadsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeadsInput, UserUpdateWithoutLeadsInput>, UserUncheckedUpdateWithoutLeadsInput>
  }

  export type CampaignLeadUpdateManyWithoutLeadNestedInput = {
    create?: XOR<CampaignLeadCreateWithoutLeadInput, CampaignLeadUncheckedCreateWithoutLeadInput> | CampaignLeadCreateWithoutLeadInput[] | CampaignLeadUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutLeadInput | CampaignLeadCreateOrConnectWithoutLeadInput[]
    upsert?: CampaignLeadUpsertWithWhereUniqueWithoutLeadInput | CampaignLeadUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: CampaignLeadCreateManyLeadInputEnvelope
    set?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    disconnect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    delete?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    update?: CampaignLeadUpdateWithWhereUniqueWithoutLeadInput | CampaignLeadUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: CampaignLeadUpdateManyWithWhereWithoutLeadInput | CampaignLeadUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: CampaignLeadScalarWhereInput | CampaignLeadScalarWhereInput[]
  }

  export type EmailEventUpdateManyWithoutLeadNestedInput = {
    create?: XOR<EmailEventCreateWithoutLeadInput, EmailEventUncheckedCreateWithoutLeadInput> | EmailEventCreateWithoutLeadInput[] | EmailEventUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: EmailEventCreateOrConnectWithoutLeadInput | EmailEventCreateOrConnectWithoutLeadInput[]
    upsert?: EmailEventUpsertWithWhereUniqueWithoutLeadInput | EmailEventUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: EmailEventCreateManyLeadInputEnvelope
    set?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    disconnect?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    delete?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    connect?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    update?: EmailEventUpdateWithWhereUniqueWithoutLeadInput | EmailEventUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: EmailEventUpdateManyWithWhereWithoutLeadInput | EmailEventUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: EmailEventScalarWhereInput | EmailEventScalarWhereInput[]
  }

  export type CampaignLeadUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<CampaignLeadCreateWithoutLeadInput, CampaignLeadUncheckedCreateWithoutLeadInput> | CampaignLeadCreateWithoutLeadInput[] | CampaignLeadUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutLeadInput | CampaignLeadCreateOrConnectWithoutLeadInput[]
    upsert?: CampaignLeadUpsertWithWhereUniqueWithoutLeadInput | CampaignLeadUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: CampaignLeadCreateManyLeadInputEnvelope
    set?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    disconnect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    delete?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    update?: CampaignLeadUpdateWithWhereUniqueWithoutLeadInput | CampaignLeadUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: CampaignLeadUpdateManyWithWhereWithoutLeadInput | CampaignLeadUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: CampaignLeadScalarWhereInput | CampaignLeadScalarWhereInput[]
  }

  export type EmailEventUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<EmailEventCreateWithoutLeadInput, EmailEventUncheckedCreateWithoutLeadInput> | EmailEventCreateWithoutLeadInput[] | EmailEventUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: EmailEventCreateOrConnectWithoutLeadInput | EmailEventCreateOrConnectWithoutLeadInput[]
    upsert?: EmailEventUpsertWithWhereUniqueWithoutLeadInput | EmailEventUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: EmailEventCreateManyLeadInputEnvelope
    set?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    disconnect?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    delete?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    connect?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    update?: EmailEventUpdateWithWhereUniqueWithoutLeadInput | EmailEventUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: EmailEventUpdateManyWithWhereWithoutLeadInput | EmailEventUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: EmailEventScalarWhereInput | EmailEventScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignsInput
    connect?: UserWhereUniqueInput
  }

  export type EmailTemplateCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<EmailTemplateCreateWithoutCampaignsInput, EmailTemplateUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutCampaignsInput
    connect?: EmailTemplateWhereUniqueInput
  }

  export type CampaignLeadCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignLeadCreateWithoutCampaignInput, CampaignLeadUncheckedCreateWithoutCampaignInput> | CampaignLeadCreateWithoutCampaignInput[] | CampaignLeadUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutCampaignInput | CampaignLeadCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignLeadCreateManyCampaignInputEnvelope
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
  }

  export type EmailEventCreateNestedManyWithoutCampaignInput = {
    create?: XOR<EmailEventCreateWithoutCampaignInput, EmailEventUncheckedCreateWithoutCampaignInput> | EmailEventCreateWithoutCampaignInput[] | EmailEventUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EmailEventCreateOrConnectWithoutCampaignInput | EmailEventCreateOrConnectWithoutCampaignInput[]
    createMany?: EmailEventCreateManyCampaignInputEnvelope
    connect?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
  }

  export type CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignLeadCreateWithoutCampaignInput, CampaignLeadUncheckedCreateWithoutCampaignInput> | CampaignLeadCreateWithoutCampaignInput[] | CampaignLeadUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutCampaignInput | CampaignLeadCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignLeadCreateManyCampaignInputEnvelope
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
  }

  export type EmailEventUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<EmailEventCreateWithoutCampaignInput, EmailEventUncheckedCreateWithoutCampaignInput> | EmailEventCreateWithoutCampaignInput[] | EmailEventUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EmailEventCreateOrConnectWithoutCampaignInput | EmailEventCreateOrConnectWithoutCampaignInput[]
    createMany?: EmailEventCreateManyCampaignInputEnvelope
    connect?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignsInput
    upsert?: UserUpsertWithoutCampaignsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCampaignsInput, UserUpdateWithoutCampaignsInput>, UserUncheckedUpdateWithoutCampaignsInput>
  }

  export type EmailTemplateUpdateOneWithoutCampaignsNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutCampaignsInput, EmailTemplateUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutCampaignsInput
    upsert?: EmailTemplateUpsertWithoutCampaignsInput
    disconnect?: EmailTemplateWhereInput | boolean
    delete?: EmailTemplateWhereInput | boolean
    connect?: EmailTemplateWhereUniqueInput
    update?: XOR<XOR<EmailTemplateUpdateToOneWithWhereWithoutCampaignsInput, EmailTemplateUpdateWithoutCampaignsInput>, EmailTemplateUncheckedUpdateWithoutCampaignsInput>
  }

  export type CampaignLeadUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignLeadCreateWithoutCampaignInput, CampaignLeadUncheckedCreateWithoutCampaignInput> | CampaignLeadCreateWithoutCampaignInput[] | CampaignLeadUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutCampaignInput | CampaignLeadCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignLeadUpsertWithWhereUniqueWithoutCampaignInput | CampaignLeadUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignLeadCreateManyCampaignInputEnvelope
    set?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    disconnect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    delete?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    update?: CampaignLeadUpdateWithWhereUniqueWithoutCampaignInput | CampaignLeadUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignLeadUpdateManyWithWhereWithoutCampaignInput | CampaignLeadUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignLeadScalarWhereInput | CampaignLeadScalarWhereInput[]
  }

  export type EmailEventUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<EmailEventCreateWithoutCampaignInput, EmailEventUncheckedCreateWithoutCampaignInput> | EmailEventCreateWithoutCampaignInput[] | EmailEventUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EmailEventCreateOrConnectWithoutCampaignInput | EmailEventCreateOrConnectWithoutCampaignInput[]
    upsert?: EmailEventUpsertWithWhereUniqueWithoutCampaignInput | EmailEventUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: EmailEventCreateManyCampaignInputEnvelope
    set?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    disconnect?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    delete?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    connect?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    update?: EmailEventUpdateWithWhereUniqueWithoutCampaignInput | EmailEventUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: EmailEventUpdateManyWithWhereWithoutCampaignInput | EmailEventUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: EmailEventScalarWhereInput | EmailEventScalarWhereInput[]
  }

  export type CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignLeadCreateWithoutCampaignInput, CampaignLeadUncheckedCreateWithoutCampaignInput> | CampaignLeadCreateWithoutCampaignInput[] | CampaignLeadUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutCampaignInput | CampaignLeadCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignLeadUpsertWithWhereUniqueWithoutCampaignInput | CampaignLeadUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignLeadCreateManyCampaignInputEnvelope
    set?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    disconnect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    delete?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    update?: CampaignLeadUpdateWithWhereUniqueWithoutCampaignInput | CampaignLeadUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignLeadUpdateManyWithWhereWithoutCampaignInput | CampaignLeadUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignLeadScalarWhereInput | CampaignLeadScalarWhereInput[]
  }

  export type EmailEventUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<EmailEventCreateWithoutCampaignInput, EmailEventUncheckedCreateWithoutCampaignInput> | EmailEventCreateWithoutCampaignInput[] | EmailEventUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EmailEventCreateOrConnectWithoutCampaignInput | EmailEventCreateOrConnectWithoutCampaignInput[]
    upsert?: EmailEventUpsertWithWhereUniqueWithoutCampaignInput | EmailEventUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: EmailEventCreateManyCampaignInputEnvelope
    set?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    disconnect?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    delete?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    connect?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    update?: EmailEventUpdateWithWhereUniqueWithoutCampaignInput | EmailEventUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: EmailEventUpdateManyWithWhereWithoutCampaignInput | EmailEventUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: EmailEventScalarWhereInput | EmailEventScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutCampaignLeadsInput = {
    create?: XOR<CampaignCreateWithoutCampaignLeadsInput, CampaignUncheckedCreateWithoutCampaignLeadsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCampaignLeadsInput
    connect?: CampaignWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutCampaignLeadsInput = {
    create?: XOR<LeadCreateWithoutCampaignLeadsInput, LeadUncheckedCreateWithoutCampaignLeadsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutCampaignLeadsInput
    connect?: LeadWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutCampaignLeadsNestedInput = {
    create?: XOR<CampaignCreateWithoutCampaignLeadsInput, CampaignUncheckedCreateWithoutCampaignLeadsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCampaignLeadsInput
    upsert?: CampaignUpsertWithoutCampaignLeadsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutCampaignLeadsInput, CampaignUpdateWithoutCampaignLeadsInput>, CampaignUncheckedUpdateWithoutCampaignLeadsInput>
  }

  export type LeadUpdateOneRequiredWithoutCampaignLeadsNestedInput = {
    create?: XOR<LeadCreateWithoutCampaignLeadsInput, LeadUncheckedCreateWithoutCampaignLeadsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutCampaignLeadsInput
    upsert?: LeadUpsertWithoutCampaignLeadsInput
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutCampaignLeadsInput, LeadUpdateWithoutCampaignLeadsInput>, LeadUncheckedUpdateWithoutCampaignLeadsInput>
  }

  export type EmailTemplateCreatevariablesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutEmailTemplatesInput = {
    create?: XOR<UserCreateWithoutEmailTemplatesInput, UserUncheckedCreateWithoutEmailTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailTemplatesInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignCreateNestedManyWithoutTemplateInput = {
    create?: XOR<CampaignCreateWithoutTemplateInput, CampaignUncheckedCreateWithoutTemplateInput> | CampaignCreateWithoutTemplateInput[] | CampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTemplateInput | CampaignCreateOrConnectWithoutTemplateInput[]
    createMany?: CampaignCreateManyTemplateInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<CampaignCreateWithoutTemplateInput, CampaignUncheckedCreateWithoutTemplateInput> | CampaignCreateWithoutTemplateInput[] | CampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTemplateInput | CampaignCreateOrConnectWithoutTemplateInput[]
    createMany?: CampaignCreateManyTemplateInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type EmailTemplateUpdatevariablesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutEmailTemplatesNestedInput = {
    create?: XOR<UserCreateWithoutEmailTemplatesInput, UserUncheckedCreateWithoutEmailTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailTemplatesInput
    upsert?: UserUpsertWithoutEmailTemplatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailTemplatesInput, UserUpdateWithoutEmailTemplatesInput>, UserUncheckedUpdateWithoutEmailTemplatesInput>
  }

  export type CampaignUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<CampaignCreateWithoutTemplateInput, CampaignUncheckedCreateWithoutTemplateInput> | CampaignCreateWithoutTemplateInput[] | CampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTemplateInput | CampaignCreateOrConnectWithoutTemplateInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutTemplateInput | CampaignUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: CampaignCreateManyTemplateInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutTemplateInput | CampaignUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutTemplateInput | CampaignUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<CampaignCreateWithoutTemplateInput, CampaignUncheckedCreateWithoutTemplateInput> | CampaignCreateWithoutTemplateInput[] | CampaignUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTemplateInput | CampaignCreateOrConnectWithoutTemplateInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutTemplateInput | CampaignUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: CampaignCreateManyTemplateInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutTemplateInput | CampaignUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutTemplateInput | CampaignUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutEmailEventsInput = {
    create?: XOR<CampaignCreateWithoutEmailEventsInput, CampaignUncheckedCreateWithoutEmailEventsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutEmailEventsInput
    connect?: CampaignWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutEmailEventsInput = {
    create?: XOR<LeadCreateWithoutEmailEventsInput, LeadUncheckedCreateWithoutEmailEventsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutEmailEventsInput
    connect?: LeadWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutEmailEventsNestedInput = {
    create?: XOR<CampaignCreateWithoutEmailEventsInput, CampaignUncheckedCreateWithoutEmailEventsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutEmailEventsInput
    upsert?: CampaignUpsertWithoutEmailEventsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutEmailEventsInput, CampaignUpdateWithoutEmailEventsInput>, CampaignUncheckedUpdateWithoutEmailEventsInput>
  }

  export type LeadUpdateOneRequiredWithoutEmailEventsNestedInput = {
    create?: XOR<LeadCreateWithoutEmailEventsInput, LeadUncheckedCreateWithoutEmailEventsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutEmailEventsInput
    upsert?: LeadUpsertWithoutEmailEventsInput
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutEmailEventsInput, LeadUpdateWithoutEmailEventsInput>, LeadUncheckedUpdateWithoutEmailEventsInput>
  }

  export type UserCreateNestedOneWithoutWebsitesInput = {
    create?: XOR<UserCreateWithoutWebsitesInput, UserUncheckedCreateWithoutWebsitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWebsitesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWebsitesNestedInput = {
    create?: XOR<UserCreateWithoutWebsitesInput, UserUncheckedCreateWithoutWebsitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWebsitesInput
    upsert?: UserUpsertWithoutWebsitesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWebsitesInput, UserUpdateWithoutWebsitesInput>, UserUncheckedUpdateWithoutWebsitesInput>
  }

  export type UserCreateNestedOneWithoutVideosInput = {
    create?: XOR<UserCreateWithoutVideosInput, UserUncheckedCreateWithoutVideosInput>
    connectOrCreate?: UserCreateOrConnectWithoutVideosInput
    connect?: UserWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutVideosNestedInput = {
    create?: XOR<UserCreateWithoutVideosInput, UserUncheckedCreateWithoutVideosInput>
    connectOrCreate?: UserCreateOrConnectWithoutVideosInput
    upsert?: UserUpsertWithoutVideosInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVideosInput, UserUpdateWithoutVideosInput>, UserUncheckedUpdateWithoutVideosInput>
  }

  export type ApiKeyCreatepermissionsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    connect?: UserWhereUniqueInput
  }

  export type ApiKeyUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    upsert?: UserUpsertWithoutApiKeysInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApiKeysInput, UserUpdateWithoutApiKeysInput>, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type ConversationCreatetagsInput = {
    set: string[]
  }

  export type ConversationCreatelabelsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutConversationsInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    connect?: UserWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationNoteCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationNoteCreateWithoutConversationInput, ConversationNoteUncheckedCreateWithoutConversationInput> | ConversationNoteCreateWithoutConversationInput[] | ConversationNoteUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationNoteCreateOrConnectWithoutConversationInput | ConversationNoteCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationNoteCreateManyConversationInputEnvelope
    connect?: ConversationNoteWhereUniqueInput | ConversationNoteWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationNoteUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationNoteCreateWithoutConversationInput, ConversationNoteUncheckedCreateWithoutConversationInput> | ConversationNoteCreateWithoutConversationInput[] | ConversationNoteUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationNoteCreateOrConnectWithoutConversationInput | ConversationNoteCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationNoteCreateManyConversationInputEnvelope
    connect?: ConversationNoteWhereUniqueInput | ConversationNoteWhereUniqueInput[]
  }

  export type ConversationUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ConversationUpdatelabelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    upsert?: UserUpsertWithoutConversationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversationsInput, UserUpdateWithoutConversationsInput>, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationNoteUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationNoteCreateWithoutConversationInput, ConversationNoteUncheckedCreateWithoutConversationInput> | ConversationNoteCreateWithoutConversationInput[] | ConversationNoteUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationNoteCreateOrConnectWithoutConversationInput | ConversationNoteCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationNoteUpsertWithWhereUniqueWithoutConversationInput | ConversationNoteUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationNoteCreateManyConversationInputEnvelope
    set?: ConversationNoteWhereUniqueInput | ConversationNoteWhereUniqueInput[]
    disconnect?: ConversationNoteWhereUniqueInput | ConversationNoteWhereUniqueInput[]
    delete?: ConversationNoteWhereUniqueInput | ConversationNoteWhereUniqueInput[]
    connect?: ConversationNoteWhereUniqueInput | ConversationNoteWhereUniqueInput[]
    update?: ConversationNoteUpdateWithWhereUniqueWithoutConversationInput | ConversationNoteUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationNoteUpdateManyWithWhereWithoutConversationInput | ConversationNoteUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationNoteScalarWhereInput | ConversationNoteScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationNoteUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationNoteCreateWithoutConversationInput, ConversationNoteUncheckedCreateWithoutConversationInput> | ConversationNoteCreateWithoutConversationInput[] | ConversationNoteUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationNoteCreateOrConnectWithoutConversationInput | ConversationNoteCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationNoteUpsertWithWhereUniqueWithoutConversationInput | ConversationNoteUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationNoteCreateManyConversationInputEnvelope
    set?: ConversationNoteWhereUniqueInput | ConversationNoteWhereUniqueInput[]
    disconnect?: ConversationNoteWhereUniqueInput | ConversationNoteWhereUniqueInput[]
    delete?: ConversationNoteWhereUniqueInput | ConversationNoteWhereUniqueInput[]
    connect?: ConversationNoteWhereUniqueInput | ConversationNoteWhereUniqueInput[]
    update?: ConversationNoteUpdateWithWhereUniqueWithoutConversationInput | ConversationNoteUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationNoteUpdateManyWithWhereWithoutConversationInput | ConversationNoteUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationNoteScalarWhereInput | ConversationNoteScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    upsert?: UserUpsertWithoutMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesInput, UserUpdateWithoutMessagesInput>, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type CannedResponseCreatetagsInput = {
    set: string[]
  }

  export type CannedResponseCreatechannelsInput = {
    set: string[]
  }

  export type CannedResponseCreatevariablesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCannedResponsesInput = {
    create?: XOR<UserCreateWithoutCannedResponsesInput, UserUncheckedCreateWithoutCannedResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCannedResponsesInput
    connect?: UserWhereUniqueInput
  }

  export type AutoResponseCreateNestedManyWithoutCannedResponseInput = {
    create?: XOR<AutoResponseCreateWithoutCannedResponseInput, AutoResponseUncheckedCreateWithoutCannedResponseInput> | AutoResponseCreateWithoutCannedResponseInput[] | AutoResponseUncheckedCreateWithoutCannedResponseInput[]
    connectOrCreate?: AutoResponseCreateOrConnectWithoutCannedResponseInput | AutoResponseCreateOrConnectWithoutCannedResponseInput[]
    createMany?: AutoResponseCreateManyCannedResponseInputEnvelope
    connect?: AutoResponseWhereUniqueInput | AutoResponseWhereUniqueInput[]
  }

  export type AutoResponseUncheckedCreateNestedManyWithoutCannedResponseInput = {
    create?: XOR<AutoResponseCreateWithoutCannedResponseInput, AutoResponseUncheckedCreateWithoutCannedResponseInput> | AutoResponseCreateWithoutCannedResponseInput[] | AutoResponseUncheckedCreateWithoutCannedResponseInput[]
    connectOrCreate?: AutoResponseCreateOrConnectWithoutCannedResponseInput | AutoResponseCreateOrConnectWithoutCannedResponseInput[]
    createMany?: AutoResponseCreateManyCannedResponseInputEnvelope
    connect?: AutoResponseWhereUniqueInput | AutoResponseWhereUniqueInput[]
  }

  export type CannedResponseUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CannedResponseUpdatechannelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CannedResponseUpdatevariablesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutCannedResponsesNestedInput = {
    create?: XOR<UserCreateWithoutCannedResponsesInput, UserUncheckedCreateWithoutCannedResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCannedResponsesInput
    upsert?: UserUpsertWithoutCannedResponsesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCannedResponsesInput, UserUpdateWithoutCannedResponsesInput>, UserUncheckedUpdateWithoutCannedResponsesInput>
  }

  export type AutoResponseUpdateManyWithoutCannedResponseNestedInput = {
    create?: XOR<AutoResponseCreateWithoutCannedResponseInput, AutoResponseUncheckedCreateWithoutCannedResponseInput> | AutoResponseCreateWithoutCannedResponseInput[] | AutoResponseUncheckedCreateWithoutCannedResponseInput[]
    connectOrCreate?: AutoResponseCreateOrConnectWithoutCannedResponseInput | AutoResponseCreateOrConnectWithoutCannedResponseInput[]
    upsert?: AutoResponseUpsertWithWhereUniqueWithoutCannedResponseInput | AutoResponseUpsertWithWhereUniqueWithoutCannedResponseInput[]
    createMany?: AutoResponseCreateManyCannedResponseInputEnvelope
    set?: AutoResponseWhereUniqueInput | AutoResponseWhereUniqueInput[]
    disconnect?: AutoResponseWhereUniqueInput | AutoResponseWhereUniqueInput[]
    delete?: AutoResponseWhereUniqueInput | AutoResponseWhereUniqueInput[]
    connect?: AutoResponseWhereUniqueInput | AutoResponseWhereUniqueInput[]
    update?: AutoResponseUpdateWithWhereUniqueWithoutCannedResponseInput | AutoResponseUpdateWithWhereUniqueWithoutCannedResponseInput[]
    updateMany?: AutoResponseUpdateManyWithWhereWithoutCannedResponseInput | AutoResponseUpdateManyWithWhereWithoutCannedResponseInput[]
    deleteMany?: AutoResponseScalarWhereInput | AutoResponseScalarWhereInput[]
  }

  export type AutoResponseUncheckedUpdateManyWithoutCannedResponseNestedInput = {
    create?: XOR<AutoResponseCreateWithoutCannedResponseInput, AutoResponseUncheckedCreateWithoutCannedResponseInput> | AutoResponseCreateWithoutCannedResponseInput[] | AutoResponseUncheckedCreateWithoutCannedResponseInput[]
    connectOrCreate?: AutoResponseCreateOrConnectWithoutCannedResponseInput | AutoResponseCreateOrConnectWithoutCannedResponseInput[]
    upsert?: AutoResponseUpsertWithWhereUniqueWithoutCannedResponseInput | AutoResponseUpsertWithWhereUniqueWithoutCannedResponseInput[]
    createMany?: AutoResponseCreateManyCannedResponseInputEnvelope
    set?: AutoResponseWhereUniqueInput | AutoResponseWhereUniqueInput[]
    disconnect?: AutoResponseWhereUniqueInput | AutoResponseWhereUniqueInput[]
    delete?: AutoResponseWhereUniqueInput | AutoResponseWhereUniqueInput[]
    connect?: AutoResponseWhereUniqueInput | AutoResponseWhereUniqueInput[]
    update?: AutoResponseUpdateWithWhereUniqueWithoutCannedResponseInput | AutoResponseUpdateWithWhereUniqueWithoutCannedResponseInput[]
    updateMany?: AutoResponseUpdateManyWithWhereWithoutCannedResponseInput | AutoResponseUpdateManyWithWhereWithoutCannedResponseInput[]
    deleteMany?: AutoResponseScalarWhereInput | AutoResponseScalarWhereInput[]
  }

  export type AutoResponseCreatechannelsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAutoResponsesInput = {
    create?: XOR<UserCreateWithoutAutoResponsesInput, UserUncheckedCreateWithoutAutoResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAutoResponsesInput
    connect?: UserWhereUniqueInput
  }

  export type CannedResponseCreateNestedOneWithoutAutoResponseInput = {
    create?: XOR<CannedResponseCreateWithoutAutoResponseInput, CannedResponseUncheckedCreateWithoutAutoResponseInput>
    connectOrCreate?: CannedResponseCreateOrConnectWithoutAutoResponseInput
    connect?: CannedResponseWhereUniqueInput
  }

  export type AutoResponseUpdatechannelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutAutoResponsesNestedInput = {
    create?: XOR<UserCreateWithoutAutoResponsesInput, UserUncheckedCreateWithoutAutoResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAutoResponsesInput
    upsert?: UserUpsertWithoutAutoResponsesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAutoResponsesInput, UserUpdateWithoutAutoResponsesInput>, UserUncheckedUpdateWithoutAutoResponsesInput>
  }

  export type CannedResponseUpdateOneWithoutAutoResponseNestedInput = {
    create?: XOR<CannedResponseCreateWithoutAutoResponseInput, CannedResponseUncheckedCreateWithoutAutoResponseInput>
    connectOrCreate?: CannedResponseCreateOrConnectWithoutAutoResponseInput
    upsert?: CannedResponseUpsertWithoutAutoResponseInput
    disconnect?: CannedResponseWhereInput | boolean
    delete?: CannedResponseWhereInput | boolean
    connect?: CannedResponseWhereUniqueInput
    update?: XOR<XOR<CannedResponseUpdateToOneWithWhereWithoutAutoResponseInput, CannedResponseUpdateWithoutAutoResponseInput>, CannedResponseUncheckedUpdateWithoutAutoResponseInput>
  }

  export type ConversationCreateNestedOneWithoutNotesInput = {
    create?: XOR<ConversationCreateWithoutNotesInput, ConversationUncheckedCreateWithoutNotesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutNotesInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConversationNotesInput = {
    create?: XOR<UserCreateWithoutConversationNotesInput, UserUncheckedCreateWithoutConversationNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationNotesInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<ConversationCreateWithoutNotesInput, ConversationUncheckedCreateWithoutNotesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutNotesInput
    upsert?: ConversationUpsertWithoutNotesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutNotesInput, ConversationUpdateWithoutNotesInput>, ConversationUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateOneRequiredWithoutConversationNotesNestedInput = {
    create?: XOR<UserCreateWithoutConversationNotesInput, UserUncheckedCreateWithoutConversationNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationNotesInput
    upsert?: UserUpsertWithoutConversationNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversationNotesInput, UserUpdateWithoutConversationNotesInput>, UserUncheckedUpdateWithoutConversationNotesInput>
  }

  export type RepairHistoryCreateNestedManyWithoutDiagnosticInput = {
    create?: XOR<RepairHistoryCreateWithoutDiagnosticInput, RepairHistoryUncheckedCreateWithoutDiagnosticInput> | RepairHistoryCreateWithoutDiagnosticInput[] | RepairHistoryUncheckedCreateWithoutDiagnosticInput[]
    connectOrCreate?: RepairHistoryCreateOrConnectWithoutDiagnosticInput | RepairHistoryCreateOrConnectWithoutDiagnosticInput[]
    createMany?: RepairHistoryCreateManyDiagnosticInputEnvelope
    connect?: RepairHistoryWhereUniqueInput | RepairHistoryWhereUniqueInput[]
  }

  export type RepairHistoryUncheckedCreateNestedManyWithoutDiagnosticInput = {
    create?: XOR<RepairHistoryCreateWithoutDiagnosticInput, RepairHistoryUncheckedCreateWithoutDiagnosticInput> | RepairHistoryCreateWithoutDiagnosticInput[] | RepairHistoryUncheckedCreateWithoutDiagnosticInput[]
    connectOrCreate?: RepairHistoryCreateOrConnectWithoutDiagnosticInput | RepairHistoryCreateOrConnectWithoutDiagnosticInput[]
    createMany?: RepairHistoryCreateManyDiagnosticInputEnvelope
    connect?: RepairHistoryWhereUniqueInput | RepairHistoryWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type RepairHistoryUpdateManyWithoutDiagnosticNestedInput = {
    create?: XOR<RepairHistoryCreateWithoutDiagnosticInput, RepairHistoryUncheckedCreateWithoutDiagnosticInput> | RepairHistoryCreateWithoutDiagnosticInput[] | RepairHistoryUncheckedCreateWithoutDiagnosticInput[]
    connectOrCreate?: RepairHistoryCreateOrConnectWithoutDiagnosticInput | RepairHistoryCreateOrConnectWithoutDiagnosticInput[]
    upsert?: RepairHistoryUpsertWithWhereUniqueWithoutDiagnosticInput | RepairHistoryUpsertWithWhereUniqueWithoutDiagnosticInput[]
    createMany?: RepairHistoryCreateManyDiagnosticInputEnvelope
    set?: RepairHistoryWhereUniqueInput | RepairHistoryWhereUniqueInput[]
    disconnect?: RepairHistoryWhereUniqueInput | RepairHistoryWhereUniqueInput[]
    delete?: RepairHistoryWhereUniqueInput | RepairHistoryWhereUniqueInput[]
    connect?: RepairHistoryWhereUniqueInput | RepairHistoryWhereUniqueInput[]
    update?: RepairHistoryUpdateWithWhereUniqueWithoutDiagnosticInput | RepairHistoryUpdateWithWhereUniqueWithoutDiagnosticInput[]
    updateMany?: RepairHistoryUpdateManyWithWhereWithoutDiagnosticInput | RepairHistoryUpdateManyWithWhereWithoutDiagnosticInput[]
    deleteMany?: RepairHistoryScalarWhereInput | RepairHistoryScalarWhereInput[]
  }

  export type RepairHistoryUncheckedUpdateManyWithoutDiagnosticNestedInput = {
    create?: XOR<RepairHistoryCreateWithoutDiagnosticInput, RepairHistoryUncheckedCreateWithoutDiagnosticInput> | RepairHistoryCreateWithoutDiagnosticInput[] | RepairHistoryUncheckedCreateWithoutDiagnosticInput[]
    connectOrCreate?: RepairHistoryCreateOrConnectWithoutDiagnosticInput | RepairHistoryCreateOrConnectWithoutDiagnosticInput[]
    upsert?: RepairHistoryUpsertWithWhereUniqueWithoutDiagnosticInput | RepairHistoryUpsertWithWhereUniqueWithoutDiagnosticInput[]
    createMany?: RepairHistoryCreateManyDiagnosticInputEnvelope
    set?: RepairHistoryWhereUniqueInput | RepairHistoryWhereUniqueInput[]
    disconnect?: RepairHistoryWhereUniqueInput | RepairHistoryWhereUniqueInput[]
    delete?: RepairHistoryWhereUniqueInput | RepairHistoryWhereUniqueInput[]
    connect?: RepairHistoryWhereUniqueInput | RepairHistoryWhereUniqueInput[]
    update?: RepairHistoryUpdateWithWhereUniqueWithoutDiagnosticInput | RepairHistoryUpdateWithWhereUniqueWithoutDiagnosticInput[]
    updateMany?: RepairHistoryUpdateManyWithWhereWithoutDiagnosticInput | RepairHistoryUpdateManyWithWhereWithoutDiagnosticInput[]
    deleteMany?: RepairHistoryScalarWhereInput | RepairHistoryScalarWhereInput[]
  }

  export type DiagnosticReportCreateNestedOneWithoutRepairsInput = {
    create?: XOR<DiagnosticReportCreateWithoutRepairsInput, DiagnosticReportUncheckedCreateWithoutRepairsInput>
    connectOrCreate?: DiagnosticReportCreateOrConnectWithoutRepairsInput
    connect?: DiagnosticReportWhereUniqueInput
  }

  export type DiagnosticReportUpdateOneWithoutRepairsNestedInput = {
    create?: XOR<DiagnosticReportCreateWithoutRepairsInput, DiagnosticReportUncheckedCreateWithoutRepairsInput>
    connectOrCreate?: DiagnosticReportCreateOrConnectWithoutRepairsInput
    upsert?: DiagnosticReportUpsertWithoutRepairsInput
    disconnect?: DiagnosticReportWhereInput | boolean
    delete?: DiagnosticReportWhereInput | boolean
    connect?: DiagnosticReportWhereUniqueInput
    update?: XOR<XOR<DiagnosticReportUpdateToOneWithWhereWithoutRepairsInput, DiagnosticReportUpdateWithoutRepairsInput>, DiagnosticReportUncheckedUpdateWithoutRepairsInput>
  }

  export type AdminUserCreatepermissionsInput = {
    set: string[]
  }

  export type AdminAuditLogCreateNestedManyWithoutAdminUserInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminUserInput, AdminAuditLogUncheckedCreateWithoutAdminUserInput> | AdminAuditLogCreateWithoutAdminUserInput[] | AdminAuditLogUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminUserInput | AdminAuditLogCreateOrConnectWithoutAdminUserInput[]
    createMany?: AdminAuditLogCreateManyAdminUserInputEnvelope
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
  }

  export type AdminAuditLogUncheckedCreateNestedManyWithoutAdminUserInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminUserInput, AdminAuditLogUncheckedCreateWithoutAdminUserInput> | AdminAuditLogCreateWithoutAdminUserInput[] | AdminAuditLogUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminUserInput | AdminAuditLogCreateOrConnectWithoutAdminUserInput[]
    createMany?: AdminAuditLogCreateManyAdminUserInputEnvelope
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
  }

  export type AdminUserUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AdminAuditLogUpdateManyWithoutAdminUserNestedInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminUserInput, AdminAuditLogUncheckedCreateWithoutAdminUserInput> | AdminAuditLogCreateWithoutAdminUserInput[] | AdminAuditLogUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminUserInput | AdminAuditLogCreateOrConnectWithoutAdminUserInput[]
    upsert?: AdminAuditLogUpsertWithWhereUniqueWithoutAdminUserInput | AdminAuditLogUpsertWithWhereUniqueWithoutAdminUserInput[]
    createMany?: AdminAuditLogCreateManyAdminUserInputEnvelope
    set?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    disconnect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    delete?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    update?: AdminAuditLogUpdateWithWhereUniqueWithoutAdminUserInput | AdminAuditLogUpdateWithWhereUniqueWithoutAdminUserInput[]
    updateMany?: AdminAuditLogUpdateManyWithWhereWithoutAdminUserInput | AdminAuditLogUpdateManyWithWhereWithoutAdminUserInput[]
    deleteMany?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
  }

  export type AdminAuditLogUncheckedUpdateManyWithoutAdminUserNestedInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminUserInput, AdminAuditLogUncheckedCreateWithoutAdminUserInput> | AdminAuditLogCreateWithoutAdminUserInput[] | AdminAuditLogUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminUserInput | AdminAuditLogCreateOrConnectWithoutAdminUserInput[]
    upsert?: AdminAuditLogUpsertWithWhereUniqueWithoutAdminUserInput | AdminAuditLogUpsertWithWhereUniqueWithoutAdminUserInput[]
    createMany?: AdminAuditLogCreateManyAdminUserInputEnvelope
    set?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    disconnect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    delete?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    update?: AdminAuditLogUpdateWithWhereUniqueWithoutAdminUserInput | AdminAuditLogUpdateWithWhereUniqueWithoutAdminUserInput[]
    updateMany?: AdminAuditLogUpdateManyWithWhereWithoutAdminUserInput | AdminAuditLogUpdateManyWithWhereWithoutAdminUserInput[]
    deleteMany?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
  }

  export type AdminUserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<AdminUserCreateWithoutAuditLogsInput, AdminUserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutAuditLogsInput
    connect?: AdminUserWhereUniqueInput
  }

  export type AdminUserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<AdminUserCreateWithoutAuditLogsInput, AdminUserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutAuditLogsInput
    upsert?: AdminUserUpsertWithoutAuditLogsInput
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutAuditLogsInput, AdminUserUpdateWithoutAuditLogsInput>, AdminUserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type LeadCreateWithoutUserInput = {
    id?: string
    email: string
    name?: string | null
    company?: string | null
    phone?: string | null
    title?: string | null
    website?: string | null
    linkedinUrl?: string | null
    source?: string | null
    status?: string
    score?: number | null
    notes?: string | null
    tags?: LeadCreatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastContactedAt?: Date | string | null
    campaignLeads?: CampaignLeadCreateNestedManyWithoutLeadInput
    emailEvents?: EmailEventCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutUserInput = {
    id?: string
    email: string
    name?: string | null
    company?: string | null
    phone?: string | null
    title?: string | null
    website?: string | null
    linkedinUrl?: string | null
    source?: string | null
    status?: string
    score?: number | null
    notes?: string | null
    tags?: LeadCreatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastContactedAt?: Date | string | null
    campaignLeads?: CampaignLeadUncheckedCreateNestedManyWithoutLeadInput
    emailEvents?: EmailEventUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutUserInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutUserInput, LeadUncheckedCreateWithoutUserInput>
  }

  export type LeadCreateManyUserInputEnvelope = {
    data: LeadCreateManyUserInput | LeadCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    type?: string
    status?: string
    subject?: string | null
    fromName?: string | null
    fromEmail?: string | null
    replyTo?: string | null
    htmlContent?: string | null
    textContent?: string | null
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    totalLeads?: number
    sentCount?: number
    openCount?: number
    clickCount?: number
    replyCount?: number
    bounceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: EmailTemplateCreateNestedOneWithoutCampaignsInput
    campaignLeads?: CampaignLeadCreateNestedManyWithoutCampaignInput
    emailEvents?: EmailEventCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    type?: string
    status?: string
    subject?: string | null
    fromName?: string | null
    fromEmail?: string | null
    replyTo?: string | null
    templateId?: string | null
    htmlContent?: string | null
    textContent?: string | null
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    totalLeads?: number
    sentCount?: number
    openCount?: number
    clickCount?: number
    replyCount?: number
    bounceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignLeads?: CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput
    emailEvents?: EmailEventUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutUserInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput>
  }

  export type CampaignCreateManyUserInputEnvelope = {
    data: CampaignCreateManyUserInput | CampaignCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmailTemplateCreateWithoutUserInput = {
    id?: string
    name: string
    subject?: string | null
    htmlContent?: string | null
    textContent?: string | null
    variables?: EmailTemplateCreatevariablesInput | string[]
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    subject?: string | null
    htmlContent?: string | null
    textContent?: string | null
    variables?: EmailTemplateCreatevariablesInput | string[]
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateCreateOrConnectWithoutUserInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutUserInput, EmailTemplateUncheckedCreateWithoutUserInput>
  }

  export type EmailTemplateCreateManyUserInputEnvelope = {
    data: EmailTemplateCreateManyUserInput | EmailTemplateCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WebsiteCreateWithoutUserInput = {
    id?: string
    name: string
    domain?: string | null
    subdomain?: string | null
    pages?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    theme?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebsiteUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    domain?: string | null
    subdomain?: string | null
    pages?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    theme?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebsiteCreateOrConnectWithoutUserInput = {
    where: WebsiteWhereUniqueInput
    create: XOR<WebsiteCreateWithoutUserInput, WebsiteUncheckedCreateWithoutUserInput>
  }

  export type WebsiteCreateManyUserInputEnvelope = {
    data: WebsiteCreateManyUserInput | WebsiteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VideoCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    filename?: string | null
    fileUrl?: string | null
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: number | null
    isMonetized?: boolean
    viewCount?: number
    earnings?: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    filename?: string | null
    fileUrl?: string | null
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: number | null
    isMonetized?: boolean
    viewCount?: number
    earnings?: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateOrConnectWithoutUserInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutUserInput, VideoUncheckedCreateWithoutUserInput>
  }

  export type VideoCreateManyUserInputEnvelope = {
    data: VideoCreateManyUserInput | VideoCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ApiKeyCreateWithoutUserInput = {
    id?: string
    name: string
    key: string
    permissions?: ApiKeyCreatepermissionsInput | string[]
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ApiKeyUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    key: string
    permissions?: ApiKeyCreatepermissionsInput | string[]
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ApiKeyCreateOrConnectWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyCreateManyUserInputEnvelope = {
    data: ApiKeyCreateManyUserInput | ApiKeyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutUserInput = {
    id?: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    contactId?: string | null
    channel: string
    channelId?: string | null
    subject?: string | null
    status?: string
    priority?: string
    assignedTo?: string | null
    tags?: ConversationCreatetagsInput | string[]
    labels?: ConversationCreatelabelsInput | string[]
    messageCount?: number
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string | null
    closedAt?: Date | string | null
    messages?: MessageCreateNestedManyWithoutConversationInput
    notes?: ConversationNoteCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutUserInput = {
    id?: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    contactId?: string | null
    channel: string
    channelId?: string | null
    subject?: string | null
    status?: string
    priority?: string
    assignedTo?: string | null
    tags?: ConversationCreatetagsInput | string[]
    labels?: ConversationCreatelabelsInput | string[]
    messageCount?: number
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string | null
    closedAt?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    notes?: ConversationNoteUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutUserInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationCreateManyUserInputEnvelope = {
    data: ConversationCreateManyUserInput | ConversationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutUserInput = {
    id?: string
    content: string
    htmlContent?: string | null
    subject?: string | null
    channel: string
    channelMessageId?: string | null
    direction?: string
    status?: string
    isRead?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutUserInput = {
    id?: string
    conversationId: string
    content: string
    htmlContent?: string | null
    subject?: string | null
    channel: string
    channelMessageId?: string | null
    direction?: string
    status?: string
    isRead?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type MessageCreateOrConnectWithoutUserInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageCreateManyUserInputEnvelope = {
    data: MessageCreateManyUserInput | MessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CannedResponseCreateWithoutUserInput = {
    id?: string
    name: string
    content: string
    htmlContent?: string | null
    subject?: string | null
    category?: string | null
    tags?: CannedResponseCreatetagsInput | string[]
    channels?: CannedResponseCreatechannelsInput | string[]
    variables?: CannedResponseCreatevariablesInput | string[]
    useCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    AutoResponse?: AutoResponseCreateNestedManyWithoutCannedResponseInput
  }

  export type CannedResponseUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    content: string
    htmlContent?: string | null
    subject?: string | null
    category?: string | null
    tags?: CannedResponseCreatetagsInput | string[]
    channels?: CannedResponseCreatechannelsInput | string[]
    variables?: CannedResponseCreatevariablesInput | string[]
    useCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    AutoResponse?: AutoResponseUncheckedCreateNestedManyWithoutCannedResponseInput
  }

  export type CannedResponseCreateOrConnectWithoutUserInput = {
    where: CannedResponseWhereUniqueInput
    create: XOR<CannedResponseCreateWithoutUserInput, CannedResponseUncheckedCreateWithoutUserInput>
  }

  export type CannedResponseCreateManyUserInputEnvelope = {
    data: CannedResponseCreateManyUserInput | CannedResponseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AutoResponseCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    enabled?: boolean
    triggerType: string
    conditions: JsonNullValueInput | InputJsonValue
    responseContent?: string | null
    responseSubject?: string | null
    channels?: AutoResponseCreatechannelsInput | string[]
    priority?: number
    delaySeconds?: number
    maxPerDay?: number | null
    maxPerContact?: number | null
    triggerCount?: number
    lastTriggeredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cannedResponse?: CannedResponseCreateNestedOneWithoutAutoResponseInput
  }

  export type AutoResponseUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    enabled?: boolean
    triggerType: string
    conditions: JsonNullValueInput | InputJsonValue
    cannedResponseId?: string | null
    responseContent?: string | null
    responseSubject?: string | null
    channels?: AutoResponseCreatechannelsInput | string[]
    priority?: number
    delaySeconds?: number
    maxPerDay?: number | null
    maxPerContact?: number | null
    triggerCount?: number
    lastTriggeredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutoResponseCreateOrConnectWithoutUserInput = {
    where: AutoResponseWhereUniqueInput
    create: XOR<AutoResponseCreateWithoutUserInput, AutoResponseUncheckedCreateWithoutUserInput>
  }

  export type AutoResponseCreateManyUserInputEnvelope = {
    data: AutoResponseCreateManyUserInput | AutoResponseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConversationNoteCreateWithoutUserInput = {
    id?: string
    content: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutNotesInput
  }

  export type ConversationNoteUncheckedCreateWithoutUserInput = {
    id?: string
    conversationId: string
    content: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationNoteCreateOrConnectWithoutUserInput = {
    where: ConversationNoteWhereUniqueInput
    create: XOR<ConversationNoteCreateWithoutUserInput, ConversationNoteUncheckedCreateWithoutUserInput>
  }

  export type ConversationNoteCreateManyUserInputEnvelope = {
    data: ConversationNoteCreateManyUserInput | ConversationNoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LeadUpsertWithWhereUniqueWithoutUserInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutUserInput, LeadUncheckedUpdateWithoutUserInput>
    create: XOR<LeadCreateWithoutUserInput, LeadUncheckedCreateWithoutUserInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutUserInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutUserInput, LeadUncheckedUpdateWithoutUserInput>
  }

  export type LeadUpdateManyWithWhereWithoutUserInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutUserInput>
  }

  export type LeadScalarWhereInput = {
    AND?: LeadScalarWhereInput | LeadScalarWhereInput[]
    OR?: LeadScalarWhereInput[]
    NOT?: LeadScalarWhereInput | LeadScalarWhereInput[]
    id?: StringFilter<"Lead"> | string
    userId?: StringFilter<"Lead"> | string
    email?: StringFilter<"Lead"> | string
    name?: StringNullableFilter<"Lead"> | string | null
    company?: StringNullableFilter<"Lead"> | string | null
    phone?: StringNullableFilter<"Lead"> | string | null
    title?: StringNullableFilter<"Lead"> | string | null
    website?: StringNullableFilter<"Lead"> | string | null
    linkedinUrl?: StringNullableFilter<"Lead"> | string | null
    source?: StringNullableFilter<"Lead"> | string | null
    status?: StringFilter<"Lead"> | string
    score?: IntNullableFilter<"Lead"> | number | null
    notes?: StringNullableFilter<"Lead"> | string | null
    tags?: StringNullableListFilter<"Lead">
    customFields?: JsonNullableFilter<"Lead">
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    lastContactedAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
  }

  export type CampaignUpsertWithWhereUniqueWithoutUserInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutUserInput, CampaignUncheckedUpdateWithoutUserInput>
    create: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutUserInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutUserInput, CampaignUncheckedUpdateWithoutUserInput>
  }

  export type CampaignUpdateManyWithWhereWithoutUserInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutUserInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    OR?: CampaignScalarWhereInput[]
    NOT?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    id?: StringFilter<"Campaign"> | string
    userId?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    type?: StringFilter<"Campaign"> | string
    status?: StringFilter<"Campaign"> | string
    subject?: StringNullableFilter<"Campaign"> | string | null
    fromName?: StringNullableFilter<"Campaign"> | string | null
    fromEmail?: StringNullableFilter<"Campaign"> | string | null
    replyTo?: StringNullableFilter<"Campaign"> | string | null
    templateId?: StringNullableFilter<"Campaign"> | string | null
    htmlContent?: StringNullableFilter<"Campaign"> | string | null
    textContent?: StringNullableFilter<"Campaign"> | string | null
    scheduledAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    totalLeads?: IntFilter<"Campaign"> | number
    sentCount?: IntFilter<"Campaign"> | number
    openCount?: IntFilter<"Campaign"> | number
    clickCount?: IntFilter<"Campaign"> | number
    replyCount?: IntFilter<"Campaign"> | number
    bounceCount?: IntFilter<"Campaign"> | number
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
  }

  export type EmailTemplateUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailTemplateWhereUniqueInput
    update: XOR<EmailTemplateUpdateWithoutUserInput, EmailTemplateUncheckedUpdateWithoutUserInput>
    create: XOR<EmailTemplateCreateWithoutUserInput, EmailTemplateUncheckedCreateWithoutUserInput>
  }

  export type EmailTemplateUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailTemplateWhereUniqueInput
    data: XOR<EmailTemplateUpdateWithoutUserInput, EmailTemplateUncheckedUpdateWithoutUserInput>
  }

  export type EmailTemplateUpdateManyWithWhereWithoutUserInput = {
    where: EmailTemplateScalarWhereInput
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyWithoutUserInput>
  }

  export type EmailTemplateScalarWhereInput = {
    AND?: EmailTemplateScalarWhereInput | EmailTemplateScalarWhereInput[]
    OR?: EmailTemplateScalarWhereInput[]
    NOT?: EmailTemplateScalarWhereInput | EmailTemplateScalarWhereInput[]
    id?: StringFilter<"EmailTemplate"> | string
    userId?: StringFilter<"EmailTemplate"> | string
    name?: StringFilter<"EmailTemplate"> | string
    subject?: StringNullableFilter<"EmailTemplate"> | string | null
    htmlContent?: StringNullableFilter<"EmailTemplate"> | string | null
    textContent?: StringNullableFilter<"EmailTemplate"> | string | null
    variables?: StringNullableListFilter<"EmailTemplate">
    isDefault?: BoolFilter<"EmailTemplate"> | boolean
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
  }

  export type WebsiteUpsertWithWhereUniqueWithoutUserInput = {
    where: WebsiteWhereUniqueInput
    update: XOR<WebsiteUpdateWithoutUserInput, WebsiteUncheckedUpdateWithoutUserInput>
    create: XOR<WebsiteCreateWithoutUserInput, WebsiteUncheckedCreateWithoutUserInput>
  }

  export type WebsiteUpdateWithWhereUniqueWithoutUserInput = {
    where: WebsiteWhereUniqueInput
    data: XOR<WebsiteUpdateWithoutUserInput, WebsiteUncheckedUpdateWithoutUserInput>
  }

  export type WebsiteUpdateManyWithWhereWithoutUserInput = {
    where: WebsiteScalarWhereInput
    data: XOR<WebsiteUpdateManyMutationInput, WebsiteUncheckedUpdateManyWithoutUserInput>
  }

  export type WebsiteScalarWhereInput = {
    AND?: WebsiteScalarWhereInput | WebsiteScalarWhereInput[]
    OR?: WebsiteScalarWhereInput[]
    NOT?: WebsiteScalarWhereInput | WebsiteScalarWhereInput[]
    id?: StringFilter<"Website"> | string
    userId?: StringFilter<"Website"> | string
    name?: StringFilter<"Website"> | string
    domain?: StringNullableFilter<"Website"> | string | null
    subdomain?: StringNullableFilter<"Website"> | string | null
    pages?: JsonNullableFilter<"Website">
    settings?: JsonNullableFilter<"Website">
    theme?: StringNullableFilter<"Website"> | string | null
    isPublished?: BoolFilter<"Website"> | boolean
    createdAt?: DateTimeFilter<"Website"> | Date | string
    updatedAt?: DateTimeFilter<"Website"> | Date | string
  }

  export type VideoUpsertWithWhereUniqueWithoutUserInput = {
    where: VideoWhereUniqueInput
    update: XOR<VideoUpdateWithoutUserInput, VideoUncheckedUpdateWithoutUserInput>
    create: XOR<VideoCreateWithoutUserInput, VideoUncheckedCreateWithoutUserInput>
  }

  export type VideoUpdateWithWhereUniqueWithoutUserInput = {
    where: VideoWhereUniqueInput
    data: XOR<VideoUpdateWithoutUserInput, VideoUncheckedUpdateWithoutUserInput>
  }

  export type VideoUpdateManyWithWhereWithoutUserInput = {
    where: VideoScalarWhereInput
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyWithoutUserInput>
  }

  export type VideoScalarWhereInput = {
    AND?: VideoScalarWhereInput | VideoScalarWhereInput[]
    OR?: VideoScalarWhereInput[]
    NOT?: VideoScalarWhereInput | VideoScalarWhereInput[]
    id?: StringFilter<"Video"> | string
    userId?: StringFilter<"Video"> | string
    title?: StringFilter<"Video"> | string
    description?: StringNullableFilter<"Video"> | string | null
    filename?: StringNullableFilter<"Video"> | string | null
    fileUrl?: StringNullableFilter<"Video"> | string | null
    thumbnailUrl?: StringNullableFilter<"Video"> | string | null
    duration?: IntNullableFilter<"Video"> | number | null
    fileSize?: IntNullableFilter<"Video"> | number | null
    isMonetized?: BoolFilter<"Video"> | boolean
    viewCount?: IntFilter<"Video"> | number
    earnings?: DecimalFilter<"Video"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Video"> | string
    createdAt?: DateTimeFilter<"Video"> | Date | string
    updatedAt?: DateTimeFilter<"Video"> | Date | string
  }

  export type ApiKeyUpsertWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    update: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyUpdateWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    data: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>
  }

  export type ApiKeyUpdateManyWithWhereWithoutUserInput = {
    where: ApiKeyScalarWhereInput
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutUserInput>
  }

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    OR?: ApiKeyScalarWhereInput[]
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    userId?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    key?: StringFilter<"ApiKey"> | string
    permissions?: StringNullableListFilter<"ApiKey">
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    isActive?: BoolFilter<"ApiKey"> | boolean
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
  }

  export type ConversationUpdateManyWithWhereWithoutUserInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutUserInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: StringFilter<"Conversation"> | string
    userId?: StringFilter<"Conversation"> | string
    contactName?: StringNullableFilter<"Conversation"> | string | null
    contactEmail?: StringNullableFilter<"Conversation"> | string | null
    contactPhone?: StringNullableFilter<"Conversation"> | string | null
    contactId?: StringNullableFilter<"Conversation"> | string | null
    channel?: StringFilter<"Conversation"> | string
    channelId?: StringNullableFilter<"Conversation"> | string | null
    subject?: StringNullableFilter<"Conversation"> | string | null
    status?: StringFilter<"Conversation"> | string
    priority?: StringFilter<"Conversation"> | string
    assignedTo?: StringNullableFilter<"Conversation"> | string | null
    tags?: StringNullableListFilter<"Conversation">
    labels?: StringNullableListFilter<"Conversation">
    messageCount?: IntFilter<"Conversation"> | number
    unreadCount?: IntFilter<"Conversation"> | number
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
  }

  export type MessageUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
  }

  export type MessageUpdateManyWithWhereWithoutUserInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    userId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    htmlContent?: StringNullableFilter<"Message"> | string | null
    subject?: StringNullableFilter<"Message"> | string | null
    channel?: StringFilter<"Message"> | string
    channelMessageId?: StringNullableFilter<"Message"> | string | null
    direction?: StringFilter<"Message"> | string
    status?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    attachments?: JsonNullableFilter<"Message">
    metadata?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
  }

  export type CannedResponseUpsertWithWhereUniqueWithoutUserInput = {
    where: CannedResponseWhereUniqueInput
    update: XOR<CannedResponseUpdateWithoutUserInput, CannedResponseUncheckedUpdateWithoutUserInput>
    create: XOR<CannedResponseCreateWithoutUserInput, CannedResponseUncheckedCreateWithoutUserInput>
  }

  export type CannedResponseUpdateWithWhereUniqueWithoutUserInput = {
    where: CannedResponseWhereUniqueInput
    data: XOR<CannedResponseUpdateWithoutUserInput, CannedResponseUncheckedUpdateWithoutUserInput>
  }

  export type CannedResponseUpdateManyWithWhereWithoutUserInput = {
    where: CannedResponseScalarWhereInput
    data: XOR<CannedResponseUpdateManyMutationInput, CannedResponseUncheckedUpdateManyWithoutUserInput>
  }

  export type CannedResponseScalarWhereInput = {
    AND?: CannedResponseScalarWhereInput | CannedResponseScalarWhereInput[]
    OR?: CannedResponseScalarWhereInput[]
    NOT?: CannedResponseScalarWhereInput | CannedResponseScalarWhereInput[]
    id?: StringFilter<"CannedResponse"> | string
    userId?: StringFilter<"CannedResponse"> | string
    name?: StringFilter<"CannedResponse"> | string
    content?: StringFilter<"CannedResponse"> | string
    htmlContent?: StringNullableFilter<"CannedResponse"> | string | null
    subject?: StringNullableFilter<"CannedResponse"> | string | null
    category?: StringNullableFilter<"CannedResponse"> | string | null
    tags?: StringNullableListFilter<"CannedResponse">
    channels?: StringNullableListFilter<"CannedResponse">
    variables?: StringNullableListFilter<"CannedResponse">
    useCount?: IntFilter<"CannedResponse"> | number
    createdAt?: DateTimeFilter<"CannedResponse"> | Date | string
    updatedAt?: DateTimeFilter<"CannedResponse"> | Date | string
  }

  export type AutoResponseUpsertWithWhereUniqueWithoutUserInput = {
    where: AutoResponseWhereUniqueInput
    update: XOR<AutoResponseUpdateWithoutUserInput, AutoResponseUncheckedUpdateWithoutUserInput>
    create: XOR<AutoResponseCreateWithoutUserInput, AutoResponseUncheckedCreateWithoutUserInput>
  }

  export type AutoResponseUpdateWithWhereUniqueWithoutUserInput = {
    where: AutoResponseWhereUniqueInput
    data: XOR<AutoResponseUpdateWithoutUserInput, AutoResponseUncheckedUpdateWithoutUserInput>
  }

  export type AutoResponseUpdateManyWithWhereWithoutUserInput = {
    where: AutoResponseScalarWhereInput
    data: XOR<AutoResponseUpdateManyMutationInput, AutoResponseUncheckedUpdateManyWithoutUserInput>
  }

  export type AutoResponseScalarWhereInput = {
    AND?: AutoResponseScalarWhereInput | AutoResponseScalarWhereInput[]
    OR?: AutoResponseScalarWhereInput[]
    NOT?: AutoResponseScalarWhereInput | AutoResponseScalarWhereInput[]
    id?: StringFilter<"AutoResponse"> | string
    userId?: StringFilter<"AutoResponse"> | string
    name?: StringFilter<"AutoResponse"> | string
    description?: StringNullableFilter<"AutoResponse"> | string | null
    enabled?: BoolFilter<"AutoResponse"> | boolean
    triggerType?: StringFilter<"AutoResponse"> | string
    conditions?: JsonFilter<"AutoResponse">
    cannedResponseId?: StringNullableFilter<"AutoResponse"> | string | null
    responseContent?: StringNullableFilter<"AutoResponse"> | string | null
    responseSubject?: StringNullableFilter<"AutoResponse"> | string | null
    channels?: StringNullableListFilter<"AutoResponse">
    priority?: IntFilter<"AutoResponse"> | number
    delaySeconds?: IntFilter<"AutoResponse"> | number
    maxPerDay?: IntNullableFilter<"AutoResponse"> | number | null
    maxPerContact?: IntNullableFilter<"AutoResponse"> | number | null
    triggerCount?: IntFilter<"AutoResponse"> | number
    lastTriggeredAt?: DateTimeNullableFilter<"AutoResponse"> | Date | string | null
    createdAt?: DateTimeFilter<"AutoResponse"> | Date | string
    updatedAt?: DateTimeFilter<"AutoResponse"> | Date | string
  }

  export type ConversationNoteUpsertWithWhereUniqueWithoutUserInput = {
    where: ConversationNoteWhereUniqueInput
    update: XOR<ConversationNoteUpdateWithoutUserInput, ConversationNoteUncheckedUpdateWithoutUserInput>
    create: XOR<ConversationNoteCreateWithoutUserInput, ConversationNoteUncheckedCreateWithoutUserInput>
  }

  export type ConversationNoteUpdateWithWhereUniqueWithoutUserInput = {
    where: ConversationNoteWhereUniqueInput
    data: XOR<ConversationNoteUpdateWithoutUserInput, ConversationNoteUncheckedUpdateWithoutUserInput>
  }

  export type ConversationNoteUpdateManyWithWhereWithoutUserInput = {
    where: ConversationNoteScalarWhereInput
    data: XOR<ConversationNoteUpdateManyMutationInput, ConversationNoteUncheckedUpdateManyWithoutUserInput>
  }

  export type ConversationNoteScalarWhereInput = {
    AND?: ConversationNoteScalarWhereInput | ConversationNoteScalarWhereInput[]
    OR?: ConversationNoteScalarWhereInput[]
    NOT?: ConversationNoteScalarWhereInput | ConversationNoteScalarWhereInput[]
    id?: StringFilter<"ConversationNote"> | string
    conversationId?: StringFilter<"ConversationNote"> | string
    userId?: StringFilter<"ConversationNote"> | string
    content?: StringFilter<"ConversationNote"> | string
    isInternal?: BoolFilter<"ConversationNote"> | boolean
    createdAt?: DateTimeFilter<"ConversationNote"> | Date | string
    updatedAt?: DateTimeFilter<"ConversationNote"> | Date | string
  }

  export type UserCreateWithoutLeadsInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutUserInput
    websites?: WebsiteCreateNestedManyWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    cannedResponses?: CannedResponseCreateNestedManyWithoutUserInput
    autoResponses?: AutoResponseCreateNestedManyWithoutUserInput
    conversationNotes?: ConversationNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLeadsInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    websites?: WebsiteUncheckedCreateNestedManyWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    cannedResponses?: CannedResponseUncheckedCreateNestedManyWithoutUserInput
    autoResponses?: AutoResponseUncheckedCreateNestedManyWithoutUserInput
    conversationNotes?: ConversationNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLeadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeadsInput, UserUncheckedCreateWithoutLeadsInput>
  }

  export type CampaignLeadCreateWithoutLeadInput = {
    id?: string
    status?: string
    sentAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    repliedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutCampaignLeadsInput
  }

  export type CampaignLeadUncheckedCreateWithoutLeadInput = {
    id?: string
    campaignId: string
    status?: string
    sentAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    repliedAt?: Date | string | null
  }

  export type CampaignLeadCreateOrConnectWithoutLeadInput = {
    where: CampaignLeadWhereUniqueInput
    create: XOR<CampaignLeadCreateWithoutLeadInput, CampaignLeadUncheckedCreateWithoutLeadInput>
  }

  export type CampaignLeadCreateManyLeadInputEnvelope = {
    data: CampaignLeadCreateManyLeadInput | CampaignLeadCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type EmailEventCreateWithoutLeadInput = {
    id?: string
    eventType: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutEmailEventsInput
  }

  export type EmailEventUncheckedCreateWithoutLeadInput = {
    id?: string
    campaignId: string
    eventType: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailEventCreateOrConnectWithoutLeadInput = {
    where: EmailEventWhereUniqueInput
    create: XOR<EmailEventCreateWithoutLeadInput, EmailEventUncheckedCreateWithoutLeadInput>
  }

  export type EmailEventCreateManyLeadInputEnvelope = {
    data: EmailEventCreateManyLeadInput | EmailEventCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLeadsInput = {
    update: XOR<UserUpdateWithoutLeadsInput, UserUncheckedUpdateWithoutLeadsInput>
    create: XOR<UserCreateWithoutLeadsInput, UserUncheckedCreateWithoutLeadsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeadsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeadsInput, UserUncheckedUpdateWithoutLeadsInput>
  }

  export type UserUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutUserNestedInput
    websites?: WebsiteUpdateManyWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    cannedResponses?: CannedResponseUpdateManyWithoutUserNestedInput
    autoResponses?: AutoResponseUpdateManyWithoutUserNestedInput
    conversationNotes?: ConversationNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    websites?: WebsiteUncheckedUpdateManyWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    cannedResponses?: CannedResponseUncheckedUpdateManyWithoutUserNestedInput
    autoResponses?: AutoResponseUncheckedUpdateManyWithoutUserNestedInput
    conversationNotes?: ConversationNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CampaignLeadUpsertWithWhereUniqueWithoutLeadInput = {
    where: CampaignLeadWhereUniqueInput
    update: XOR<CampaignLeadUpdateWithoutLeadInput, CampaignLeadUncheckedUpdateWithoutLeadInput>
    create: XOR<CampaignLeadCreateWithoutLeadInput, CampaignLeadUncheckedCreateWithoutLeadInput>
  }

  export type CampaignLeadUpdateWithWhereUniqueWithoutLeadInput = {
    where: CampaignLeadWhereUniqueInput
    data: XOR<CampaignLeadUpdateWithoutLeadInput, CampaignLeadUncheckedUpdateWithoutLeadInput>
  }

  export type CampaignLeadUpdateManyWithWhereWithoutLeadInput = {
    where: CampaignLeadScalarWhereInput
    data: XOR<CampaignLeadUpdateManyMutationInput, CampaignLeadUncheckedUpdateManyWithoutLeadInput>
  }

  export type CampaignLeadScalarWhereInput = {
    AND?: CampaignLeadScalarWhereInput | CampaignLeadScalarWhereInput[]
    OR?: CampaignLeadScalarWhereInput[]
    NOT?: CampaignLeadScalarWhereInput | CampaignLeadScalarWhereInput[]
    id?: StringFilter<"CampaignLead"> | string
    campaignId?: StringFilter<"CampaignLead"> | string
    leadId?: StringFilter<"CampaignLead"> | string
    status?: StringFilter<"CampaignLead"> | string
    sentAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    openedAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    clickedAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    repliedAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
  }

  export type EmailEventUpsertWithWhereUniqueWithoutLeadInput = {
    where: EmailEventWhereUniqueInput
    update: XOR<EmailEventUpdateWithoutLeadInput, EmailEventUncheckedUpdateWithoutLeadInput>
    create: XOR<EmailEventCreateWithoutLeadInput, EmailEventUncheckedCreateWithoutLeadInput>
  }

  export type EmailEventUpdateWithWhereUniqueWithoutLeadInput = {
    where: EmailEventWhereUniqueInput
    data: XOR<EmailEventUpdateWithoutLeadInput, EmailEventUncheckedUpdateWithoutLeadInput>
  }

  export type EmailEventUpdateManyWithWhereWithoutLeadInput = {
    where: EmailEventScalarWhereInput
    data: XOR<EmailEventUpdateManyMutationInput, EmailEventUncheckedUpdateManyWithoutLeadInput>
  }

  export type EmailEventScalarWhereInput = {
    AND?: EmailEventScalarWhereInput | EmailEventScalarWhereInput[]
    OR?: EmailEventScalarWhereInput[]
    NOT?: EmailEventScalarWhereInput | EmailEventScalarWhereInput[]
    id?: StringFilter<"EmailEvent"> | string
    campaignId?: StringFilter<"EmailEvent"> | string
    leadId?: StringFilter<"EmailEvent"> | string
    eventType?: StringFilter<"EmailEvent"> | string
    eventData?: JsonNullableFilter<"EmailEvent">
    createdAt?: DateTimeFilter<"EmailEvent"> | Date | string
  }

  export type UserCreateWithoutCampaignsInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    leads?: LeadCreateNestedManyWithoutUserInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutUserInput
    websites?: WebsiteCreateNestedManyWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    cannedResponses?: CannedResponseCreateNestedManyWithoutUserInput
    autoResponses?: AutoResponseCreateNestedManyWithoutUserInput
    conversationNotes?: ConversationNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCampaignsInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    leads?: LeadUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    websites?: WebsiteUncheckedCreateNestedManyWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    cannedResponses?: CannedResponseUncheckedCreateNestedManyWithoutUserInput
    autoResponses?: AutoResponseUncheckedCreateNestedManyWithoutUserInput
    conversationNotes?: ConversationNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCampaignsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
  }

  export type EmailTemplateCreateWithoutCampaignsInput = {
    id?: string
    name: string
    subject?: string | null
    htmlContent?: string | null
    textContent?: string | null
    variables?: EmailTemplateCreatevariablesInput | string[]
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmailTemplatesInput
  }

  export type EmailTemplateUncheckedCreateWithoutCampaignsInput = {
    id?: string
    userId: string
    name: string
    subject?: string | null
    htmlContent?: string | null
    textContent?: string | null
    variables?: EmailTemplateCreatevariablesInput | string[]
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateCreateOrConnectWithoutCampaignsInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutCampaignsInput, EmailTemplateUncheckedCreateWithoutCampaignsInput>
  }

  export type CampaignLeadCreateWithoutCampaignInput = {
    id?: string
    status?: string
    sentAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    repliedAt?: Date | string | null
    lead: LeadCreateNestedOneWithoutCampaignLeadsInput
  }

  export type CampaignLeadUncheckedCreateWithoutCampaignInput = {
    id?: string
    leadId: string
    status?: string
    sentAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    repliedAt?: Date | string | null
  }

  export type CampaignLeadCreateOrConnectWithoutCampaignInput = {
    where: CampaignLeadWhereUniqueInput
    create: XOR<CampaignLeadCreateWithoutCampaignInput, CampaignLeadUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignLeadCreateManyCampaignInputEnvelope = {
    data: CampaignLeadCreateManyCampaignInput | CampaignLeadCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type EmailEventCreateWithoutCampaignInput = {
    id?: string
    eventType: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lead: LeadCreateNestedOneWithoutEmailEventsInput
  }

  export type EmailEventUncheckedCreateWithoutCampaignInput = {
    id?: string
    leadId: string
    eventType: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmailEventCreateOrConnectWithoutCampaignInput = {
    where: EmailEventWhereUniqueInput
    create: XOR<EmailEventCreateWithoutCampaignInput, EmailEventUncheckedCreateWithoutCampaignInput>
  }

  export type EmailEventCreateManyCampaignInputEnvelope = {
    data: EmailEventCreateManyCampaignInput | EmailEventCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCampaignsInput = {
    update: XOR<UserUpdateWithoutCampaignsInput, UserUncheckedUpdateWithoutCampaignsInput>
    create: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCampaignsInput, UserUncheckedUpdateWithoutCampaignsInput>
  }

  export type UserUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUpdateManyWithoutUserNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutUserNestedInput
    websites?: WebsiteUpdateManyWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    cannedResponses?: CannedResponseUpdateManyWithoutUserNestedInput
    autoResponses?: AutoResponseUpdateManyWithoutUserNestedInput
    conversationNotes?: ConversationNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    websites?: WebsiteUncheckedUpdateManyWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    cannedResponses?: CannedResponseUncheckedUpdateManyWithoutUserNestedInput
    autoResponses?: AutoResponseUncheckedUpdateManyWithoutUserNestedInput
    conversationNotes?: ConversationNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmailTemplateUpsertWithoutCampaignsInput = {
    update: XOR<EmailTemplateUpdateWithoutCampaignsInput, EmailTemplateUncheckedUpdateWithoutCampaignsInput>
    create: XOR<EmailTemplateCreateWithoutCampaignsInput, EmailTemplateUncheckedCreateWithoutCampaignsInput>
    where?: EmailTemplateWhereInput
  }

  export type EmailTemplateUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: EmailTemplateWhereInput
    data: XOR<EmailTemplateUpdateWithoutCampaignsInput, EmailTemplateUncheckedUpdateWithoutCampaignsInput>
  }

  export type EmailTemplateUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailTemplatesNestedInput
  }

  export type EmailTemplateUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignLeadUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignLeadWhereUniqueInput
    update: XOR<CampaignLeadUpdateWithoutCampaignInput, CampaignLeadUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignLeadCreateWithoutCampaignInput, CampaignLeadUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignLeadUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignLeadWhereUniqueInput
    data: XOR<CampaignLeadUpdateWithoutCampaignInput, CampaignLeadUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignLeadUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignLeadScalarWhereInput
    data: XOR<CampaignLeadUpdateManyMutationInput, CampaignLeadUncheckedUpdateManyWithoutCampaignInput>
  }

  export type EmailEventUpsertWithWhereUniqueWithoutCampaignInput = {
    where: EmailEventWhereUniqueInput
    update: XOR<EmailEventUpdateWithoutCampaignInput, EmailEventUncheckedUpdateWithoutCampaignInput>
    create: XOR<EmailEventCreateWithoutCampaignInput, EmailEventUncheckedCreateWithoutCampaignInput>
  }

  export type EmailEventUpdateWithWhereUniqueWithoutCampaignInput = {
    where: EmailEventWhereUniqueInput
    data: XOR<EmailEventUpdateWithoutCampaignInput, EmailEventUncheckedUpdateWithoutCampaignInput>
  }

  export type EmailEventUpdateManyWithWhereWithoutCampaignInput = {
    where: EmailEventScalarWhereInput
    data: XOR<EmailEventUpdateManyMutationInput, EmailEventUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignCreateWithoutCampaignLeadsInput = {
    id?: string
    name: string
    description?: string | null
    type?: string
    status?: string
    subject?: string | null
    fromName?: string | null
    fromEmail?: string | null
    replyTo?: string | null
    htmlContent?: string | null
    textContent?: string | null
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    totalLeads?: number
    sentCount?: number
    openCount?: number
    clickCount?: number
    replyCount?: number
    bounceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignsInput
    template?: EmailTemplateCreateNestedOneWithoutCampaignsInput
    emailEvents?: EmailEventCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCampaignLeadsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    type?: string
    status?: string
    subject?: string | null
    fromName?: string | null
    fromEmail?: string | null
    replyTo?: string | null
    templateId?: string | null
    htmlContent?: string | null
    textContent?: string | null
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    totalLeads?: number
    sentCount?: number
    openCount?: number
    clickCount?: number
    replyCount?: number
    bounceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailEvents?: EmailEventUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCampaignLeadsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCampaignLeadsInput, CampaignUncheckedCreateWithoutCampaignLeadsInput>
  }

  export type LeadCreateWithoutCampaignLeadsInput = {
    id?: string
    email: string
    name?: string | null
    company?: string | null
    phone?: string | null
    title?: string | null
    website?: string | null
    linkedinUrl?: string | null
    source?: string | null
    status?: string
    score?: number | null
    notes?: string | null
    tags?: LeadCreatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastContactedAt?: Date | string | null
    user: UserCreateNestedOneWithoutLeadsInput
    emailEvents?: EmailEventCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutCampaignLeadsInput = {
    id?: string
    userId: string
    email: string
    name?: string | null
    company?: string | null
    phone?: string | null
    title?: string | null
    website?: string | null
    linkedinUrl?: string | null
    source?: string | null
    status?: string
    score?: number | null
    notes?: string | null
    tags?: LeadCreatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastContactedAt?: Date | string | null
    emailEvents?: EmailEventUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutCampaignLeadsInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutCampaignLeadsInput, LeadUncheckedCreateWithoutCampaignLeadsInput>
  }

  export type CampaignUpsertWithoutCampaignLeadsInput = {
    update: XOR<CampaignUpdateWithoutCampaignLeadsInput, CampaignUncheckedUpdateWithoutCampaignLeadsInput>
    create: XOR<CampaignCreateWithoutCampaignLeadsInput, CampaignUncheckedCreateWithoutCampaignLeadsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutCampaignLeadsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutCampaignLeadsInput, CampaignUncheckedUpdateWithoutCampaignLeadsInput>
  }

  export type CampaignUpdateWithoutCampaignLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    template?: EmailTemplateUpdateOneWithoutCampaignsNestedInput
    emailEvents?: EmailEventUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCampaignLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailEvents?: EmailEventUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type LeadUpsertWithoutCampaignLeadsInput = {
    update: XOR<LeadUpdateWithoutCampaignLeadsInput, LeadUncheckedUpdateWithoutCampaignLeadsInput>
    create: XOR<LeadCreateWithoutCampaignLeadsInput, LeadUncheckedCreateWithoutCampaignLeadsInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutCampaignLeadsInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutCampaignLeadsInput, LeadUncheckedUpdateWithoutCampaignLeadsInput>
  }

  export type LeadUpdateWithoutCampaignLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LeadUpdatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutLeadsNestedInput
    emailEvents?: EmailEventUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutCampaignLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LeadUpdatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailEvents?: EmailEventUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type UserCreateWithoutEmailTemplatesInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    leads?: LeadCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    websites?: WebsiteCreateNestedManyWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    cannedResponses?: CannedResponseCreateNestedManyWithoutUserInput
    autoResponses?: AutoResponseCreateNestedManyWithoutUserInput
    conversationNotes?: ConversationNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailTemplatesInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    leads?: LeadUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    websites?: WebsiteUncheckedCreateNestedManyWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    cannedResponses?: CannedResponseUncheckedCreateNestedManyWithoutUserInput
    autoResponses?: AutoResponseUncheckedCreateNestedManyWithoutUserInput
    conversationNotes?: ConversationNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailTemplatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailTemplatesInput, UserUncheckedCreateWithoutEmailTemplatesInput>
  }

  export type CampaignCreateWithoutTemplateInput = {
    id?: string
    name: string
    description?: string | null
    type?: string
    status?: string
    subject?: string | null
    fromName?: string | null
    fromEmail?: string | null
    replyTo?: string | null
    htmlContent?: string | null
    textContent?: string | null
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    totalLeads?: number
    sentCount?: number
    openCount?: number
    clickCount?: number
    replyCount?: number
    bounceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignsInput
    campaignLeads?: CampaignLeadCreateNestedManyWithoutCampaignInput
    emailEvents?: EmailEventCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutTemplateInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    type?: string
    status?: string
    subject?: string | null
    fromName?: string | null
    fromEmail?: string | null
    replyTo?: string | null
    htmlContent?: string | null
    textContent?: string | null
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    totalLeads?: number
    sentCount?: number
    openCount?: number
    clickCount?: number
    replyCount?: number
    bounceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignLeads?: CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput
    emailEvents?: EmailEventUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutTemplateInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutTemplateInput, CampaignUncheckedCreateWithoutTemplateInput>
  }

  export type CampaignCreateManyTemplateInputEnvelope = {
    data: CampaignCreateManyTemplateInput | CampaignCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEmailTemplatesInput = {
    update: XOR<UserUpdateWithoutEmailTemplatesInput, UserUncheckedUpdateWithoutEmailTemplatesInput>
    create: XOR<UserCreateWithoutEmailTemplatesInput, UserUncheckedCreateWithoutEmailTemplatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailTemplatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailTemplatesInput, UserUncheckedUpdateWithoutEmailTemplatesInput>
  }

  export type UserUpdateWithoutEmailTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    websites?: WebsiteUpdateManyWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    cannedResponses?: CannedResponseUpdateManyWithoutUserNestedInput
    autoResponses?: AutoResponseUpdateManyWithoutUserNestedInput
    conversationNotes?: ConversationNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    websites?: WebsiteUncheckedUpdateManyWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    cannedResponses?: CannedResponseUncheckedUpdateManyWithoutUserNestedInput
    autoResponses?: AutoResponseUncheckedUpdateManyWithoutUserNestedInput
    conversationNotes?: ConversationNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CampaignUpsertWithWhereUniqueWithoutTemplateInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutTemplateInput, CampaignUncheckedUpdateWithoutTemplateInput>
    create: XOR<CampaignCreateWithoutTemplateInput, CampaignUncheckedCreateWithoutTemplateInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutTemplateInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutTemplateInput, CampaignUncheckedUpdateWithoutTemplateInput>
  }

  export type CampaignUpdateManyWithWhereWithoutTemplateInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutTemplateInput>
  }

  export type CampaignCreateWithoutEmailEventsInput = {
    id?: string
    name: string
    description?: string | null
    type?: string
    status?: string
    subject?: string | null
    fromName?: string | null
    fromEmail?: string | null
    replyTo?: string | null
    htmlContent?: string | null
    textContent?: string | null
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    totalLeads?: number
    sentCount?: number
    openCount?: number
    clickCount?: number
    replyCount?: number
    bounceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignsInput
    template?: EmailTemplateCreateNestedOneWithoutCampaignsInput
    campaignLeads?: CampaignLeadCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutEmailEventsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    type?: string
    status?: string
    subject?: string | null
    fromName?: string | null
    fromEmail?: string | null
    replyTo?: string | null
    templateId?: string | null
    htmlContent?: string | null
    textContent?: string | null
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    totalLeads?: number
    sentCount?: number
    openCount?: number
    clickCount?: number
    replyCount?: number
    bounceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignLeads?: CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutEmailEventsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutEmailEventsInput, CampaignUncheckedCreateWithoutEmailEventsInput>
  }

  export type LeadCreateWithoutEmailEventsInput = {
    id?: string
    email: string
    name?: string | null
    company?: string | null
    phone?: string | null
    title?: string | null
    website?: string | null
    linkedinUrl?: string | null
    source?: string | null
    status?: string
    score?: number | null
    notes?: string | null
    tags?: LeadCreatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastContactedAt?: Date | string | null
    user: UserCreateNestedOneWithoutLeadsInput
    campaignLeads?: CampaignLeadCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutEmailEventsInput = {
    id?: string
    userId: string
    email: string
    name?: string | null
    company?: string | null
    phone?: string | null
    title?: string | null
    website?: string | null
    linkedinUrl?: string | null
    source?: string | null
    status?: string
    score?: number | null
    notes?: string | null
    tags?: LeadCreatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastContactedAt?: Date | string | null
    campaignLeads?: CampaignLeadUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutEmailEventsInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutEmailEventsInput, LeadUncheckedCreateWithoutEmailEventsInput>
  }

  export type CampaignUpsertWithoutEmailEventsInput = {
    update: XOR<CampaignUpdateWithoutEmailEventsInput, CampaignUncheckedUpdateWithoutEmailEventsInput>
    create: XOR<CampaignCreateWithoutEmailEventsInput, CampaignUncheckedCreateWithoutEmailEventsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutEmailEventsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutEmailEventsInput, CampaignUncheckedUpdateWithoutEmailEventsInput>
  }

  export type CampaignUpdateWithoutEmailEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    template?: EmailTemplateUpdateOneWithoutCampaignsNestedInput
    campaignLeads?: CampaignLeadUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutEmailEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignLeads?: CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type LeadUpsertWithoutEmailEventsInput = {
    update: XOR<LeadUpdateWithoutEmailEventsInput, LeadUncheckedUpdateWithoutEmailEventsInput>
    create: XOR<LeadCreateWithoutEmailEventsInput, LeadUncheckedCreateWithoutEmailEventsInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutEmailEventsInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutEmailEventsInput, LeadUncheckedUpdateWithoutEmailEventsInput>
  }

  export type LeadUpdateWithoutEmailEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LeadUpdatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutLeadsNestedInput
    campaignLeads?: CampaignLeadUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutEmailEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LeadUpdatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaignLeads?: CampaignLeadUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type UserCreateWithoutWebsitesInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    leads?: LeadCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    cannedResponses?: CannedResponseCreateNestedManyWithoutUserInput
    autoResponses?: AutoResponseCreateNestedManyWithoutUserInput
    conversationNotes?: ConversationNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWebsitesInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    leads?: LeadUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    cannedResponses?: CannedResponseUncheckedCreateNestedManyWithoutUserInput
    autoResponses?: AutoResponseUncheckedCreateNestedManyWithoutUserInput
    conversationNotes?: ConversationNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWebsitesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWebsitesInput, UserUncheckedCreateWithoutWebsitesInput>
  }

  export type UserUpsertWithoutWebsitesInput = {
    update: XOR<UserUpdateWithoutWebsitesInput, UserUncheckedUpdateWithoutWebsitesInput>
    create: XOR<UserCreateWithoutWebsitesInput, UserUncheckedCreateWithoutWebsitesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWebsitesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWebsitesInput, UserUncheckedUpdateWithoutWebsitesInput>
  }

  export type UserUpdateWithoutWebsitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    cannedResponses?: CannedResponseUpdateManyWithoutUserNestedInput
    autoResponses?: AutoResponseUpdateManyWithoutUserNestedInput
    conversationNotes?: ConversationNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWebsitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    cannedResponses?: CannedResponseUncheckedUpdateManyWithoutUserNestedInput
    autoResponses?: AutoResponseUncheckedUpdateManyWithoutUserNestedInput
    conversationNotes?: ConversationNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutVideosInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    leads?: LeadCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutUserInput
    websites?: WebsiteCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    cannedResponses?: CannedResponseCreateNestedManyWithoutUserInput
    autoResponses?: AutoResponseCreateNestedManyWithoutUserInput
    conversationNotes?: ConversationNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVideosInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    leads?: LeadUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    websites?: WebsiteUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    cannedResponses?: CannedResponseUncheckedCreateNestedManyWithoutUserInput
    autoResponses?: AutoResponseUncheckedCreateNestedManyWithoutUserInput
    conversationNotes?: ConversationNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVideosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVideosInput, UserUncheckedCreateWithoutVideosInput>
  }

  export type UserUpsertWithoutVideosInput = {
    update: XOR<UserUpdateWithoutVideosInput, UserUncheckedUpdateWithoutVideosInput>
    create: XOR<UserCreateWithoutVideosInput, UserUncheckedCreateWithoutVideosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVideosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVideosInput, UserUncheckedUpdateWithoutVideosInput>
  }

  export type UserUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutUserNestedInput
    websites?: WebsiteUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    cannedResponses?: CannedResponseUpdateManyWithoutUserNestedInput
    autoResponses?: AutoResponseUpdateManyWithoutUserNestedInput
    conversationNotes?: ConversationNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    websites?: WebsiteUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    cannedResponses?: CannedResponseUncheckedUpdateManyWithoutUserNestedInput
    autoResponses?: AutoResponseUncheckedUpdateManyWithoutUserNestedInput
    conversationNotes?: ConversationNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutApiKeysInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    leads?: LeadCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutUserInput
    websites?: WebsiteCreateNestedManyWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    cannedResponses?: CannedResponseCreateNestedManyWithoutUserInput
    autoResponses?: AutoResponseCreateNestedManyWithoutUserInput
    conversationNotes?: ConversationNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApiKeysInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    leads?: LeadUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    websites?: WebsiteUncheckedCreateNestedManyWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    cannedResponses?: CannedResponseUncheckedCreateNestedManyWithoutUserInput
    autoResponses?: AutoResponseUncheckedCreateNestedManyWithoutUserInput
    conversationNotes?: ConversationNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApiKeysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
  }

  export type UserUpsertWithoutApiKeysInput = {
    update: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type UserUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutUserNestedInput
    websites?: WebsiteUpdateManyWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    cannedResponses?: CannedResponseUpdateManyWithoutUserNestedInput
    autoResponses?: AutoResponseUpdateManyWithoutUserNestedInput
    conversationNotes?: ConversationNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    websites?: WebsiteUncheckedUpdateManyWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    cannedResponses?: CannedResponseUncheckedUpdateManyWithoutUserNestedInput
    autoResponses?: AutoResponseUncheckedUpdateManyWithoutUserNestedInput
    conversationNotes?: ConversationNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutConversationsInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    leads?: LeadCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutUserInput
    websites?: WebsiteCreateNestedManyWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    cannedResponses?: CannedResponseCreateNestedManyWithoutUserInput
    autoResponses?: AutoResponseCreateNestedManyWithoutUserInput
    conversationNotes?: ConversationNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConversationsInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    leads?: LeadUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    websites?: WebsiteUncheckedCreateNestedManyWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    cannedResponses?: CannedResponseUncheckedCreateNestedManyWithoutUserInput
    autoResponses?: AutoResponseUncheckedCreateNestedManyWithoutUserInput
    conversationNotes?: ConversationNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    content: string
    htmlContent?: string | null
    subject?: string | null
    channel: string
    channelMessageId?: string | null
    direction?: string
    status?: string
    isRead?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
    user: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    userId: string
    content: string
    htmlContent?: string | null
    subject?: string | null
    channel: string
    channelMessageId?: string | null
    direction?: string
    status?: string
    isRead?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type ConversationNoteCreateWithoutConversationInput = {
    id?: string
    content: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConversationNotesInput
  }

  export type ConversationNoteUncheckedCreateWithoutConversationInput = {
    id?: string
    userId: string
    content: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationNoteCreateOrConnectWithoutConversationInput = {
    where: ConversationNoteWhereUniqueInput
    create: XOR<ConversationNoteCreateWithoutConversationInput, ConversationNoteUncheckedCreateWithoutConversationInput>
  }

  export type ConversationNoteCreateManyConversationInputEnvelope = {
    data: ConversationNoteCreateManyConversationInput | ConversationNoteCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutConversationsInput = {
    update: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutUserNestedInput
    websites?: WebsiteUpdateManyWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    cannedResponses?: CannedResponseUpdateManyWithoutUserNestedInput
    autoResponses?: AutoResponseUpdateManyWithoutUserNestedInput
    conversationNotes?: ConversationNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    websites?: WebsiteUncheckedUpdateManyWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    cannedResponses?: CannedResponseUncheckedUpdateManyWithoutUserNestedInput
    autoResponses?: AutoResponseUncheckedUpdateManyWithoutUserNestedInput
    conversationNotes?: ConversationNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationNoteUpsertWithWhereUniqueWithoutConversationInput = {
    where: ConversationNoteWhereUniqueInput
    update: XOR<ConversationNoteUpdateWithoutConversationInput, ConversationNoteUncheckedUpdateWithoutConversationInput>
    create: XOR<ConversationNoteCreateWithoutConversationInput, ConversationNoteUncheckedCreateWithoutConversationInput>
  }

  export type ConversationNoteUpdateWithWhereUniqueWithoutConversationInput = {
    where: ConversationNoteWhereUniqueInput
    data: XOR<ConversationNoteUpdateWithoutConversationInput, ConversationNoteUncheckedUpdateWithoutConversationInput>
  }

  export type ConversationNoteUpdateManyWithWhereWithoutConversationInput = {
    where: ConversationNoteScalarWhereInput
    data: XOR<ConversationNoteUpdateManyMutationInput, ConversationNoteUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    contactId?: string | null
    channel: string
    channelId?: string | null
    subject?: string | null
    status?: string
    priority?: string
    assignedTo?: string | null
    tags?: ConversationCreatetagsInput | string[]
    labels?: ConversationCreatelabelsInput | string[]
    messageCount?: number
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string | null
    closedAt?: Date | string | null
    user: UserCreateNestedOneWithoutConversationsInput
    notes?: ConversationNoteCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    contactId?: string | null
    channel: string
    channelId?: string | null
    subject?: string | null
    status?: string
    priority?: string
    assignedTo?: string | null
    tags?: ConversationCreatetagsInput | string[]
    labels?: ConversationCreatelabelsInput | string[]
    messageCount?: number
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string | null
    closedAt?: Date | string | null
    notes?: ConversationNoteUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMessagesInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    leads?: LeadCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutUserInput
    websites?: WebsiteCreateNestedManyWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    cannedResponses?: CannedResponseCreateNestedManyWithoutUserInput
    autoResponses?: AutoResponseCreateNestedManyWithoutUserInput
    conversationNotes?: ConversationNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessagesInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    leads?: LeadUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    websites?: WebsiteUncheckedCreateNestedManyWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    cannedResponses?: CannedResponseUncheckedCreateNestedManyWithoutUserInput
    autoResponses?: AutoResponseUncheckedCreateNestedManyWithoutUserInput
    conversationNotes?: ConversationNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ConversationUpdatetagsInput | string[]
    labels?: ConversationUpdatelabelsInput | string[]
    messageCount?: IntFieldUpdateOperationsInput | number
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    notes?: ConversationNoteUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ConversationUpdatetagsInput | string[]
    labels?: ConversationUpdatelabelsInput | string[]
    messageCount?: IntFieldUpdateOperationsInput | number
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: ConversationNoteUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutUserNestedInput
    websites?: WebsiteUpdateManyWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    cannedResponses?: CannedResponseUpdateManyWithoutUserNestedInput
    autoResponses?: AutoResponseUpdateManyWithoutUserNestedInput
    conversationNotes?: ConversationNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    websites?: WebsiteUncheckedUpdateManyWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    cannedResponses?: CannedResponseUncheckedUpdateManyWithoutUserNestedInput
    autoResponses?: AutoResponseUncheckedUpdateManyWithoutUserNestedInput
    conversationNotes?: ConversationNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCannedResponsesInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    leads?: LeadCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutUserInput
    websites?: WebsiteCreateNestedManyWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    autoResponses?: AutoResponseCreateNestedManyWithoutUserInput
    conversationNotes?: ConversationNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCannedResponsesInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    leads?: LeadUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    websites?: WebsiteUncheckedCreateNestedManyWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    autoResponses?: AutoResponseUncheckedCreateNestedManyWithoutUserInput
    conversationNotes?: ConversationNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCannedResponsesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCannedResponsesInput, UserUncheckedCreateWithoutCannedResponsesInput>
  }

  export type AutoResponseCreateWithoutCannedResponseInput = {
    id?: string
    name: string
    description?: string | null
    enabled?: boolean
    triggerType: string
    conditions: JsonNullValueInput | InputJsonValue
    responseContent?: string | null
    responseSubject?: string | null
    channels?: AutoResponseCreatechannelsInput | string[]
    priority?: number
    delaySeconds?: number
    maxPerDay?: number | null
    maxPerContact?: number | null
    triggerCount?: number
    lastTriggeredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAutoResponsesInput
  }

  export type AutoResponseUncheckedCreateWithoutCannedResponseInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    enabled?: boolean
    triggerType: string
    conditions: JsonNullValueInput | InputJsonValue
    responseContent?: string | null
    responseSubject?: string | null
    channels?: AutoResponseCreatechannelsInput | string[]
    priority?: number
    delaySeconds?: number
    maxPerDay?: number | null
    maxPerContact?: number | null
    triggerCount?: number
    lastTriggeredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutoResponseCreateOrConnectWithoutCannedResponseInput = {
    where: AutoResponseWhereUniqueInput
    create: XOR<AutoResponseCreateWithoutCannedResponseInput, AutoResponseUncheckedCreateWithoutCannedResponseInput>
  }

  export type AutoResponseCreateManyCannedResponseInputEnvelope = {
    data: AutoResponseCreateManyCannedResponseInput | AutoResponseCreateManyCannedResponseInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCannedResponsesInput = {
    update: XOR<UserUpdateWithoutCannedResponsesInput, UserUncheckedUpdateWithoutCannedResponsesInput>
    create: XOR<UserCreateWithoutCannedResponsesInput, UserUncheckedCreateWithoutCannedResponsesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCannedResponsesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCannedResponsesInput, UserUncheckedUpdateWithoutCannedResponsesInput>
  }

  export type UserUpdateWithoutCannedResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutUserNestedInput
    websites?: WebsiteUpdateManyWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    autoResponses?: AutoResponseUpdateManyWithoutUserNestedInput
    conversationNotes?: ConversationNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCannedResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    websites?: WebsiteUncheckedUpdateManyWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    autoResponses?: AutoResponseUncheckedUpdateManyWithoutUserNestedInput
    conversationNotes?: ConversationNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AutoResponseUpsertWithWhereUniqueWithoutCannedResponseInput = {
    where: AutoResponseWhereUniqueInput
    update: XOR<AutoResponseUpdateWithoutCannedResponseInput, AutoResponseUncheckedUpdateWithoutCannedResponseInput>
    create: XOR<AutoResponseCreateWithoutCannedResponseInput, AutoResponseUncheckedCreateWithoutCannedResponseInput>
  }

  export type AutoResponseUpdateWithWhereUniqueWithoutCannedResponseInput = {
    where: AutoResponseWhereUniqueInput
    data: XOR<AutoResponseUpdateWithoutCannedResponseInput, AutoResponseUncheckedUpdateWithoutCannedResponseInput>
  }

  export type AutoResponseUpdateManyWithWhereWithoutCannedResponseInput = {
    where: AutoResponseScalarWhereInput
    data: XOR<AutoResponseUpdateManyMutationInput, AutoResponseUncheckedUpdateManyWithoutCannedResponseInput>
  }

  export type UserCreateWithoutAutoResponsesInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    leads?: LeadCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutUserInput
    websites?: WebsiteCreateNestedManyWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    cannedResponses?: CannedResponseCreateNestedManyWithoutUserInput
    conversationNotes?: ConversationNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAutoResponsesInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    leads?: LeadUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    websites?: WebsiteUncheckedCreateNestedManyWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    cannedResponses?: CannedResponseUncheckedCreateNestedManyWithoutUserInput
    conversationNotes?: ConversationNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAutoResponsesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAutoResponsesInput, UserUncheckedCreateWithoutAutoResponsesInput>
  }

  export type CannedResponseCreateWithoutAutoResponseInput = {
    id?: string
    name: string
    content: string
    htmlContent?: string | null
    subject?: string | null
    category?: string | null
    tags?: CannedResponseCreatetagsInput | string[]
    channels?: CannedResponseCreatechannelsInput | string[]
    variables?: CannedResponseCreatevariablesInput | string[]
    useCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCannedResponsesInput
  }

  export type CannedResponseUncheckedCreateWithoutAutoResponseInput = {
    id?: string
    userId: string
    name: string
    content: string
    htmlContent?: string | null
    subject?: string | null
    category?: string | null
    tags?: CannedResponseCreatetagsInput | string[]
    channels?: CannedResponseCreatechannelsInput | string[]
    variables?: CannedResponseCreatevariablesInput | string[]
    useCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CannedResponseCreateOrConnectWithoutAutoResponseInput = {
    where: CannedResponseWhereUniqueInput
    create: XOR<CannedResponseCreateWithoutAutoResponseInput, CannedResponseUncheckedCreateWithoutAutoResponseInput>
  }

  export type UserUpsertWithoutAutoResponsesInput = {
    update: XOR<UserUpdateWithoutAutoResponsesInput, UserUncheckedUpdateWithoutAutoResponsesInput>
    create: XOR<UserCreateWithoutAutoResponsesInput, UserUncheckedCreateWithoutAutoResponsesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAutoResponsesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAutoResponsesInput, UserUncheckedUpdateWithoutAutoResponsesInput>
  }

  export type UserUpdateWithoutAutoResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutUserNestedInput
    websites?: WebsiteUpdateManyWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    cannedResponses?: CannedResponseUpdateManyWithoutUserNestedInput
    conversationNotes?: ConversationNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAutoResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    websites?: WebsiteUncheckedUpdateManyWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    cannedResponses?: CannedResponseUncheckedUpdateManyWithoutUserNestedInput
    conversationNotes?: ConversationNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CannedResponseUpsertWithoutAutoResponseInput = {
    update: XOR<CannedResponseUpdateWithoutAutoResponseInput, CannedResponseUncheckedUpdateWithoutAutoResponseInput>
    create: XOR<CannedResponseCreateWithoutAutoResponseInput, CannedResponseUncheckedCreateWithoutAutoResponseInput>
    where?: CannedResponseWhereInput
  }

  export type CannedResponseUpdateToOneWithWhereWithoutAutoResponseInput = {
    where?: CannedResponseWhereInput
    data: XOR<CannedResponseUpdateWithoutAutoResponseInput, CannedResponseUncheckedUpdateWithoutAutoResponseInput>
  }

  export type CannedResponseUpdateWithoutAutoResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CannedResponseUpdatetagsInput | string[]
    channels?: CannedResponseUpdatechannelsInput | string[]
    variables?: CannedResponseUpdatevariablesInput | string[]
    useCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCannedResponsesNestedInput
  }

  export type CannedResponseUncheckedUpdateWithoutAutoResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CannedResponseUpdatetagsInput | string[]
    channels?: CannedResponseUpdatechannelsInput | string[]
    variables?: CannedResponseUpdatevariablesInput | string[]
    useCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateWithoutNotesInput = {
    id?: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    contactId?: string | null
    channel: string
    channelId?: string | null
    subject?: string | null
    status?: string
    priority?: string
    assignedTo?: string | null
    tags?: ConversationCreatetagsInput | string[]
    labels?: ConversationCreatelabelsInput | string[]
    messageCount?: number
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string | null
    closedAt?: Date | string | null
    user: UserCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutNotesInput = {
    id?: string
    userId: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    contactId?: string | null
    channel: string
    channelId?: string | null
    subject?: string | null
    status?: string
    priority?: string
    assignedTo?: string | null
    tags?: ConversationCreatetagsInput | string[]
    labels?: ConversationCreatelabelsInput | string[]
    messageCount?: number
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string | null
    closedAt?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutNotesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutNotesInput, ConversationUncheckedCreateWithoutNotesInput>
  }

  export type UserCreateWithoutConversationNotesInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    leads?: LeadCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    emailTemplates?: EmailTemplateCreateNestedManyWithoutUserInput
    websites?: WebsiteCreateNestedManyWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    cannedResponses?: CannedResponseCreateNestedManyWithoutUserInput
    autoResponses?: AutoResponseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConversationNotesInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    company?: string | null
    tier?: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    leads?: LeadUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    emailTemplates?: EmailTemplateUncheckedCreateNestedManyWithoutUserInput
    websites?: WebsiteUncheckedCreateNestedManyWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    cannedResponses?: CannedResponseUncheckedCreateNestedManyWithoutUserInput
    autoResponses?: AutoResponseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConversationNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationNotesInput, UserUncheckedCreateWithoutConversationNotesInput>
  }

  export type ConversationUpsertWithoutNotesInput = {
    update: XOR<ConversationUpdateWithoutNotesInput, ConversationUncheckedUpdateWithoutNotesInput>
    create: XOR<ConversationCreateWithoutNotesInput, ConversationUncheckedCreateWithoutNotesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutNotesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutNotesInput, ConversationUncheckedUpdateWithoutNotesInput>
  }

  export type ConversationUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ConversationUpdatetagsInput | string[]
    labels?: ConversationUpdatelabelsInput | string[]
    messageCount?: IntFieldUpdateOperationsInput | number
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ConversationUpdatetagsInput | string[]
    labels?: ConversationUpdatelabelsInput | string[]
    messageCount?: IntFieldUpdateOperationsInput | number
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type UserUpsertWithoutConversationNotesInput = {
    update: XOR<UserUpdateWithoutConversationNotesInput, UserUncheckedUpdateWithoutConversationNotesInput>
    create: XOR<UserCreateWithoutConversationNotesInput, UserUncheckedCreateWithoutConversationNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversationNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversationNotesInput, UserUncheckedUpdateWithoutConversationNotesInput>
  }

  export type UserUpdateWithoutConversationNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    emailTemplates?: EmailTemplateUpdateManyWithoutUserNestedInput
    websites?: WebsiteUpdateManyWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    cannedResponses?: CannedResponseUpdateManyWithoutUserNestedInput
    autoResponses?: AutoResponseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leads?: LeadUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    emailTemplates?: EmailTemplateUncheckedUpdateManyWithoutUserNestedInput
    websites?: WebsiteUncheckedUpdateManyWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    cannedResponses?: CannedResponseUncheckedUpdateManyWithoutUserNestedInput
    autoResponses?: AutoResponseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RepairHistoryCreateWithoutDiagnosticInput = {
    id?: string
    repairType: string
    fixApplied?: string | null
    fixCode?: string | null
    success: boolean
    timeToFixSeconds?: number | null
    verificationResult?: NullableJsonNullValueInput | InputJsonValue
    rollbackPlan?: string | null
    createdAt?: Date | string
  }

  export type RepairHistoryUncheckedCreateWithoutDiagnosticInput = {
    id?: string
    repairType: string
    fixApplied?: string | null
    fixCode?: string | null
    success: boolean
    timeToFixSeconds?: number | null
    verificationResult?: NullableJsonNullValueInput | InputJsonValue
    rollbackPlan?: string | null
    createdAt?: Date | string
  }

  export type RepairHistoryCreateOrConnectWithoutDiagnosticInput = {
    where: RepairHistoryWhereUniqueInput
    create: XOR<RepairHistoryCreateWithoutDiagnosticInput, RepairHistoryUncheckedCreateWithoutDiagnosticInput>
  }

  export type RepairHistoryCreateManyDiagnosticInputEnvelope = {
    data: RepairHistoryCreateManyDiagnosticInput | RepairHistoryCreateManyDiagnosticInput[]
    skipDuplicates?: boolean
  }

  export type RepairHistoryUpsertWithWhereUniqueWithoutDiagnosticInput = {
    where: RepairHistoryWhereUniqueInput
    update: XOR<RepairHistoryUpdateWithoutDiagnosticInput, RepairHistoryUncheckedUpdateWithoutDiagnosticInput>
    create: XOR<RepairHistoryCreateWithoutDiagnosticInput, RepairHistoryUncheckedCreateWithoutDiagnosticInput>
  }

  export type RepairHistoryUpdateWithWhereUniqueWithoutDiagnosticInput = {
    where: RepairHistoryWhereUniqueInput
    data: XOR<RepairHistoryUpdateWithoutDiagnosticInput, RepairHistoryUncheckedUpdateWithoutDiagnosticInput>
  }

  export type RepairHistoryUpdateManyWithWhereWithoutDiagnosticInput = {
    where: RepairHistoryScalarWhereInput
    data: XOR<RepairHistoryUpdateManyMutationInput, RepairHistoryUncheckedUpdateManyWithoutDiagnosticInput>
  }

  export type RepairHistoryScalarWhereInput = {
    AND?: RepairHistoryScalarWhereInput | RepairHistoryScalarWhereInput[]
    OR?: RepairHistoryScalarWhereInput[]
    NOT?: RepairHistoryScalarWhereInput | RepairHistoryScalarWhereInput[]
    id?: StringFilter<"RepairHistory"> | string
    diagnosticId?: StringNullableFilter<"RepairHistory"> | string | null
    repairType?: StringFilter<"RepairHistory"> | string
    fixApplied?: StringNullableFilter<"RepairHistory"> | string | null
    fixCode?: StringNullableFilter<"RepairHistory"> | string | null
    success?: BoolFilter<"RepairHistory"> | boolean
    timeToFixSeconds?: IntNullableFilter<"RepairHistory"> | number | null
    verificationResult?: JsonNullableFilter<"RepairHistory">
    rollbackPlan?: StringNullableFilter<"RepairHistory"> | string | null
    createdAt?: DateTimeFilter<"RepairHistory"> | Date | string
  }

  export type DiagnosticReportCreateWithoutRepairsInput = {
    id?: string
    alertId?: string | null
    issueType: string
    rootCause?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: string | null
    aiModel?: string | null
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    suggestedFix?: string | null
    severity?: string | null
    affectedUsers?: number | null
    createdAt?: Date | string
  }

  export type DiagnosticReportUncheckedCreateWithoutRepairsInput = {
    id?: string
    alertId?: string | null
    issueType: string
    rootCause?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: string | null
    aiModel?: string | null
    confidenceScore?: Decimal | DecimalJsLike | number | string | null
    suggestedFix?: string | null
    severity?: string | null
    affectedUsers?: number | null
    createdAt?: Date | string
  }

  export type DiagnosticReportCreateOrConnectWithoutRepairsInput = {
    where: DiagnosticReportWhereUniqueInput
    create: XOR<DiagnosticReportCreateWithoutRepairsInput, DiagnosticReportUncheckedCreateWithoutRepairsInput>
  }

  export type DiagnosticReportUpsertWithoutRepairsInput = {
    update: XOR<DiagnosticReportUpdateWithoutRepairsInput, DiagnosticReportUncheckedUpdateWithoutRepairsInput>
    create: XOR<DiagnosticReportCreateWithoutRepairsInput, DiagnosticReportUncheckedCreateWithoutRepairsInput>
    where?: DiagnosticReportWhereInput
  }

  export type DiagnosticReportUpdateToOneWithWhereWithoutRepairsInput = {
    where?: DiagnosticReportWhereInput
    data: XOR<DiagnosticReportUpdateWithoutRepairsInput, DiagnosticReportUncheckedUpdateWithoutRepairsInput>
  }

  export type DiagnosticReportUpdateWithoutRepairsInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: StringFieldUpdateOperationsInput | string
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    suggestedFix?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    affectedUsers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosticReportUncheckedUpdateWithoutRepairsInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: StringFieldUpdateOperationsInput | string
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    aiModel?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    suggestedFix?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    affectedUsers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogCreateWithoutAdminUserInput = {
    id?: string
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AdminAuditLogUncheckedCreateWithoutAdminUserInput = {
    id?: string
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AdminAuditLogCreateOrConnectWithoutAdminUserInput = {
    where: AdminAuditLogWhereUniqueInput
    create: XOR<AdminAuditLogCreateWithoutAdminUserInput, AdminAuditLogUncheckedCreateWithoutAdminUserInput>
  }

  export type AdminAuditLogCreateManyAdminUserInputEnvelope = {
    data: AdminAuditLogCreateManyAdminUserInput | AdminAuditLogCreateManyAdminUserInput[]
    skipDuplicates?: boolean
  }

  export type AdminAuditLogUpsertWithWhereUniqueWithoutAdminUserInput = {
    where: AdminAuditLogWhereUniqueInput
    update: XOR<AdminAuditLogUpdateWithoutAdminUserInput, AdminAuditLogUncheckedUpdateWithoutAdminUserInput>
    create: XOR<AdminAuditLogCreateWithoutAdminUserInput, AdminAuditLogUncheckedCreateWithoutAdminUserInput>
  }

  export type AdminAuditLogUpdateWithWhereUniqueWithoutAdminUserInput = {
    where: AdminAuditLogWhereUniqueInput
    data: XOR<AdminAuditLogUpdateWithoutAdminUserInput, AdminAuditLogUncheckedUpdateWithoutAdminUserInput>
  }

  export type AdminAuditLogUpdateManyWithWhereWithoutAdminUserInput = {
    where: AdminAuditLogScalarWhereInput
    data: XOR<AdminAuditLogUpdateManyMutationInput, AdminAuditLogUncheckedUpdateManyWithoutAdminUserInput>
  }

  export type AdminAuditLogScalarWhereInput = {
    AND?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
    OR?: AdminAuditLogScalarWhereInput[]
    NOT?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
    id?: StringFilter<"AdminAuditLog"> | string
    adminUserId?: StringFilter<"AdminAuditLog"> | string
    action?: StringFilter<"AdminAuditLog"> | string
    resource?: StringNullableFilter<"AdminAuditLog"> | string | null
    resourceId?: StringNullableFilter<"AdminAuditLog"> | string | null
    details?: JsonNullableFilter<"AdminAuditLog">
    ipAddress?: StringNullableFilter<"AdminAuditLog"> | string | null
    userAgent?: StringNullableFilter<"AdminAuditLog"> | string | null
    createdAt?: DateTimeFilter<"AdminAuditLog"> | Date | string
  }

  export type AdminUserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: string
    permissions?: AdminUserCreatepermissionsInput | string[]
    mfaEnabled?: boolean
    mfaSecret?: string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: string
    permissions?: AdminUserCreatepermissionsInput | string[]
    mfaEnabled?: boolean
    mfaSecret?: string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUserCreateOrConnectWithoutAuditLogsInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutAuditLogsInput, AdminUserUncheckedCreateWithoutAuditLogsInput>
  }

  export type AdminUserUpsertWithoutAuditLogsInput = {
    update: XOR<AdminUserUpdateWithoutAuditLogsInput, AdminUserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<AdminUserCreateWithoutAuditLogsInput, AdminUserUncheckedCreateWithoutAuditLogsInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutAuditLogsInput, AdminUserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type AdminUserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUserUpdatepermissionsInput | string[]
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUserUpdatepermissionsInput | string[]
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateManyUserInput = {
    id?: string
    email: string
    name?: string | null
    company?: string | null
    phone?: string | null
    title?: string | null
    website?: string | null
    linkedinUrl?: string | null
    source?: string | null
    status?: string
    score?: number | null
    notes?: string | null
    tags?: LeadCreatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastContactedAt?: Date | string | null
  }

  export type CampaignCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    type?: string
    status?: string
    subject?: string | null
    fromName?: string | null
    fromEmail?: string | null
    replyTo?: string | null
    templateId?: string | null
    htmlContent?: string | null
    textContent?: string | null
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    totalLeads?: number
    sentCount?: number
    openCount?: number
    clickCount?: number
    replyCount?: number
    bounceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateCreateManyUserInput = {
    id?: string
    name: string
    subject?: string | null
    htmlContent?: string | null
    textContent?: string | null
    variables?: EmailTemplateCreatevariablesInput | string[]
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebsiteCreateManyUserInput = {
    id?: string
    name: string
    domain?: string | null
    subdomain?: string | null
    pages?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    theme?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    filename?: string | null
    fileUrl?: string | null
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: number | null
    isMonetized?: boolean
    viewCount?: number
    earnings?: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyCreateManyUserInput = {
    id?: string
    name: string
    key: string
    permissions?: ApiKeyCreatepermissionsInput | string[]
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ConversationCreateManyUserInput = {
    id?: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    contactId?: string | null
    channel: string
    channelId?: string | null
    subject?: string | null
    status?: string
    priority?: string
    assignedTo?: string | null
    tags?: ConversationCreatetagsInput | string[]
    labels?: ConversationCreatelabelsInput | string[]
    messageCount?: number
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string | null
    closedAt?: Date | string | null
  }

  export type MessageCreateManyUserInput = {
    id?: string
    conversationId: string
    content: string
    htmlContent?: string | null
    subject?: string | null
    channel: string
    channelMessageId?: string | null
    direction?: string
    status?: string
    isRead?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type CannedResponseCreateManyUserInput = {
    id?: string
    name: string
    content: string
    htmlContent?: string | null
    subject?: string | null
    category?: string | null
    tags?: CannedResponseCreatetagsInput | string[]
    channels?: CannedResponseCreatechannelsInput | string[]
    variables?: CannedResponseCreatevariablesInput | string[]
    useCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutoResponseCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    enabled?: boolean
    triggerType: string
    conditions: JsonNullValueInput | InputJsonValue
    cannedResponseId?: string | null
    responseContent?: string | null
    responseSubject?: string | null
    channels?: AutoResponseCreatechannelsInput | string[]
    priority?: number
    delaySeconds?: number
    maxPerDay?: number | null
    maxPerContact?: number | null
    triggerCount?: number
    lastTriggeredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationNoteCreateManyUserInput = {
    id?: string
    conversationId: string
    content: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LeadUpdatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaignLeads?: CampaignLeadUpdateManyWithoutLeadNestedInput
    emailEvents?: EmailEventUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LeadUpdatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaignLeads?: CampaignLeadUncheckedUpdateManyWithoutLeadNestedInput
    emailEvents?: EmailEventUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LeadUpdatetagsInput | string[]
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastContactedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: EmailTemplateUpdateOneWithoutCampaignsNestedInput
    campaignLeads?: CampaignLeadUpdateManyWithoutCampaignNestedInput
    emailEvents?: EmailEventUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignLeads?: CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput
    emailEvents?: EmailEventUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: EmailTemplateUpdatevariablesInput | string[]
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    isMonetized?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    earnings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    isMonetized?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    earnings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    isMonetized?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    earnings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    permissions?: ApiKeyUpdatepermissionsInput | string[]
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    permissions?: ApiKeyUpdatepermissionsInput | string[]
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    permissions?: ApiKeyUpdatepermissionsInput | string[]
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ConversationUpdatetagsInput | string[]
    labels?: ConversationUpdatelabelsInput | string[]
    messageCount?: IntFieldUpdateOperationsInput | number
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutConversationNestedInput
    notes?: ConversationNoteUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ConversationUpdatetagsInput | string[]
    labels?: ConversationUpdatelabelsInput | string[]
    messageCount?: IntFieldUpdateOperationsInput | number
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    notes?: ConversationNoteUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ConversationUpdatetagsInput | string[]
    labels?: ConversationUpdatelabelsInput | string[]
    messageCount?: IntFieldUpdateOperationsInput | number
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    channelMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    channelMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    channelMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CannedResponseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CannedResponseUpdatetagsInput | string[]
    channels?: CannedResponseUpdatechannelsInput | string[]
    variables?: CannedResponseUpdatevariablesInput | string[]
    useCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AutoResponse?: AutoResponseUpdateManyWithoutCannedResponseNestedInput
  }

  export type CannedResponseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CannedResponseUpdatetagsInput | string[]
    channels?: CannedResponseUpdatechannelsInput | string[]
    variables?: CannedResponseUpdatevariablesInput | string[]
    useCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AutoResponse?: AutoResponseUncheckedUpdateManyWithoutCannedResponseNestedInput
  }

  export type CannedResponseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CannedResponseUpdatetagsInput | string[]
    channels?: CannedResponseUpdatechannelsInput | string[]
    variables?: CannedResponseUpdatevariablesInput | string[]
    useCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoResponseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    responseContent?: NullableStringFieldUpdateOperationsInput | string | null
    responseSubject?: NullableStringFieldUpdateOperationsInput | string | null
    channels?: AutoResponseUpdatechannelsInput | string[]
    priority?: IntFieldUpdateOperationsInput | number
    delaySeconds?: IntFieldUpdateOperationsInput | number
    maxPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    maxPerContact?: NullableIntFieldUpdateOperationsInput | number | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cannedResponse?: CannedResponseUpdateOneWithoutAutoResponseNestedInput
  }

  export type AutoResponseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    cannedResponseId?: NullableStringFieldUpdateOperationsInput | string | null
    responseContent?: NullableStringFieldUpdateOperationsInput | string | null
    responseSubject?: NullableStringFieldUpdateOperationsInput | string | null
    channels?: AutoResponseUpdatechannelsInput | string[]
    priority?: IntFieldUpdateOperationsInput | number
    delaySeconds?: IntFieldUpdateOperationsInput | number
    maxPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    maxPerContact?: NullableIntFieldUpdateOperationsInput | number | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoResponseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    cannedResponseId?: NullableStringFieldUpdateOperationsInput | string | null
    responseContent?: NullableStringFieldUpdateOperationsInput | string | null
    responseSubject?: NullableStringFieldUpdateOperationsInput | string | null
    channels?: AutoResponseUpdatechannelsInput | string[]
    priority?: IntFieldUpdateOperationsInput | number
    delaySeconds?: IntFieldUpdateOperationsInput | number
    maxPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    maxPerContact?: NullableIntFieldUpdateOperationsInput | number | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationNoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutNotesNestedInput
  }

  export type ConversationNoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationNoteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignLeadCreateManyLeadInput = {
    id?: string
    campaignId: string
    status?: string
    sentAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    repliedAt?: Date | string | null
  }

  export type EmailEventCreateManyLeadInput = {
    id?: string
    campaignId: string
    eventType: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CampaignLeadUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutCampaignLeadsNestedInput
  }

  export type CampaignLeadUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignLeadUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailEventUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutEmailEventsNestedInput
  }

  export type EmailEventUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailEventUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignLeadCreateManyCampaignInput = {
    id?: string
    leadId: string
    status?: string
    sentAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    repliedAt?: Date | string | null
  }

  export type EmailEventCreateManyCampaignInput = {
    id?: string
    leadId: string
    eventType: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CampaignLeadUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lead?: LeadUpdateOneRequiredWithoutCampaignLeadsNestedInput
  }

  export type CampaignLeadUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignLeadUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailEventUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: LeadUpdateOneRequiredWithoutEmailEventsNestedInput
  }

  export type EmailEventUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailEventUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateManyTemplateInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    type?: string
    status?: string
    subject?: string | null
    fromName?: string | null
    fromEmail?: string | null
    replyTo?: string | null
    htmlContent?: string | null
    textContent?: string | null
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    totalLeads?: number
    sentCount?: number
    openCount?: number
    clickCount?: number
    replyCount?: number
    bounceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    campaignLeads?: CampaignLeadUpdateManyWithoutCampaignNestedInput
    emailEvents?: EmailEventUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignLeads?: CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput
    emailEvents?: EmailEventUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    bounceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    userId: string
    content: string
    htmlContent?: string | null
    subject?: string | null
    channel: string
    channelMessageId?: string | null
    direction?: string
    status?: string
    isRead?: boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type ConversationNoteCreateManyConversationInput = {
    id?: string
    userId: string
    content: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    channelMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    channelMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    channelMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConversationNoteUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConversationNotesNestedInput
  }

  export type ConversationNoteUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationNoteUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoResponseCreateManyCannedResponseInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    enabled?: boolean
    triggerType: string
    conditions: JsonNullValueInput | InputJsonValue
    responseContent?: string | null
    responseSubject?: string | null
    channels?: AutoResponseCreatechannelsInput | string[]
    priority?: number
    delaySeconds?: number
    maxPerDay?: number | null
    maxPerContact?: number | null
    triggerCount?: number
    lastTriggeredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutoResponseUpdateWithoutCannedResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    responseContent?: NullableStringFieldUpdateOperationsInput | string | null
    responseSubject?: NullableStringFieldUpdateOperationsInput | string | null
    channels?: AutoResponseUpdatechannelsInput | string[]
    priority?: IntFieldUpdateOperationsInput | number
    delaySeconds?: IntFieldUpdateOperationsInput | number
    maxPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    maxPerContact?: NullableIntFieldUpdateOperationsInput | number | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAutoResponsesNestedInput
  }

  export type AutoResponseUncheckedUpdateWithoutCannedResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    responseContent?: NullableStringFieldUpdateOperationsInput | string | null
    responseSubject?: NullableStringFieldUpdateOperationsInput | string | null
    channels?: AutoResponseUpdatechannelsInput | string[]
    priority?: IntFieldUpdateOperationsInput | number
    delaySeconds?: IntFieldUpdateOperationsInput | number
    maxPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    maxPerContact?: NullableIntFieldUpdateOperationsInput | number | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoResponseUncheckedUpdateManyWithoutCannedResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    triggerType?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    responseContent?: NullableStringFieldUpdateOperationsInput | string | null
    responseSubject?: NullableStringFieldUpdateOperationsInput | string | null
    channels?: AutoResponseUpdatechannelsInput | string[]
    priority?: IntFieldUpdateOperationsInput | number
    delaySeconds?: IntFieldUpdateOperationsInput | number
    maxPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    maxPerContact?: NullableIntFieldUpdateOperationsInput | number | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairHistoryCreateManyDiagnosticInput = {
    id?: string
    repairType: string
    fixApplied?: string | null
    fixCode?: string | null
    success: boolean
    timeToFixSeconds?: number | null
    verificationResult?: NullableJsonNullValueInput | InputJsonValue
    rollbackPlan?: string | null
    createdAt?: Date | string
  }

  export type RepairHistoryUpdateWithoutDiagnosticInput = {
    id?: StringFieldUpdateOperationsInput | string
    repairType?: StringFieldUpdateOperationsInput | string
    fixApplied?: NullableStringFieldUpdateOperationsInput | string | null
    fixCode?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    timeToFixSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    verificationResult?: NullableJsonNullValueInput | InputJsonValue
    rollbackPlan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairHistoryUncheckedUpdateWithoutDiagnosticInput = {
    id?: StringFieldUpdateOperationsInput | string
    repairType?: StringFieldUpdateOperationsInput | string
    fixApplied?: NullableStringFieldUpdateOperationsInput | string | null
    fixCode?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    timeToFixSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    verificationResult?: NullableJsonNullValueInput | InputJsonValue
    rollbackPlan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairHistoryUncheckedUpdateManyWithoutDiagnosticInput = {
    id?: StringFieldUpdateOperationsInput | string
    repairType?: StringFieldUpdateOperationsInput | string
    fixApplied?: NullableStringFieldUpdateOperationsInput | string | null
    fixCode?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    timeToFixSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    verificationResult?: NullableJsonNullValueInput | InputJsonValue
    rollbackPlan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogCreateManyAdminUserInput = {
    id?: string
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AdminAuditLogUpdateWithoutAdminUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUncheckedUpdateWithoutAdminUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUncheckedUpdateManyWithoutAdminUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeadCountOutputTypeDefaultArgs instead
     */
    export type LeadCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeadCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignCountOutputTypeDefaultArgs instead
     */
    export type CampaignCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailTemplateCountOutputTypeDefaultArgs instead
     */
    export type EmailTemplateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationCountOutputTypeDefaultArgs instead
     */
    export type ConversationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CannedResponseCountOutputTypeDefaultArgs instead
     */
    export type CannedResponseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CannedResponseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiagnosticReportCountOutputTypeDefaultArgs instead
     */
    export type DiagnosticReportCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiagnosticReportCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminUserCountOutputTypeDefaultArgs instead
     */
    export type AdminUserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminUserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeadDefaultArgs instead
     */
    export type LeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignDefaultArgs instead
     */
    export type CampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignLeadDefaultArgs instead
     */
    export type CampaignLeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignLeadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailTemplateDefaultArgs instead
     */
    export type EmailTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailEventDefaultArgs instead
     */
    export type EmailEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebsiteDefaultArgs instead
     */
    export type WebsiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebsiteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VideoDefaultArgs instead
     */
    export type VideoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VideoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiKeyDefaultArgs instead
     */
    export type ApiKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiKeyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationDefaultArgs instead
     */
    export type ConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CannedResponseDefaultArgs instead
     */
    export type CannedResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CannedResponseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AutoResponseDefaultArgs instead
     */
    export type AutoResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AutoResponseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationNoteDefaultArgs instead
     */
    export type ConversationNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationNoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemHealthMetricDefaultArgs instead
     */
    export type SystemHealthMetricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemHealthMetricDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiagnosticReportDefaultArgs instead
     */
    export type DiagnosticReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiagnosticReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RepairHistoryDefaultArgs instead
     */
    export type RepairHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RepairHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LearningPatternDefaultArgs instead
     */
    export type LearningPatternArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LearningPatternDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PredictionDefaultArgs instead
     */
    export type PredictionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PredictionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SecurityIncidentDefaultArgs instead
     */
    export type SecurityIncidentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SecurityIncidentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PerformanceMetricDefaultArgs instead
     */
    export type PerformanceMetricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PerformanceMetricDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemAlertDefaultArgs instead
     */
    export type SystemAlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemAlertDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminUserDefaultArgs instead
     */
    export type AdminUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminAuditLogDefaultArgs instead
     */
    export type AdminAuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminAuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminSessionDefaultArgs instead
     */
    export type AdminSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminSessionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}